
/**
 * Client
**/

import * as runtime from '@prisma/client/runtime/library.js';
import $Types = runtime.Types // general types
import $Public = runtime.Types.Public
import $Utils = runtime.Types.Utils
import $Extensions = runtime.Types.Extensions
import $Result = runtime.Types.Result

export type PrismaPromise<T> = $Public.PrismaPromise<T>


/**
 * Model User
 * 
 */
export type User = $Result.DefaultSelection<Prisma.$UserPayload>
/**
 * Model Subscription
 * 
 */
export type Subscription = $Result.DefaultSelection<Prisma.$SubscriptionPayload>
/**
 * Model Invoice
 * 
 */
export type Invoice = $Result.DefaultSelection<Prisma.$InvoicePayload>
/**
 * Model MikrotikDevice
 * 
 */
export type MikrotikDevice = $Result.DefaultSelection<Prisma.$MikrotikDevicePayload>
/**
 * Model Domain
 * 
 */
export type Domain = $Result.DefaultSelection<Prisma.$DomainPayload>
/**
 * Model ProxmoxServer
 * 
 */
export type ProxmoxServer = $Result.DefaultSelection<Prisma.$ProxmoxServerPayload>
/**
 * Model ProxmoxNode
 * 
 */
export type ProxmoxNode = $Result.DefaultSelection<Prisma.$ProxmoxNodePayload>
/**
 * Model ProxmoxVM
 * 
 */
export type ProxmoxVM = $Result.DefaultSelection<Prisma.$ProxmoxVMPayload>
/**
 * Model ProxmoxMetric
 * 
 */
export type ProxmoxMetric = $Result.DefaultSelection<Prisma.$ProxmoxMetricPayload>
/**
 * Model Site
 * 
 */
export type Site = $Result.DefaultSelection<Prisma.$SitePayload>
/**
 * Model Vlan
 * 
 */
export type Vlan = $Result.DefaultSelection<Prisma.$VlanPayload>
/**
 * Model NetworkSubnet
 * 
 */
export type NetworkSubnet = $Result.DefaultSelection<Prisma.$NetworkSubnetPayload>
/**
 * Model NetworkIP
 * 
 */
export type NetworkIP = $Result.DefaultSelection<Prisma.$NetworkIPPayload>
/**
 * Model NetworkDevice
 * 
 */
export type NetworkDevice = $Result.DefaultSelection<Prisma.$NetworkDevicePayload>
/**
 * Model NetworkService
 * 
 */
export type NetworkService = $Result.DefaultSelection<Prisma.$NetworkServicePayload>

/**
 * Enums
 */
export namespace $Enums {
  export const IPStatus: {
  AVAILABLE: 'AVAILABLE',
  RESERVED: 'RESERVED',
  ASSIGNED: 'ASSIGNED'
};

export type IPStatus = (typeof IPStatus)[keyof typeof IPStatus]


export const DeviceType: {
  ROUTER: 'ROUTER',
  SWITCH: 'SWITCH',
  FIREWALL: 'FIREWALL',
  SERVER: 'SERVER',
  VM: 'VM',
  AP: 'AP',
  NAS: 'NAS',
  OTHER: 'OTHER'
};

export type DeviceType = (typeof DeviceType)[keyof typeof DeviceType]


export const Protocol: {
  TCP: 'TCP',
  UDP: 'UDP',
  SCTP: 'SCTP',
  ICMP: 'ICMP',
  OTHER: 'OTHER'
};

export type Protocol = (typeof Protocol)[keyof typeof Protocol]

}

export type IPStatus = $Enums.IPStatus

export const IPStatus: typeof $Enums.IPStatus

export type DeviceType = $Enums.DeviceType

export const DeviceType: typeof $Enums.DeviceType

export type Protocol = $Enums.Protocol

export const Protocol: typeof $Enums.Protocol

/**
 * ##  Prisma Client ʲˢ
 *
 * Type-safe database client for TypeScript & Node.js
 * @example
 * ```
 * const prisma = new PrismaClient()
 * // Fetch zero or more Users
 * const users = await prisma.user.findMany()
 * ```
 *
 *
 * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
 */
export class PrismaClient<
  ClientOptions extends Prisma.PrismaClientOptions = Prisma.PrismaClientOptions,
  const U = 'log' extends keyof ClientOptions ? ClientOptions['log'] extends Array<Prisma.LogLevel | Prisma.LogDefinition> ? Prisma.GetEvents<ClientOptions['log']> : never : never,
  ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
> {
  [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['other'] }

    /**
   * ##  Prisma Client ʲˢ
   *
   * Type-safe database client for TypeScript & Node.js
   * @example
   * ```
   * const prisma = new PrismaClient()
   * // Fetch zero or more Users
   * const users = await prisma.user.findMany()
   * ```
   *
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
   */

  constructor(optionsArg ?: Prisma.Subset<ClientOptions, Prisma.PrismaClientOptions>);
  $on<V extends U>(eventType: V, callback: (event: V extends 'query' ? Prisma.QueryEvent : Prisma.LogEvent) => void): PrismaClient;

  /**
   * Connect with the database
   */
  $connect(): $Utils.JsPromise<void>;

  /**
   * Disconnect from the database
   */
  $disconnect(): $Utils.JsPromise<void>;

/**
   * Executes a prepared raw query and returns the number of affected rows.
   * @example
   * ```
   * const result = await prisma.$executeRaw`UPDATE User SET cool = ${true} WHERE email = ${'user@email.com'};`
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Executes a raw query and returns the number of affected rows.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$executeRawUnsafe('UPDATE User SET cool = $1 WHERE email = $2 ;', true, 'user@email.com')
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Performs a prepared raw query and returns the `SELECT` data.
   * @example
   * ```
   * const result = await prisma.$queryRaw`SELECT * FROM User WHERE id = ${1} OR email = ${'user@email.com'};`
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<T>;

  /**
   * Performs a raw query and returns the `SELECT` data.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$queryRawUnsafe('SELECT * FROM User WHERE id = $1 OR email = $2;', 1, 'user@email.com')
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<T>;


  /**
   * Allows the running of a sequence of read/write operations that are guaranteed to either succeed or fail as a whole.
   * @example
   * ```
   * const [george, bob, alice] = await prisma.$transaction([
   *   prisma.user.create({ data: { name: 'George' } }),
   *   prisma.user.create({ data: { name: 'Bob' } }),
   *   prisma.user.create({ data: { name: 'Alice' } }),
   * ])
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/concepts/components/prisma-client/transactions).
   */
  $transaction<P extends Prisma.PrismaPromise<any>[]>(arg: [...P], options?: { isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<runtime.Types.Utils.UnwrapTuple<P>>

  $transaction<R>(fn: (prisma: Omit<PrismaClient, runtime.ITXClientDenyList>) => $Utils.JsPromise<R>, options?: { maxWait?: number, timeout?: number, isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<R>


  $extends: $Extensions.ExtendsHook<"extends", Prisma.TypeMapCb<ClientOptions>, ExtArgs, $Utils.Call<Prisma.TypeMapCb<ClientOptions>, {
    extArgs: ExtArgs
  }>>

      /**
   * `prisma.user`: Exposes CRUD operations for the **User** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Users
    * const users = await prisma.user.findMany()
    * ```
    */
  get user(): Prisma.UserDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.subscription`: Exposes CRUD operations for the **Subscription** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Subscriptions
    * const subscriptions = await prisma.subscription.findMany()
    * ```
    */
  get subscription(): Prisma.SubscriptionDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.invoice`: Exposes CRUD operations for the **Invoice** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Invoices
    * const invoices = await prisma.invoice.findMany()
    * ```
    */
  get invoice(): Prisma.InvoiceDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.mikrotikDevice`: Exposes CRUD operations for the **MikrotikDevice** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more MikrotikDevices
    * const mikrotikDevices = await prisma.mikrotikDevice.findMany()
    * ```
    */
  get mikrotikDevice(): Prisma.MikrotikDeviceDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.domain`: Exposes CRUD operations for the **Domain** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Domains
    * const domains = await prisma.domain.findMany()
    * ```
    */
  get domain(): Prisma.DomainDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.proxmoxServer`: Exposes CRUD operations for the **ProxmoxServer** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ProxmoxServers
    * const proxmoxServers = await prisma.proxmoxServer.findMany()
    * ```
    */
  get proxmoxServer(): Prisma.ProxmoxServerDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.proxmoxNode`: Exposes CRUD operations for the **ProxmoxNode** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ProxmoxNodes
    * const proxmoxNodes = await prisma.proxmoxNode.findMany()
    * ```
    */
  get proxmoxNode(): Prisma.ProxmoxNodeDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.proxmoxVM`: Exposes CRUD operations for the **ProxmoxVM** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ProxmoxVMS
    * const proxmoxVMS = await prisma.proxmoxVM.findMany()
    * ```
    */
  get proxmoxVM(): Prisma.ProxmoxVMDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.proxmoxMetric`: Exposes CRUD operations for the **ProxmoxMetric** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ProxmoxMetrics
    * const proxmoxMetrics = await prisma.proxmoxMetric.findMany()
    * ```
    */
  get proxmoxMetric(): Prisma.ProxmoxMetricDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.site`: Exposes CRUD operations for the **Site** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Sites
    * const sites = await prisma.site.findMany()
    * ```
    */
  get site(): Prisma.SiteDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.vlan`: Exposes CRUD operations for the **Vlan** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Vlans
    * const vlans = await prisma.vlan.findMany()
    * ```
    */
  get vlan(): Prisma.VlanDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.networkSubnet`: Exposes CRUD operations for the **NetworkSubnet** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more NetworkSubnets
    * const networkSubnets = await prisma.networkSubnet.findMany()
    * ```
    */
  get networkSubnet(): Prisma.NetworkSubnetDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.networkIP`: Exposes CRUD operations for the **NetworkIP** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more NetworkIPS
    * const networkIPS = await prisma.networkIP.findMany()
    * ```
    */
  get networkIP(): Prisma.NetworkIPDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.networkDevice`: Exposes CRUD operations for the **NetworkDevice** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more NetworkDevices
    * const networkDevices = await prisma.networkDevice.findMany()
    * ```
    */
  get networkDevice(): Prisma.NetworkDeviceDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.networkService`: Exposes CRUD operations for the **NetworkService** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more NetworkServices
    * const networkServices = await prisma.networkService.findMany()
    * ```
    */
  get networkService(): Prisma.NetworkServiceDelegate<ExtArgs, ClientOptions>;
}

export namespace Prisma {
  export import DMMF = runtime.DMMF

  export type PrismaPromise<T> = $Public.PrismaPromise<T>

  /**
   * Validator
   */
  export import validator = runtime.Public.validator

  /**
   * Prisma Errors
   */
  export import PrismaClientKnownRequestError = runtime.PrismaClientKnownRequestError
  export import PrismaClientUnknownRequestError = runtime.PrismaClientUnknownRequestError
  export import PrismaClientRustPanicError = runtime.PrismaClientRustPanicError
  export import PrismaClientInitializationError = runtime.PrismaClientInitializationError
  export import PrismaClientValidationError = runtime.PrismaClientValidationError

  /**
   * Re-export of sql-template-tag
   */
  export import sql = runtime.sqltag
  export import empty = runtime.empty
  export import join = runtime.join
  export import raw = runtime.raw
  export import Sql = runtime.Sql



  /**
   * Decimal.js
   */
  export import Decimal = runtime.Decimal

  export type DecimalJsLike = runtime.DecimalJsLike

  /**
   * Metrics
   */
  export type Metrics = runtime.Metrics
  export type Metric<T> = runtime.Metric<T>
  export type MetricHistogram = runtime.MetricHistogram
  export type MetricHistogramBucket = runtime.MetricHistogramBucket

  /**
  * Extensions
  */
  export import Extension = $Extensions.UserArgs
  export import getExtensionContext = runtime.Extensions.getExtensionContext
  export import Args = $Public.Args
  export import Payload = $Public.Payload
  export import Result = $Public.Result
  export import Exact = $Public.Exact

  /**
   * Prisma Client JS version: 6.18.0
   * Query Engine version: 34b5a692b7bd79939a9a2c3ef97d816e749cda2f
   */
  export type PrismaVersion = {
    client: string
  }

  export const prismaVersion: PrismaVersion

  /**
   * Utility Types
   */


  export import Bytes = runtime.Bytes
  export import JsonObject = runtime.JsonObject
  export import JsonArray = runtime.JsonArray
  export import JsonValue = runtime.JsonValue
  export import InputJsonObject = runtime.InputJsonObject
  export import InputJsonArray = runtime.InputJsonArray
  export import InputJsonValue = runtime.InputJsonValue

  /**
   * Types of the values used to represent different kinds of `null` values when working with JSON fields.
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  namespace NullTypes {
    /**
    * Type of `Prisma.DbNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.DbNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class DbNull {
      private DbNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.JsonNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.JsonNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class JsonNull {
      private JsonNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.AnyNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.AnyNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class AnyNull {
      private AnyNull: never
      private constructor()
    }
  }

  /**
   * Helper for filtering JSON entries that have `null` on the database (empty on the db)
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const DbNull: NullTypes.DbNull

  /**
   * Helper for filtering JSON entries that have JSON `null` values (not empty on the db)
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const JsonNull: NullTypes.JsonNull

  /**
   * Helper for filtering JSON entries that are `Prisma.DbNull` or `Prisma.JsonNull`
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const AnyNull: NullTypes.AnyNull

  type SelectAndInclude = {
    select: any
    include: any
  }

  type SelectAndOmit = {
    select: any
    omit: any
  }

  /**
   * Get the type of the value, that the Promise holds.
   */
  export type PromiseType<T extends PromiseLike<any>> = T extends PromiseLike<infer U> ? U : T;

  /**
   * Get the return type of a function which returns a Promise.
   */
  export type PromiseReturnType<T extends (...args: any) => $Utils.JsPromise<any>> = PromiseType<ReturnType<T>>

  /**
   * From T, pick a set of properties whose keys are in the union K
   */
  type Prisma__Pick<T, K extends keyof T> = {
      [P in K]: T[P];
  };


  export type Enumerable<T> = T | Array<T>;

  export type RequiredKeys<T> = {
    [K in keyof T]-?: {} extends Prisma__Pick<T, K> ? never : K
  }[keyof T]

  export type TruthyKeys<T> = keyof {
    [K in keyof T as T[K] extends false | undefined | null ? never : K]: K
  }

  export type TrueKeys<T> = TruthyKeys<Prisma__Pick<T, RequiredKeys<T>>>

  /**
   * Subset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection
   */
  export type Subset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never;
  };

  /**
   * SelectSubset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection.
   * Additionally, it validates, if both select and include are present. If the case, it errors.
   */
  export type SelectSubset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    (T extends SelectAndInclude
      ? 'Please either choose `select` or `include`.'
      : T extends SelectAndOmit
        ? 'Please either choose `select` or `omit`.'
        : {})

  /**
   * Subset + Intersection
   * @desc From `T` pick properties that exist in `U` and intersect `K`
   */
  export type SubsetIntersection<T, U, K> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    K

  type Without<T, U> = { [P in Exclude<keyof T, keyof U>]?: never };

  /**
   * XOR is needed to have a real mutually exclusive union type
   * https://stackoverflow.com/questions/42123407/does-typescript-support-mutually-exclusive-types
   */
  type XOR<T, U> =
    T extends object ?
    U extends object ?
      (Without<T, U> & U) | (Without<U, T> & T)
    : U : T


  /**
   * Is T a Record?
   */
  type IsObject<T extends any> = T extends Array<any>
  ? False
  : T extends Date
  ? False
  : T extends Uint8Array
  ? False
  : T extends BigInt
  ? False
  : T extends object
  ? True
  : False


  /**
   * If it's T[], return T
   */
  export type UnEnumerate<T extends unknown> = T extends Array<infer U> ? U : T

  /**
   * From ts-toolbelt
   */

  type __Either<O extends object, K extends Key> = Omit<O, K> &
    {
      // Merge all but K
      [P in K]: Prisma__Pick<O, P & keyof O> // With K possibilities
    }[K]

  type EitherStrict<O extends object, K extends Key> = Strict<__Either<O, K>>

  type EitherLoose<O extends object, K extends Key> = ComputeRaw<__Either<O, K>>

  type _Either<
    O extends object,
    K extends Key,
    strict extends Boolean
  > = {
    1: EitherStrict<O, K>
    0: EitherLoose<O, K>
  }[strict]

  type Either<
    O extends object,
    K extends Key,
    strict extends Boolean = 1
  > = O extends unknown ? _Either<O, K, strict> : never

  export type Union = any

  type PatchUndefined<O extends object, O1 extends object> = {
    [K in keyof O]: O[K] extends undefined ? At<O1, K> : O[K]
  } & {}

  /** Helper Types for "Merge" **/
  export type IntersectOf<U extends Union> = (
    U extends unknown ? (k: U) => void : never
  ) extends (k: infer I) => void
    ? I
    : never

  export type Overwrite<O extends object, O1 extends object> = {
      [K in keyof O]: K extends keyof O1 ? O1[K] : O[K];
  } & {};

  type _Merge<U extends object> = IntersectOf<Overwrite<U, {
      [K in keyof U]-?: At<U, K>;
  }>>;

  type Key = string | number | symbol;
  type AtBasic<O extends object, K extends Key> = K extends keyof O ? O[K] : never;
  type AtStrict<O extends object, K extends Key> = O[K & keyof O];
  type AtLoose<O extends object, K extends Key> = O extends unknown ? AtStrict<O, K> : never;
  export type At<O extends object, K extends Key, strict extends Boolean = 1> = {
      1: AtStrict<O, K>;
      0: AtLoose<O, K>;
  }[strict];

  export type ComputeRaw<A extends any> = A extends Function ? A : {
    [K in keyof A]: A[K];
  } & {};

  export type OptionalFlat<O> = {
    [K in keyof O]?: O[K];
  } & {};

  type _Record<K extends keyof any, T> = {
    [P in K]: T;
  };

  // cause typescript not to expand types and preserve names
  type NoExpand<T> = T extends unknown ? T : never;

  // this type assumes the passed object is entirely optional
  type AtLeast<O extends object, K extends string> = NoExpand<
    O extends unknown
    ? | (K extends keyof O ? { [P in K]: O[P] } & O : O)
      | {[P in keyof O as P extends K ? P : never]-?: O[P]} & O
    : never>;

  type _Strict<U, _U = U> = U extends unknown ? U & OptionalFlat<_Record<Exclude<Keys<_U>, keyof U>, never>> : never;

  export type Strict<U extends object> = ComputeRaw<_Strict<U>>;
  /** End Helper Types for "Merge" **/

  export type Merge<U extends object> = ComputeRaw<_Merge<Strict<U>>>;

  /**
  A [[Boolean]]
  */
  export type Boolean = True | False

  // /**
  // 1
  // */
  export type True = 1

  /**
  0
  */
  export type False = 0

  export type Not<B extends Boolean> = {
    0: 1
    1: 0
  }[B]

  export type Extends<A1 extends any, A2 extends any> = [A1] extends [never]
    ? 0 // anything `never` is false
    : A1 extends A2
    ? 1
    : 0

  export type Has<U extends Union, U1 extends Union> = Not<
    Extends<Exclude<U1, U>, U1>
  >

  export type Or<B1 extends Boolean, B2 extends Boolean> = {
    0: {
      0: 0
      1: 1
    }
    1: {
      0: 1
      1: 1
    }
  }[B1][B2]

  export type Keys<U extends Union> = U extends unknown ? keyof U : never

  type Cast<A, B> = A extends B ? A : B;

  export const type: unique symbol;



  /**
   * Used by group by
   */

  export type GetScalarType<T, O> = O extends object ? {
    [P in keyof T]: P extends keyof O
      ? O[P]
      : never
  } : never

  type FieldPaths<
    T,
    U = Omit<T, '_avg' | '_sum' | '_count' | '_min' | '_max'>
  > = IsObject<T> extends True ? U : T

  type GetHavingFields<T> = {
    [K in keyof T]: Or<
      Or<Extends<'OR', K>, Extends<'AND', K>>,
      Extends<'NOT', K>
    > extends True
      ? // infer is only needed to not hit TS limit
        // based on the brilliant idea of Pierre-Antoine Mills
        // https://github.com/microsoft/TypeScript/issues/30188#issuecomment-478938437
        T[K] extends infer TK
        ? GetHavingFields<UnEnumerate<TK> extends object ? Merge<UnEnumerate<TK>> : never>
        : never
      : {} extends FieldPaths<T[K]>
      ? never
      : K
  }[keyof T]

  /**
   * Convert tuple to union
   */
  type _TupleToUnion<T> = T extends (infer E)[] ? E : never
  type TupleToUnion<K extends readonly any[]> = _TupleToUnion<K>
  type MaybeTupleToUnion<T> = T extends any[] ? TupleToUnion<T> : T

  /**
   * Like `Pick`, but additionally can also accept an array of keys
   */
  type PickEnumerable<T, K extends Enumerable<keyof T> | keyof T> = Prisma__Pick<T, MaybeTupleToUnion<K>>

  /**
   * Exclude all keys with underscores
   */
  type ExcludeUnderscoreKeys<T extends string> = T extends `_${string}` ? never : T


  export type FieldRef<Model, FieldType> = runtime.FieldRef<Model, FieldType>

  type FieldRefInputType<Model, FieldType> = Model extends never ? never : FieldRef<Model, FieldType>


  export const ModelName: {
    User: 'User',
    Subscription: 'Subscription',
    Invoice: 'Invoice',
    MikrotikDevice: 'MikrotikDevice',
    Domain: 'Domain',
    ProxmoxServer: 'ProxmoxServer',
    ProxmoxNode: 'ProxmoxNode',
    ProxmoxVM: 'ProxmoxVM',
    ProxmoxMetric: 'ProxmoxMetric',
    Site: 'Site',
    Vlan: 'Vlan',
    NetworkSubnet: 'NetworkSubnet',
    NetworkIP: 'NetworkIP',
    NetworkDevice: 'NetworkDevice',
    NetworkService: 'NetworkService'
  };

  export type ModelName = (typeof ModelName)[keyof typeof ModelName]


  export type Datasources = {
    db?: Datasource
  }

  interface TypeMapCb<ClientOptions = {}> extends $Utils.Fn<{extArgs: $Extensions.InternalArgs }, $Utils.Record<string, any>> {
    returns: Prisma.TypeMap<this['params']['extArgs'], ClientOptions extends { omit: infer OmitOptions } ? OmitOptions : {}>
  }

  export type TypeMap<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> = {
    globalOmitOptions: {
      omit: GlobalOmitOptions
    }
    meta: {
      modelProps: "user" | "subscription" | "invoice" | "mikrotikDevice" | "domain" | "proxmoxServer" | "proxmoxNode" | "proxmoxVM" | "proxmoxMetric" | "site" | "vlan" | "networkSubnet" | "networkIP" | "networkDevice" | "networkService"
      txIsolationLevel: Prisma.TransactionIsolationLevel
    }
    model: {
      User: {
        payload: Prisma.$UserPayload<ExtArgs>
        fields: Prisma.UserFieldRefs
        operations: {
          findUnique: {
            args: Prisma.UserFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.UserFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          findFirst: {
            args: Prisma.UserFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.UserFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          findMany: {
            args: Prisma.UserFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>[]
          }
          create: {
            args: Prisma.UserCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          createMany: {
            args: Prisma.UserCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.UserCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>[]
          }
          delete: {
            args: Prisma.UserDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          update: {
            args: Prisma.UserUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          deleteMany: {
            args: Prisma.UserDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.UserUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.UserUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>[]
          }
          upsert: {
            args: Prisma.UserUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          aggregate: {
            args: Prisma.UserAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateUser>
          }
          groupBy: {
            args: Prisma.UserGroupByArgs<ExtArgs>
            result: $Utils.Optional<UserGroupByOutputType>[]
          }
          count: {
            args: Prisma.UserCountArgs<ExtArgs>
            result: $Utils.Optional<UserCountAggregateOutputType> | number
          }
        }
      }
      Subscription: {
        payload: Prisma.$SubscriptionPayload<ExtArgs>
        fields: Prisma.SubscriptionFieldRefs
        operations: {
          findUnique: {
            args: Prisma.SubscriptionFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubscriptionPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.SubscriptionFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubscriptionPayload>
          }
          findFirst: {
            args: Prisma.SubscriptionFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubscriptionPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.SubscriptionFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubscriptionPayload>
          }
          findMany: {
            args: Prisma.SubscriptionFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubscriptionPayload>[]
          }
          create: {
            args: Prisma.SubscriptionCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubscriptionPayload>
          }
          createMany: {
            args: Prisma.SubscriptionCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.SubscriptionCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubscriptionPayload>[]
          }
          delete: {
            args: Prisma.SubscriptionDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubscriptionPayload>
          }
          update: {
            args: Prisma.SubscriptionUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubscriptionPayload>
          }
          deleteMany: {
            args: Prisma.SubscriptionDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.SubscriptionUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.SubscriptionUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubscriptionPayload>[]
          }
          upsert: {
            args: Prisma.SubscriptionUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubscriptionPayload>
          }
          aggregate: {
            args: Prisma.SubscriptionAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateSubscription>
          }
          groupBy: {
            args: Prisma.SubscriptionGroupByArgs<ExtArgs>
            result: $Utils.Optional<SubscriptionGroupByOutputType>[]
          }
          count: {
            args: Prisma.SubscriptionCountArgs<ExtArgs>
            result: $Utils.Optional<SubscriptionCountAggregateOutputType> | number
          }
        }
      }
      Invoice: {
        payload: Prisma.$InvoicePayload<ExtArgs>
        fields: Prisma.InvoiceFieldRefs
        operations: {
          findUnique: {
            args: Prisma.InvoiceFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InvoicePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.InvoiceFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InvoicePayload>
          }
          findFirst: {
            args: Prisma.InvoiceFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InvoicePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.InvoiceFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InvoicePayload>
          }
          findMany: {
            args: Prisma.InvoiceFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InvoicePayload>[]
          }
          create: {
            args: Prisma.InvoiceCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InvoicePayload>
          }
          createMany: {
            args: Prisma.InvoiceCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.InvoiceCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InvoicePayload>[]
          }
          delete: {
            args: Prisma.InvoiceDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InvoicePayload>
          }
          update: {
            args: Prisma.InvoiceUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InvoicePayload>
          }
          deleteMany: {
            args: Prisma.InvoiceDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.InvoiceUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.InvoiceUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InvoicePayload>[]
          }
          upsert: {
            args: Prisma.InvoiceUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InvoicePayload>
          }
          aggregate: {
            args: Prisma.InvoiceAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateInvoice>
          }
          groupBy: {
            args: Prisma.InvoiceGroupByArgs<ExtArgs>
            result: $Utils.Optional<InvoiceGroupByOutputType>[]
          }
          count: {
            args: Prisma.InvoiceCountArgs<ExtArgs>
            result: $Utils.Optional<InvoiceCountAggregateOutputType> | number
          }
        }
      }
      MikrotikDevice: {
        payload: Prisma.$MikrotikDevicePayload<ExtArgs>
        fields: Prisma.MikrotikDeviceFieldRefs
        operations: {
          findUnique: {
            args: Prisma.MikrotikDeviceFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MikrotikDevicePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.MikrotikDeviceFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MikrotikDevicePayload>
          }
          findFirst: {
            args: Prisma.MikrotikDeviceFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MikrotikDevicePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.MikrotikDeviceFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MikrotikDevicePayload>
          }
          findMany: {
            args: Prisma.MikrotikDeviceFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MikrotikDevicePayload>[]
          }
          create: {
            args: Prisma.MikrotikDeviceCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MikrotikDevicePayload>
          }
          createMany: {
            args: Prisma.MikrotikDeviceCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.MikrotikDeviceCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MikrotikDevicePayload>[]
          }
          delete: {
            args: Prisma.MikrotikDeviceDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MikrotikDevicePayload>
          }
          update: {
            args: Prisma.MikrotikDeviceUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MikrotikDevicePayload>
          }
          deleteMany: {
            args: Prisma.MikrotikDeviceDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.MikrotikDeviceUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.MikrotikDeviceUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MikrotikDevicePayload>[]
          }
          upsert: {
            args: Prisma.MikrotikDeviceUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MikrotikDevicePayload>
          }
          aggregate: {
            args: Prisma.MikrotikDeviceAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateMikrotikDevice>
          }
          groupBy: {
            args: Prisma.MikrotikDeviceGroupByArgs<ExtArgs>
            result: $Utils.Optional<MikrotikDeviceGroupByOutputType>[]
          }
          count: {
            args: Prisma.MikrotikDeviceCountArgs<ExtArgs>
            result: $Utils.Optional<MikrotikDeviceCountAggregateOutputType> | number
          }
        }
      }
      Domain: {
        payload: Prisma.$DomainPayload<ExtArgs>
        fields: Prisma.DomainFieldRefs
        operations: {
          findUnique: {
            args: Prisma.DomainFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DomainPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.DomainFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DomainPayload>
          }
          findFirst: {
            args: Prisma.DomainFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DomainPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.DomainFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DomainPayload>
          }
          findMany: {
            args: Prisma.DomainFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DomainPayload>[]
          }
          create: {
            args: Prisma.DomainCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DomainPayload>
          }
          createMany: {
            args: Prisma.DomainCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.DomainCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DomainPayload>[]
          }
          delete: {
            args: Prisma.DomainDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DomainPayload>
          }
          update: {
            args: Prisma.DomainUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DomainPayload>
          }
          deleteMany: {
            args: Prisma.DomainDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.DomainUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.DomainUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DomainPayload>[]
          }
          upsert: {
            args: Prisma.DomainUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DomainPayload>
          }
          aggregate: {
            args: Prisma.DomainAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateDomain>
          }
          groupBy: {
            args: Prisma.DomainGroupByArgs<ExtArgs>
            result: $Utils.Optional<DomainGroupByOutputType>[]
          }
          count: {
            args: Prisma.DomainCountArgs<ExtArgs>
            result: $Utils.Optional<DomainCountAggregateOutputType> | number
          }
        }
      }
      ProxmoxServer: {
        payload: Prisma.$ProxmoxServerPayload<ExtArgs>
        fields: Prisma.ProxmoxServerFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ProxmoxServerFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProxmoxServerPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ProxmoxServerFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProxmoxServerPayload>
          }
          findFirst: {
            args: Prisma.ProxmoxServerFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProxmoxServerPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ProxmoxServerFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProxmoxServerPayload>
          }
          findMany: {
            args: Prisma.ProxmoxServerFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProxmoxServerPayload>[]
          }
          create: {
            args: Prisma.ProxmoxServerCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProxmoxServerPayload>
          }
          createMany: {
            args: Prisma.ProxmoxServerCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ProxmoxServerCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProxmoxServerPayload>[]
          }
          delete: {
            args: Prisma.ProxmoxServerDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProxmoxServerPayload>
          }
          update: {
            args: Prisma.ProxmoxServerUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProxmoxServerPayload>
          }
          deleteMany: {
            args: Prisma.ProxmoxServerDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ProxmoxServerUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ProxmoxServerUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProxmoxServerPayload>[]
          }
          upsert: {
            args: Prisma.ProxmoxServerUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProxmoxServerPayload>
          }
          aggregate: {
            args: Prisma.ProxmoxServerAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateProxmoxServer>
          }
          groupBy: {
            args: Prisma.ProxmoxServerGroupByArgs<ExtArgs>
            result: $Utils.Optional<ProxmoxServerGroupByOutputType>[]
          }
          count: {
            args: Prisma.ProxmoxServerCountArgs<ExtArgs>
            result: $Utils.Optional<ProxmoxServerCountAggregateOutputType> | number
          }
        }
      }
      ProxmoxNode: {
        payload: Prisma.$ProxmoxNodePayload<ExtArgs>
        fields: Prisma.ProxmoxNodeFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ProxmoxNodeFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProxmoxNodePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ProxmoxNodeFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProxmoxNodePayload>
          }
          findFirst: {
            args: Prisma.ProxmoxNodeFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProxmoxNodePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ProxmoxNodeFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProxmoxNodePayload>
          }
          findMany: {
            args: Prisma.ProxmoxNodeFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProxmoxNodePayload>[]
          }
          create: {
            args: Prisma.ProxmoxNodeCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProxmoxNodePayload>
          }
          createMany: {
            args: Prisma.ProxmoxNodeCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ProxmoxNodeCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProxmoxNodePayload>[]
          }
          delete: {
            args: Prisma.ProxmoxNodeDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProxmoxNodePayload>
          }
          update: {
            args: Prisma.ProxmoxNodeUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProxmoxNodePayload>
          }
          deleteMany: {
            args: Prisma.ProxmoxNodeDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ProxmoxNodeUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ProxmoxNodeUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProxmoxNodePayload>[]
          }
          upsert: {
            args: Prisma.ProxmoxNodeUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProxmoxNodePayload>
          }
          aggregate: {
            args: Prisma.ProxmoxNodeAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateProxmoxNode>
          }
          groupBy: {
            args: Prisma.ProxmoxNodeGroupByArgs<ExtArgs>
            result: $Utils.Optional<ProxmoxNodeGroupByOutputType>[]
          }
          count: {
            args: Prisma.ProxmoxNodeCountArgs<ExtArgs>
            result: $Utils.Optional<ProxmoxNodeCountAggregateOutputType> | number
          }
        }
      }
      ProxmoxVM: {
        payload: Prisma.$ProxmoxVMPayload<ExtArgs>
        fields: Prisma.ProxmoxVMFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ProxmoxVMFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProxmoxVMPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ProxmoxVMFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProxmoxVMPayload>
          }
          findFirst: {
            args: Prisma.ProxmoxVMFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProxmoxVMPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ProxmoxVMFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProxmoxVMPayload>
          }
          findMany: {
            args: Prisma.ProxmoxVMFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProxmoxVMPayload>[]
          }
          create: {
            args: Prisma.ProxmoxVMCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProxmoxVMPayload>
          }
          createMany: {
            args: Prisma.ProxmoxVMCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ProxmoxVMCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProxmoxVMPayload>[]
          }
          delete: {
            args: Prisma.ProxmoxVMDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProxmoxVMPayload>
          }
          update: {
            args: Prisma.ProxmoxVMUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProxmoxVMPayload>
          }
          deleteMany: {
            args: Prisma.ProxmoxVMDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ProxmoxVMUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ProxmoxVMUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProxmoxVMPayload>[]
          }
          upsert: {
            args: Prisma.ProxmoxVMUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProxmoxVMPayload>
          }
          aggregate: {
            args: Prisma.ProxmoxVMAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateProxmoxVM>
          }
          groupBy: {
            args: Prisma.ProxmoxVMGroupByArgs<ExtArgs>
            result: $Utils.Optional<ProxmoxVMGroupByOutputType>[]
          }
          count: {
            args: Prisma.ProxmoxVMCountArgs<ExtArgs>
            result: $Utils.Optional<ProxmoxVMCountAggregateOutputType> | number
          }
        }
      }
      ProxmoxMetric: {
        payload: Prisma.$ProxmoxMetricPayload<ExtArgs>
        fields: Prisma.ProxmoxMetricFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ProxmoxMetricFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProxmoxMetricPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ProxmoxMetricFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProxmoxMetricPayload>
          }
          findFirst: {
            args: Prisma.ProxmoxMetricFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProxmoxMetricPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ProxmoxMetricFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProxmoxMetricPayload>
          }
          findMany: {
            args: Prisma.ProxmoxMetricFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProxmoxMetricPayload>[]
          }
          create: {
            args: Prisma.ProxmoxMetricCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProxmoxMetricPayload>
          }
          createMany: {
            args: Prisma.ProxmoxMetricCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ProxmoxMetricCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProxmoxMetricPayload>[]
          }
          delete: {
            args: Prisma.ProxmoxMetricDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProxmoxMetricPayload>
          }
          update: {
            args: Prisma.ProxmoxMetricUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProxmoxMetricPayload>
          }
          deleteMany: {
            args: Prisma.ProxmoxMetricDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ProxmoxMetricUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ProxmoxMetricUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProxmoxMetricPayload>[]
          }
          upsert: {
            args: Prisma.ProxmoxMetricUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProxmoxMetricPayload>
          }
          aggregate: {
            args: Prisma.ProxmoxMetricAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateProxmoxMetric>
          }
          groupBy: {
            args: Prisma.ProxmoxMetricGroupByArgs<ExtArgs>
            result: $Utils.Optional<ProxmoxMetricGroupByOutputType>[]
          }
          count: {
            args: Prisma.ProxmoxMetricCountArgs<ExtArgs>
            result: $Utils.Optional<ProxmoxMetricCountAggregateOutputType> | number
          }
        }
      }
      Site: {
        payload: Prisma.$SitePayload<ExtArgs>
        fields: Prisma.SiteFieldRefs
        operations: {
          findUnique: {
            args: Prisma.SiteFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SitePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.SiteFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SitePayload>
          }
          findFirst: {
            args: Prisma.SiteFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SitePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.SiteFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SitePayload>
          }
          findMany: {
            args: Prisma.SiteFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SitePayload>[]
          }
          create: {
            args: Prisma.SiteCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SitePayload>
          }
          createMany: {
            args: Prisma.SiteCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.SiteCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SitePayload>[]
          }
          delete: {
            args: Prisma.SiteDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SitePayload>
          }
          update: {
            args: Prisma.SiteUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SitePayload>
          }
          deleteMany: {
            args: Prisma.SiteDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.SiteUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.SiteUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SitePayload>[]
          }
          upsert: {
            args: Prisma.SiteUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SitePayload>
          }
          aggregate: {
            args: Prisma.SiteAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateSite>
          }
          groupBy: {
            args: Prisma.SiteGroupByArgs<ExtArgs>
            result: $Utils.Optional<SiteGroupByOutputType>[]
          }
          count: {
            args: Prisma.SiteCountArgs<ExtArgs>
            result: $Utils.Optional<SiteCountAggregateOutputType> | number
          }
        }
      }
      Vlan: {
        payload: Prisma.$VlanPayload<ExtArgs>
        fields: Prisma.VlanFieldRefs
        operations: {
          findUnique: {
            args: Prisma.VlanFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VlanPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.VlanFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VlanPayload>
          }
          findFirst: {
            args: Prisma.VlanFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VlanPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.VlanFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VlanPayload>
          }
          findMany: {
            args: Prisma.VlanFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VlanPayload>[]
          }
          create: {
            args: Prisma.VlanCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VlanPayload>
          }
          createMany: {
            args: Prisma.VlanCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.VlanCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VlanPayload>[]
          }
          delete: {
            args: Prisma.VlanDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VlanPayload>
          }
          update: {
            args: Prisma.VlanUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VlanPayload>
          }
          deleteMany: {
            args: Prisma.VlanDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.VlanUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.VlanUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VlanPayload>[]
          }
          upsert: {
            args: Prisma.VlanUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VlanPayload>
          }
          aggregate: {
            args: Prisma.VlanAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateVlan>
          }
          groupBy: {
            args: Prisma.VlanGroupByArgs<ExtArgs>
            result: $Utils.Optional<VlanGroupByOutputType>[]
          }
          count: {
            args: Prisma.VlanCountArgs<ExtArgs>
            result: $Utils.Optional<VlanCountAggregateOutputType> | number
          }
        }
      }
      NetworkSubnet: {
        payload: Prisma.$NetworkSubnetPayload<ExtArgs>
        fields: Prisma.NetworkSubnetFieldRefs
        operations: {
          findUnique: {
            args: Prisma.NetworkSubnetFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NetworkSubnetPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.NetworkSubnetFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NetworkSubnetPayload>
          }
          findFirst: {
            args: Prisma.NetworkSubnetFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NetworkSubnetPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.NetworkSubnetFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NetworkSubnetPayload>
          }
          findMany: {
            args: Prisma.NetworkSubnetFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NetworkSubnetPayload>[]
          }
          create: {
            args: Prisma.NetworkSubnetCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NetworkSubnetPayload>
          }
          createMany: {
            args: Prisma.NetworkSubnetCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.NetworkSubnetCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NetworkSubnetPayload>[]
          }
          delete: {
            args: Prisma.NetworkSubnetDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NetworkSubnetPayload>
          }
          update: {
            args: Prisma.NetworkSubnetUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NetworkSubnetPayload>
          }
          deleteMany: {
            args: Prisma.NetworkSubnetDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.NetworkSubnetUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.NetworkSubnetUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NetworkSubnetPayload>[]
          }
          upsert: {
            args: Prisma.NetworkSubnetUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NetworkSubnetPayload>
          }
          aggregate: {
            args: Prisma.NetworkSubnetAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateNetworkSubnet>
          }
          groupBy: {
            args: Prisma.NetworkSubnetGroupByArgs<ExtArgs>
            result: $Utils.Optional<NetworkSubnetGroupByOutputType>[]
          }
          count: {
            args: Prisma.NetworkSubnetCountArgs<ExtArgs>
            result: $Utils.Optional<NetworkSubnetCountAggregateOutputType> | number
          }
        }
      }
      NetworkIP: {
        payload: Prisma.$NetworkIPPayload<ExtArgs>
        fields: Prisma.NetworkIPFieldRefs
        operations: {
          findUnique: {
            args: Prisma.NetworkIPFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NetworkIPPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.NetworkIPFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NetworkIPPayload>
          }
          findFirst: {
            args: Prisma.NetworkIPFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NetworkIPPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.NetworkIPFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NetworkIPPayload>
          }
          findMany: {
            args: Prisma.NetworkIPFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NetworkIPPayload>[]
          }
          create: {
            args: Prisma.NetworkIPCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NetworkIPPayload>
          }
          createMany: {
            args: Prisma.NetworkIPCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.NetworkIPCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NetworkIPPayload>[]
          }
          delete: {
            args: Prisma.NetworkIPDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NetworkIPPayload>
          }
          update: {
            args: Prisma.NetworkIPUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NetworkIPPayload>
          }
          deleteMany: {
            args: Prisma.NetworkIPDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.NetworkIPUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.NetworkIPUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NetworkIPPayload>[]
          }
          upsert: {
            args: Prisma.NetworkIPUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NetworkIPPayload>
          }
          aggregate: {
            args: Prisma.NetworkIPAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateNetworkIP>
          }
          groupBy: {
            args: Prisma.NetworkIPGroupByArgs<ExtArgs>
            result: $Utils.Optional<NetworkIPGroupByOutputType>[]
          }
          count: {
            args: Prisma.NetworkIPCountArgs<ExtArgs>
            result: $Utils.Optional<NetworkIPCountAggregateOutputType> | number
          }
        }
      }
      NetworkDevice: {
        payload: Prisma.$NetworkDevicePayload<ExtArgs>
        fields: Prisma.NetworkDeviceFieldRefs
        operations: {
          findUnique: {
            args: Prisma.NetworkDeviceFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NetworkDevicePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.NetworkDeviceFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NetworkDevicePayload>
          }
          findFirst: {
            args: Prisma.NetworkDeviceFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NetworkDevicePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.NetworkDeviceFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NetworkDevicePayload>
          }
          findMany: {
            args: Prisma.NetworkDeviceFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NetworkDevicePayload>[]
          }
          create: {
            args: Prisma.NetworkDeviceCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NetworkDevicePayload>
          }
          createMany: {
            args: Prisma.NetworkDeviceCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.NetworkDeviceCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NetworkDevicePayload>[]
          }
          delete: {
            args: Prisma.NetworkDeviceDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NetworkDevicePayload>
          }
          update: {
            args: Prisma.NetworkDeviceUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NetworkDevicePayload>
          }
          deleteMany: {
            args: Prisma.NetworkDeviceDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.NetworkDeviceUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.NetworkDeviceUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NetworkDevicePayload>[]
          }
          upsert: {
            args: Prisma.NetworkDeviceUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NetworkDevicePayload>
          }
          aggregate: {
            args: Prisma.NetworkDeviceAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateNetworkDevice>
          }
          groupBy: {
            args: Prisma.NetworkDeviceGroupByArgs<ExtArgs>
            result: $Utils.Optional<NetworkDeviceGroupByOutputType>[]
          }
          count: {
            args: Prisma.NetworkDeviceCountArgs<ExtArgs>
            result: $Utils.Optional<NetworkDeviceCountAggregateOutputType> | number
          }
        }
      }
      NetworkService: {
        payload: Prisma.$NetworkServicePayload<ExtArgs>
        fields: Prisma.NetworkServiceFieldRefs
        operations: {
          findUnique: {
            args: Prisma.NetworkServiceFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NetworkServicePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.NetworkServiceFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NetworkServicePayload>
          }
          findFirst: {
            args: Prisma.NetworkServiceFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NetworkServicePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.NetworkServiceFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NetworkServicePayload>
          }
          findMany: {
            args: Prisma.NetworkServiceFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NetworkServicePayload>[]
          }
          create: {
            args: Prisma.NetworkServiceCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NetworkServicePayload>
          }
          createMany: {
            args: Prisma.NetworkServiceCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.NetworkServiceCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NetworkServicePayload>[]
          }
          delete: {
            args: Prisma.NetworkServiceDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NetworkServicePayload>
          }
          update: {
            args: Prisma.NetworkServiceUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NetworkServicePayload>
          }
          deleteMany: {
            args: Prisma.NetworkServiceDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.NetworkServiceUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.NetworkServiceUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NetworkServicePayload>[]
          }
          upsert: {
            args: Prisma.NetworkServiceUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NetworkServicePayload>
          }
          aggregate: {
            args: Prisma.NetworkServiceAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateNetworkService>
          }
          groupBy: {
            args: Prisma.NetworkServiceGroupByArgs<ExtArgs>
            result: $Utils.Optional<NetworkServiceGroupByOutputType>[]
          }
          count: {
            args: Prisma.NetworkServiceCountArgs<ExtArgs>
            result: $Utils.Optional<NetworkServiceCountAggregateOutputType> | number
          }
        }
      }
    }
  } & {
    other: {
      payload: any
      operations: {
        $executeRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $executeRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
        $queryRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $queryRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
      }
    }
  }
  export const defineExtension: $Extensions.ExtendsHook<"define", Prisma.TypeMapCb, $Extensions.DefaultArgs>
  export type DefaultPrismaClient = PrismaClient
  export type ErrorFormat = 'pretty' | 'colorless' | 'minimal'
  export interface PrismaClientOptions {
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasources?: Datasources
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasourceUrl?: string
    /**
     * @default "colorless"
     */
    errorFormat?: ErrorFormat
    /**
     * @example
     * ```
     * // Shorthand for `emit: 'stdout'`
     * log: ['query', 'info', 'warn', 'error']
     * 
     * // Emit as events only
     * log: [
     *   { emit: 'event', level: 'query' },
     *   { emit: 'event', level: 'info' },
     *   { emit: 'event', level: 'warn' }
     *   { emit: 'event', level: 'error' }
     * ]
     * 
     * / Emit as events and log to stdout
     * og: [
     *  { emit: 'stdout', level: 'query' },
     *  { emit: 'stdout', level: 'info' },
     *  { emit: 'stdout', level: 'warn' }
     *  { emit: 'stdout', level: 'error' }
     * 
     * ```
     * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/logging#the-log-option).
     */
    log?: (LogLevel | LogDefinition)[]
    /**
     * The default values for transactionOptions
     * maxWait ?= 2000
     * timeout ?= 5000
     */
    transactionOptions?: {
      maxWait?: number
      timeout?: number
      isolationLevel?: Prisma.TransactionIsolationLevel
    }
    /**
     * Instance of a Driver Adapter, e.g., like one provided by `@prisma/adapter-planetscale`
     */
    adapter?: runtime.SqlDriverAdapterFactory | null
    /**
     * Global configuration for omitting model fields by default.
     * 
     * @example
     * ```
     * const prisma = new PrismaClient({
     *   omit: {
     *     user: {
     *       password: true
     *     }
     *   }
     * })
     * ```
     */
    omit?: Prisma.GlobalOmitConfig
  }
  export type GlobalOmitConfig = {
    user?: UserOmit
    subscription?: SubscriptionOmit
    invoice?: InvoiceOmit
    mikrotikDevice?: MikrotikDeviceOmit
    domain?: DomainOmit
    proxmoxServer?: ProxmoxServerOmit
    proxmoxNode?: ProxmoxNodeOmit
    proxmoxVM?: ProxmoxVMOmit
    proxmoxMetric?: ProxmoxMetricOmit
    site?: SiteOmit
    vlan?: VlanOmit
    networkSubnet?: NetworkSubnetOmit
    networkIP?: NetworkIPOmit
    networkDevice?: NetworkDeviceOmit
    networkService?: NetworkServiceOmit
  }

  /* Types for Logging */
  export type LogLevel = 'info' | 'query' | 'warn' | 'error'
  export type LogDefinition = {
    level: LogLevel
    emit: 'stdout' | 'event'
  }

  export type CheckIsLogLevel<T> = T extends LogLevel ? T : never;

  export type GetLogType<T> = CheckIsLogLevel<
    T extends LogDefinition ? T['level'] : T
  >;

  export type GetEvents<T extends any[]> = T extends Array<LogLevel | LogDefinition>
    ? GetLogType<T[number]>
    : never;

  export type QueryEvent = {
    timestamp: Date
    query: string
    params: string
    duration: number
    target: string
  }

  export type LogEvent = {
    timestamp: Date
    message: string
    target: string
  }
  /* End Types for Logging */


  export type PrismaAction =
    | 'findUnique'
    | 'findUniqueOrThrow'
    | 'findMany'
    | 'findFirst'
    | 'findFirstOrThrow'
    | 'create'
    | 'createMany'
    | 'createManyAndReturn'
    | 'update'
    | 'updateMany'
    | 'updateManyAndReturn'
    | 'upsert'
    | 'delete'
    | 'deleteMany'
    | 'executeRaw'
    | 'queryRaw'
    | 'aggregate'
    | 'count'
    | 'runCommandRaw'
    | 'findRaw'
    | 'groupBy'

  // tested in getLogLevel.test.ts
  export function getLogLevel(log: Array<LogLevel | LogDefinition>): LogLevel | undefined;

  /**
   * `PrismaClient` proxy available in interactive transactions.
   */
  export type TransactionClient = Omit<Prisma.DefaultPrismaClient, runtime.ITXClientDenyList>

  export type Datasource = {
    url?: string
  }

  /**
   * Count Types
   */


  /**
   * Count Type UserCountOutputType
   */

  export type UserCountOutputType = {
    subscriptions: number
  }

  export type UserCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    subscriptions?: boolean | UserCountOutputTypeCountSubscriptionsArgs
  }

  // Custom InputTypes
  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserCountOutputType
     */
    select?: UserCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountSubscriptionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SubscriptionWhereInput
  }


  /**
   * Count Type SubscriptionCountOutputType
   */

  export type SubscriptionCountOutputType = {
    invoices: number
  }

  export type SubscriptionCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    invoices?: boolean | SubscriptionCountOutputTypeCountInvoicesArgs
  }

  // Custom InputTypes
  /**
   * SubscriptionCountOutputType without action
   */
  export type SubscriptionCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SubscriptionCountOutputType
     */
    select?: SubscriptionCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * SubscriptionCountOutputType without action
   */
  export type SubscriptionCountOutputTypeCountInvoicesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: InvoiceWhereInput
  }


  /**
   * Count Type ProxmoxServerCountOutputType
   */

  export type ProxmoxServerCountOutputType = {
    nodes: number
    vms: number
  }

  export type ProxmoxServerCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    nodes?: boolean | ProxmoxServerCountOutputTypeCountNodesArgs
    vms?: boolean | ProxmoxServerCountOutputTypeCountVmsArgs
  }

  // Custom InputTypes
  /**
   * ProxmoxServerCountOutputType without action
   */
  export type ProxmoxServerCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProxmoxServerCountOutputType
     */
    select?: ProxmoxServerCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * ProxmoxServerCountOutputType without action
   */
  export type ProxmoxServerCountOutputTypeCountNodesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ProxmoxNodeWhereInput
  }

  /**
   * ProxmoxServerCountOutputType without action
   */
  export type ProxmoxServerCountOutputTypeCountVmsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ProxmoxVMWhereInput
  }


  /**
   * Count Type ProxmoxNodeCountOutputType
   */

  export type ProxmoxNodeCountOutputType = {
    vms: number
  }

  export type ProxmoxNodeCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    vms?: boolean | ProxmoxNodeCountOutputTypeCountVmsArgs
  }

  // Custom InputTypes
  /**
   * ProxmoxNodeCountOutputType without action
   */
  export type ProxmoxNodeCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProxmoxNodeCountOutputType
     */
    select?: ProxmoxNodeCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * ProxmoxNodeCountOutputType without action
   */
  export type ProxmoxNodeCountOutputTypeCountVmsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ProxmoxVMWhereInput
  }


  /**
   * Count Type ProxmoxVMCountOutputType
   */

  export type ProxmoxVMCountOutputType = {
    metrics: number
  }

  export type ProxmoxVMCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    metrics?: boolean | ProxmoxVMCountOutputTypeCountMetricsArgs
  }

  // Custom InputTypes
  /**
   * ProxmoxVMCountOutputType without action
   */
  export type ProxmoxVMCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProxmoxVMCountOutputType
     */
    select?: ProxmoxVMCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * ProxmoxVMCountOutputType without action
   */
  export type ProxmoxVMCountOutputTypeCountMetricsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ProxmoxMetricWhereInput
  }


  /**
   * Count Type SiteCountOutputType
   */

  export type SiteCountOutputType = {
    subnets: number
    devices: number
    vlans: number
  }

  export type SiteCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    subnets?: boolean | SiteCountOutputTypeCountSubnetsArgs
    devices?: boolean | SiteCountOutputTypeCountDevicesArgs
    vlans?: boolean | SiteCountOutputTypeCountVlansArgs
  }

  // Custom InputTypes
  /**
   * SiteCountOutputType without action
   */
  export type SiteCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SiteCountOutputType
     */
    select?: SiteCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * SiteCountOutputType without action
   */
  export type SiteCountOutputTypeCountSubnetsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: NetworkSubnetWhereInput
  }

  /**
   * SiteCountOutputType without action
   */
  export type SiteCountOutputTypeCountDevicesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: NetworkDeviceWhereInput
  }

  /**
   * SiteCountOutputType without action
   */
  export type SiteCountOutputTypeCountVlansArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: VlanWhereInput
  }


  /**
   * Count Type VlanCountOutputType
   */

  export type VlanCountOutputType = {
    subnets: number
  }

  export type VlanCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    subnets?: boolean | VlanCountOutputTypeCountSubnetsArgs
  }

  // Custom InputTypes
  /**
   * VlanCountOutputType without action
   */
  export type VlanCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VlanCountOutputType
     */
    select?: VlanCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * VlanCountOutputType without action
   */
  export type VlanCountOutputTypeCountSubnetsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: NetworkSubnetWhereInput
  }


  /**
   * Count Type NetworkSubnetCountOutputType
   */

  export type NetworkSubnetCountOutputType = {
    children: number
    ips: number
  }

  export type NetworkSubnetCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    children?: boolean | NetworkSubnetCountOutputTypeCountChildrenArgs
    ips?: boolean | NetworkSubnetCountOutputTypeCountIpsArgs
  }

  // Custom InputTypes
  /**
   * NetworkSubnetCountOutputType without action
   */
  export type NetworkSubnetCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NetworkSubnetCountOutputType
     */
    select?: NetworkSubnetCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * NetworkSubnetCountOutputType without action
   */
  export type NetworkSubnetCountOutputTypeCountChildrenArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: NetworkSubnetWhereInput
  }

  /**
   * NetworkSubnetCountOutputType without action
   */
  export type NetworkSubnetCountOutputTypeCountIpsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: NetworkIPWhereInput
  }


  /**
   * Count Type NetworkDeviceCountOutputType
   */

  export type NetworkDeviceCountOutputType = {
    services: number
    ips: number
  }

  export type NetworkDeviceCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    services?: boolean | NetworkDeviceCountOutputTypeCountServicesArgs
    ips?: boolean | NetworkDeviceCountOutputTypeCountIpsArgs
  }

  // Custom InputTypes
  /**
   * NetworkDeviceCountOutputType without action
   */
  export type NetworkDeviceCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NetworkDeviceCountOutputType
     */
    select?: NetworkDeviceCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * NetworkDeviceCountOutputType without action
   */
  export type NetworkDeviceCountOutputTypeCountServicesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: NetworkServiceWhereInput
  }

  /**
   * NetworkDeviceCountOutputType without action
   */
  export type NetworkDeviceCountOutputTypeCountIpsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: NetworkIPWhereInput
  }


  /**
   * Models
   */

  /**
   * Model User
   */

  export type AggregateUser = {
    _count: UserCountAggregateOutputType | null
    _min: UserMinAggregateOutputType | null
    _max: UserMaxAggregateOutputType | null
  }

  export type UserMinAggregateOutputType = {
    id: string | null
    name: string | null
    email: string | null
    password: string | null
    role: string | null
    phone: string | null
    address: string | null
    city: string | null
    state: string | null
    zipCode: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type UserMaxAggregateOutputType = {
    id: string | null
    name: string | null
    email: string | null
    password: string | null
    role: string | null
    phone: string | null
    address: string | null
    city: string | null
    state: string | null
    zipCode: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type UserCountAggregateOutputType = {
    id: number
    name: number
    email: number
    password: number
    role: number
    phone: number
    address: number
    city: number
    state: number
    zipCode: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type UserMinAggregateInputType = {
    id?: true
    name?: true
    email?: true
    password?: true
    role?: true
    phone?: true
    address?: true
    city?: true
    state?: true
    zipCode?: true
    createdAt?: true
    updatedAt?: true
  }

  export type UserMaxAggregateInputType = {
    id?: true
    name?: true
    email?: true
    password?: true
    role?: true
    phone?: true
    address?: true
    city?: true
    state?: true
    zipCode?: true
    createdAt?: true
    updatedAt?: true
  }

  export type UserCountAggregateInputType = {
    id?: true
    name?: true
    email?: true
    password?: true
    role?: true
    phone?: true
    address?: true
    city?: true
    state?: true
    zipCode?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type UserAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which User to aggregate.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Users
    **/
    _count?: true | UserCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UserMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UserMaxAggregateInputType
  }

  export type GetUserAggregateType<T extends UserAggregateArgs> = {
        [P in keyof T & keyof AggregateUser]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUser[P]>
      : GetScalarType<T[P], AggregateUser[P]>
  }




  export type UserGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserWhereInput
    orderBy?: UserOrderByWithAggregationInput | UserOrderByWithAggregationInput[]
    by: UserScalarFieldEnum[] | UserScalarFieldEnum
    having?: UserScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UserCountAggregateInputType | true
    _min?: UserMinAggregateInputType
    _max?: UserMaxAggregateInputType
  }

  export type UserGroupByOutputType = {
    id: string
    name: string
    email: string
    password: string
    role: string
    phone: string | null
    address: string | null
    city: string | null
    state: string | null
    zipCode: string | null
    createdAt: Date
    updatedAt: Date
    _count: UserCountAggregateOutputType | null
    _min: UserMinAggregateOutputType | null
    _max: UserMaxAggregateOutputType | null
  }

  type GetUserGroupByPayload<T extends UserGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<UserGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UserGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UserGroupByOutputType[P]>
            : GetScalarType<T[P], UserGroupByOutputType[P]>
        }
      >
    >


  export type UserSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    email?: boolean
    password?: boolean
    role?: boolean
    phone?: boolean
    address?: boolean
    city?: boolean
    state?: boolean
    zipCode?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    subscriptions?: boolean | User$subscriptionsArgs<ExtArgs>
    _count?: boolean | UserCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["user"]>

  export type UserSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    email?: boolean
    password?: boolean
    role?: boolean
    phone?: boolean
    address?: boolean
    city?: boolean
    state?: boolean
    zipCode?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["user"]>

  export type UserSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    email?: boolean
    password?: boolean
    role?: boolean
    phone?: boolean
    address?: boolean
    city?: boolean
    state?: boolean
    zipCode?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["user"]>

  export type UserSelectScalar = {
    id?: boolean
    name?: boolean
    email?: boolean
    password?: boolean
    role?: boolean
    phone?: boolean
    address?: boolean
    city?: boolean
    state?: boolean
    zipCode?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type UserOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "email" | "password" | "role" | "phone" | "address" | "city" | "state" | "zipCode" | "createdAt" | "updatedAt", ExtArgs["result"]["user"]>
  export type UserInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    subscriptions?: boolean | User$subscriptionsArgs<ExtArgs>
    _count?: boolean | UserCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type UserIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type UserIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $UserPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "User"
    objects: {
      subscriptions: Prisma.$SubscriptionPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      email: string
      password: string
      role: string
      phone: string | null
      address: string | null
      city: string | null
      state: string | null
      zipCode: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["user"]>
    composites: {}
  }

  type UserGetPayload<S extends boolean | null | undefined | UserDefaultArgs> = $Result.GetResult<Prisma.$UserPayload, S>

  type UserCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<UserFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: UserCountAggregateInputType | true
    }

  export interface UserDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['User'], meta: { name: 'User' } }
    /**
     * Find zero or one User that matches the filter.
     * @param {UserFindUniqueArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends UserFindUniqueArgs>(args: SelectSubset<T, UserFindUniqueArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one User that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {UserFindUniqueOrThrowArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends UserFindUniqueOrThrowArgs>(args: SelectSubset<T, UserFindUniqueOrThrowArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first User that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindFirstArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends UserFindFirstArgs>(args?: SelectSubset<T, UserFindFirstArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first User that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindFirstOrThrowArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends UserFindFirstOrThrowArgs>(args?: SelectSubset<T, UserFindFirstOrThrowArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Users that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Users
     * const users = await prisma.user.findMany()
     * 
     * // Get first 10 Users
     * const users = await prisma.user.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const userWithIdOnly = await prisma.user.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends UserFindManyArgs>(args?: SelectSubset<T, UserFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a User.
     * @param {UserCreateArgs} args - Arguments to create a User.
     * @example
     * // Create one User
     * const User = await prisma.user.create({
     *   data: {
     *     // ... data to create a User
     *   }
     * })
     * 
     */
    create<T extends UserCreateArgs>(args: SelectSubset<T, UserCreateArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Users.
     * @param {UserCreateManyArgs} args - Arguments to create many Users.
     * @example
     * // Create many Users
     * const user = await prisma.user.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends UserCreateManyArgs>(args?: SelectSubset<T, UserCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Users and returns the data saved in the database.
     * @param {UserCreateManyAndReturnArgs} args - Arguments to create many Users.
     * @example
     * // Create many Users
     * const user = await prisma.user.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Users and only return the `id`
     * const userWithIdOnly = await prisma.user.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends UserCreateManyAndReturnArgs>(args?: SelectSubset<T, UserCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a User.
     * @param {UserDeleteArgs} args - Arguments to delete one User.
     * @example
     * // Delete one User
     * const User = await prisma.user.delete({
     *   where: {
     *     // ... filter to delete one User
     *   }
     * })
     * 
     */
    delete<T extends UserDeleteArgs>(args: SelectSubset<T, UserDeleteArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one User.
     * @param {UserUpdateArgs} args - Arguments to update one User.
     * @example
     * // Update one User
     * const user = await prisma.user.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends UserUpdateArgs>(args: SelectSubset<T, UserUpdateArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Users.
     * @param {UserDeleteManyArgs} args - Arguments to filter Users to delete.
     * @example
     * // Delete a few Users
     * const { count } = await prisma.user.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends UserDeleteManyArgs>(args?: SelectSubset<T, UserDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Users
     * const user = await prisma.user.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends UserUpdateManyArgs>(args: SelectSubset<T, UserUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Users and returns the data updated in the database.
     * @param {UserUpdateManyAndReturnArgs} args - Arguments to update many Users.
     * @example
     * // Update many Users
     * const user = await prisma.user.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Users and only return the `id`
     * const userWithIdOnly = await prisma.user.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends UserUpdateManyAndReturnArgs>(args: SelectSubset<T, UserUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one User.
     * @param {UserUpsertArgs} args - Arguments to update or create a User.
     * @example
     * // Update or create a User
     * const user = await prisma.user.upsert({
     *   create: {
     *     // ... data to create a User
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the User we want to update
     *   }
     * })
     */
    upsert<T extends UserUpsertArgs>(args: SelectSubset<T, UserUpsertArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserCountArgs} args - Arguments to filter Users to count.
     * @example
     * // Count the number of Users
     * const count = await prisma.user.count({
     *   where: {
     *     // ... the filter for the Users we want to count
     *   }
     * })
    **/
    count<T extends UserCountArgs>(
      args?: Subset<T, UserCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UserCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a User.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UserAggregateArgs>(args: Subset<T, UserAggregateArgs>): Prisma.PrismaPromise<GetUserAggregateType<T>>

    /**
     * Group by User.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends UserGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: UserGroupByArgs['orderBy'] }
        : { orderBy?: UserGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, UserGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUserGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the User model
   */
  readonly fields: UserFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for User.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__UserClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    subscriptions<T extends User$subscriptionsArgs<ExtArgs> = {}>(args?: Subset<T, User$subscriptionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SubscriptionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the User model
   */
  interface UserFieldRefs {
    readonly id: FieldRef<"User", 'String'>
    readonly name: FieldRef<"User", 'String'>
    readonly email: FieldRef<"User", 'String'>
    readonly password: FieldRef<"User", 'String'>
    readonly role: FieldRef<"User", 'String'>
    readonly phone: FieldRef<"User", 'String'>
    readonly address: FieldRef<"User", 'String'>
    readonly city: FieldRef<"User", 'String'>
    readonly state: FieldRef<"User", 'String'>
    readonly zipCode: FieldRef<"User", 'String'>
    readonly createdAt: FieldRef<"User", 'DateTime'>
    readonly updatedAt: FieldRef<"User", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * User findUnique
   */
  export type UserFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User findUniqueOrThrow
   */
  export type UserFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User findFirst
   */
  export type UserFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Users.
     */
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User findFirstOrThrow
   */
  export type UserFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Users.
     */
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User findMany
   */
  export type UserFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which Users to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User create
   */
  export type UserCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The data needed to create a User.
     */
    data: XOR<UserCreateInput, UserUncheckedCreateInput>
  }

  /**
   * User createMany
   */
  export type UserCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Users.
     */
    data: UserCreateManyInput | UserCreateManyInput[]
  }

  /**
   * User createManyAndReturn
   */
  export type UserCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * The data used to create many Users.
     */
    data: UserCreateManyInput | UserCreateManyInput[]
  }

  /**
   * User update
   */
  export type UserUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The data needed to update a User.
     */
    data: XOR<UserUpdateInput, UserUncheckedUpdateInput>
    /**
     * Choose, which User to update.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User updateMany
   */
  export type UserUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Users.
     */
    data: XOR<UserUpdateManyMutationInput, UserUncheckedUpdateManyInput>
    /**
     * Filter which Users to update
     */
    where?: UserWhereInput
    /**
     * Limit how many Users to update.
     */
    limit?: number
  }

  /**
   * User updateManyAndReturn
   */
  export type UserUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * The data used to update Users.
     */
    data: XOR<UserUpdateManyMutationInput, UserUncheckedUpdateManyInput>
    /**
     * Filter which Users to update
     */
    where?: UserWhereInput
    /**
     * Limit how many Users to update.
     */
    limit?: number
  }

  /**
   * User upsert
   */
  export type UserUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The filter to search for the User to update in case it exists.
     */
    where: UserWhereUniqueInput
    /**
     * In case the User found by the `where` argument doesn't exist, create a new User with this data.
     */
    create: XOR<UserCreateInput, UserUncheckedCreateInput>
    /**
     * In case the User was found with the provided `where` argument, update it with this data.
     */
    update: XOR<UserUpdateInput, UserUncheckedUpdateInput>
  }

  /**
   * User delete
   */
  export type UserDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter which User to delete.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User deleteMany
   */
  export type UserDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Users to delete
     */
    where?: UserWhereInput
    /**
     * Limit how many Users to delete.
     */
    limit?: number
  }

  /**
   * User.subscriptions
   */
  export type User$subscriptionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Subscription
     */
    select?: SubscriptionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Subscription
     */
    omit?: SubscriptionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubscriptionInclude<ExtArgs> | null
    where?: SubscriptionWhereInput
    orderBy?: SubscriptionOrderByWithRelationInput | SubscriptionOrderByWithRelationInput[]
    cursor?: SubscriptionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: SubscriptionScalarFieldEnum | SubscriptionScalarFieldEnum[]
  }

  /**
   * User without action
   */
  export type UserDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
  }


  /**
   * Model Subscription
   */

  export type AggregateSubscription = {
    _count: SubscriptionCountAggregateOutputType | null
    _avg: SubscriptionAvgAggregateOutputType | null
    _sum: SubscriptionSumAggregateOutputType | null
    _min: SubscriptionMinAggregateOutputType | null
    _max: SubscriptionMaxAggregateOutputType | null
  }

  export type SubscriptionAvgAggregateOutputType = {
    price: number | null
  }

  export type SubscriptionSumAggregateOutputType = {
    price: number | null
  }

  export type SubscriptionMinAggregateOutputType = {
    id: string | null
    userId: string | null
    planName: string | null
    price: number | null
    status: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type SubscriptionMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    planName: string | null
    price: number | null
    status: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type SubscriptionCountAggregateOutputType = {
    id: number
    userId: number
    planName: number
    price: number
    status: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type SubscriptionAvgAggregateInputType = {
    price?: true
  }

  export type SubscriptionSumAggregateInputType = {
    price?: true
  }

  export type SubscriptionMinAggregateInputType = {
    id?: true
    userId?: true
    planName?: true
    price?: true
    status?: true
    createdAt?: true
    updatedAt?: true
  }

  export type SubscriptionMaxAggregateInputType = {
    id?: true
    userId?: true
    planName?: true
    price?: true
    status?: true
    createdAt?: true
    updatedAt?: true
  }

  export type SubscriptionCountAggregateInputType = {
    id?: true
    userId?: true
    planName?: true
    price?: true
    status?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type SubscriptionAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Subscription to aggregate.
     */
    where?: SubscriptionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Subscriptions to fetch.
     */
    orderBy?: SubscriptionOrderByWithRelationInput | SubscriptionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: SubscriptionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Subscriptions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Subscriptions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Subscriptions
    **/
    _count?: true | SubscriptionCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: SubscriptionAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: SubscriptionSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SubscriptionMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SubscriptionMaxAggregateInputType
  }

  export type GetSubscriptionAggregateType<T extends SubscriptionAggregateArgs> = {
        [P in keyof T & keyof AggregateSubscription]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSubscription[P]>
      : GetScalarType<T[P], AggregateSubscription[P]>
  }




  export type SubscriptionGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SubscriptionWhereInput
    orderBy?: SubscriptionOrderByWithAggregationInput | SubscriptionOrderByWithAggregationInput[]
    by: SubscriptionScalarFieldEnum[] | SubscriptionScalarFieldEnum
    having?: SubscriptionScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SubscriptionCountAggregateInputType | true
    _avg?: SubscriptionAvgAggregateInputType
    _sum?: SubscriptionSumAggregateInputType
    _min?: SubscriptionMinAggregateInputType
    _max?: SubscriptionMaxAggregateInputType
  }

  export type SubscriptionGroupByOutputType = {
    id: string
    userId: string
    planName: string
    price: number
    status: string
    createdAt: Date
    updatedAt: Date
    _count: SubscriptionCountAggregateOutputType | null
    _avg: SubscriptionAvgAggregateOutputType | null
    _sum: SubscriptionSumAggregateOutputType | null
    _min: SubscriptionMinAggregateOutputType | null
    _max: SubscriptionMaxAggregateOutputType | null
  }

  type GetSubscriptionGroupByPayload<T extends SubscriptionGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<SubscriptionGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SubscriptionGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SubscriptionGroupByOutputType[P]>
            : GetScalarType<T[P], SubscriptionGroupByOutputType[P]>
        }
      >
    >


  export type SubscriptionSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    planName?: boolean
    price?: boolean
    status?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    invoices?: boolean | Subscription$invoicesArgs<ExtArgs>
    _count?: boolean | SubscriptionCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["subscription"]>

  export type SubscriptionSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    planName?: boolean
    price?: boolean
    status?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["subscription"]>

  export type SubscriptionSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    planName?: boolean
    price?: boolean
    status?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["subscription"]>

  export type SubscriptionSelectScalar = {
    id?: boolean
    userId?: boolean
    planName?: boolean
    price?: boolean
    status?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type SubscriptionOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "userId" | "planName" | "price" | "status" | "createdAt" | "updatedAt", ExtArgs["result"]["subscription"]>
  export type SubscriptionInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    invoices?: boolean | Subscription$invoicesArgs<ExtArgs>
    _count?: boolean | SubscriptionCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type SubscriptionIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type SubscriptionIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $SubscriptionPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Subscription"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
      invoices: Prisma.$InvoicePayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      planName: string
      price: number
      status: string
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["subscription"]>
    composites: {}
  }

  type SubscriptionGetPayload<S extends boolean | null | undefined | SubscriptionDefaultArgs> = $Result.GetResult<Prisma.$SubscriptionPayload, S>

  type SubscriptionCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<SubscriptionFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: SubscriptionCountAggregateInputType | true
    }

  export interface SubscriptionDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Subscription'], meta: { name: 'Subscription' } }
    /**
     * Find zero or one Subscription that matches the filter.
     * @param {SubscriptionFindUniqueArgs} args - Arguments to find a Subscription
     * @example
     * // Get one Subscription
     * const subscription = await prisma.subscription.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends SubscriptionFindUniqueArgs>(args: SelectSubset<T, SubscriptionFindUniqueArgs<ExtArgs>>): Prisma__SubscriptionClient<$Result.GetResult<Prisma.$SubscriptionPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Subscription that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {SubscriptionFindUniqueOrThrowArgs} args - Arguments to find a Subscription
     * @example
     * // Get one Subscription
     * const subscription = await prisma.subscription.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends SubscriptionFindUniqueOrThrowArgs>(args: SelectSubset<T, SubscriptionFindUniqueOrThrowArgs<ExtArgs>>): Prisma__SubscriptionClient<$Result.GetResult<Prisma.$SubscriptionPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Subscription that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SubscriptionFindFirstArgs} args - Arguments to find a Subscription
     * @example
     * // Get one Subscription
     * const subscription = await prisma.subscription.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends SubscriptionFindFirstArgs>(args?: SelectSubset<T, SubscriptionFindFirstArgs<ExtArgs>>): Prisma__SubscriptionClient<$Result.GetResult<Prisma.$SubscriptionPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Subscription that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SubscriptionFindFirstOrThrowArgs} args - Arguments to find a Subscription
     * @example
     * // Get one Subscription
     * const subscription = await prisma.subscription.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends SubscriptionFindFirstOrThrowArgs>(args?: SelectSubset<T, SubscriptionFindFirstOrThrowArgs<ExtArgs>>): Prisma__SubscriptionClient<$Result.GetResult<Prisma.$SubscriptionPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Subscriptions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SubscriptionFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Subscriptions
     * const subscriptions = await prisma.subscription.findMany()
     * 
     * // Get first 10 Subscriptions
     * const subscriptions = await prisma.subscription.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const subscriptionWithIdOnly = await prisma.subscription.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends SubscriptionFindManyArgs>(args?: SelectSubset<T, SubscriptionFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SubscriptionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Subscription.
     * @param {SubscriptionCreateArgs} args - Arguments to create a Subscription.
     * @example
     * // Create one Subscription
     * const Subscription = await prisma.subscription.create({
     *   data: {
     *     // ... data to create a Subscription
     *   }
     * })
     * 
     */
    create<T extends SubscriptionCreateArgs>(args: SelectSubset<T, SubscriptionCreateArgs<ExtArgs>>): Prisma__SubscriptionClient<$Result.GetResult<Prisma.$SubscriptionPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Subscriptions.
     * @param {SubscriptionCreateManyArgs} args - Arguments to create many Subscriptions.
     * @example
     * // Create many Subscriptions
     * const subscription = await prisma.subscription.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends SubscriptionCreateManyArgs>(args?: SelectSubset<T, SubscriptionCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Subscriptions and returns the data saved in the database.
     * @param {SubscriptionCreateManyAndReturnArgs} args - Arguments to create many Subscriptions.
     * @example
     * // Create many Subscriptions
     * const subscription = await prisma.subscription.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Subscriptions and only return the `id`
     * const subscriptionWithIdOnly = await prisma.subscription.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends SubscriptionCreateManyAndReturnArgs>(args?: SelectSubset<T, SubscriptionCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SubscriptionPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Subscription.
     * @param {SubscriptionDeleteArgs} args - Arguments to delete one Subscription.
     * @example
     * // Delete one Subscription
     * const Subscription = await prisma.subscription.delete({
     *   where: {
     *     // ... filter to delete one Subscription
     *   }
     * })
     * 
     */
    delete<T extends SubscriptionDeleteArgs>(args: SelectSubset<T, SubscriptionDeleteArgs<ExtArgs>>): Prisma__SubscriptionClient<$Result.GetResult<Prisma.$SubscriptionPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Subscription.
     * @param {SubscriptionUpdateArgs} args - Arguments to update one Subscription.
     * @example
     * // Update one Subscription
     * const subscription = await prisma.subscription.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends SubscriptionUpdateArgs>(args: SelectSubset<T, SubscriptionUpdateArgs<ExtArgs>>): Prisma__SubscriptionClient<$Result.GetResult<Prisma.$SubscriptionPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Subscriptions.
     * @param {SubscriptionDeleteManyArgs} args - Arguments to filter Subscriptions to delete.
     * @example
     * // Delete a few Subscriptions
     * const { count } = await prisma.subscription.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends SubscriptionDeleteManyArgs>(args?: SelectSubset<T, SubscriptionDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Subscriptions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SubscriptionUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Subscriptions
     * const subscription = await prisma.subscription.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends SubscriptionUpdateManyArgs>(args: SelectSubset<T, SubscriptionUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Subscriptions and returns the data updated in the database.
     * @param {SubscriptionUpdateManyAndReturnArgs} args - Arguments to update many Subscriptions.
     * @example
     * // Update many Subscriptions
     * const subscription = await prisma.subscription.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Subscriptions and only return the `id`
     * const subscriptionWithIdOnly = await prisma.subscription.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends SubscriptionUpdateManyAndReturnArgs>(args: SelectSubset<T, SubscriptionUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SubscriptionPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Subscription.
     * @param {SubscriptionUpsertArgs} args - Arguments to update or create a Subscription.
     * @example
     * // Update or create a Subscription
     * const subscription = await prisma.subscription.upsert({
     *   create: {
     *     // ... data to create a Subscription
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Subscription we want to update
     *   }
     * })
     */
    upsert<T extends SubscriptionUpsertArgs>(args: SelectSubset<T, SubscriptionUpsertArgs<ExtArgs>>): Prisma__SubscriptionClient<$Result.GetResult<Prisma.$SubscriptionPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Subscriptions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SubscriptionCountArgs} args - Arguments to filter Subscriptions to count.
     * @example
     * // Count the number of Subscriptions
     * const count = await prisma.subscription.count({
     *   where: {
     *     // ... the filter for the Subscriptions we want to count
     *   }
     * })
    **/
    count<T extends SubscriptionCountArgs>(
      args?: Subset<T, SubscriptionCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SubscriptionCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Subscription.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SubscriptionAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SubscriptionAggregateArgs>(args: Subset<T, SubscriptionAggregateArgs>): Prisma.PrismaPromise<GetSubscriptionAggregateType<T>>

    /**
     * Group by Subscription.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SubscriptionGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends SubscriptionGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: SubscriptionGroupByArgs['orderBy'] }
        : { orderBy?: SubscriptionGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, SubscriptionGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSubscriptionGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Subscription model
   */
  readonly fields: SubscriptionFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Subscription.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__SubscriptionClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    invoices<T extends Subscription$invoicesArgs<ExtArgs> = {}>(args?: Subset<T, Subscription$invoicesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$InvoicePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Subscription model
   */
  interface SubscriptionFieldRefs {
    readonly id: FieldRef<"Subscription", 'String'>
    readonly userId: FieldRef<"Subscription", 'String'>
    readonly planName: FieldRef<"Subscription", 'String'>
    readonly price: FieldRef<"Subscription", 'Float'>
    readonly status: FieldRef<"Subscription", 'String'>
    readonly createdAt: FieldRef<"Subscription", 'DateTime'>
    readonly updatedAt: FieldRef<"Subscription", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Subscription findUnique
   */
  export type SubscriptionFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Subscription
     */
    select?: SubscriptionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Subscription
     */
    omit?: SubscriptionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubscriptionInclude<ExtArgs> | null
    /**
     * Filter, which Subscription to fetch.
     */
    where: SubscriptionWhereUniqueInput
  }

  /**
   * Subscription findUniqueOrThrow
   */
  export type SubscriptionFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Subscription
     */
    select?: SubscriptionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Subscription
     */
    omit?: SubscriptionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubscriptionInclude<ExtArgs> | null
    /**
     * Filter, which Subscription to fetch.
     */
    where: SubscriptionWhereUniqueInput
  }

  /**
   * Subscription findFirst
   */
  export type SubscriptionFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Subscription
     */
    select?: SubscriptionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Subscription
     */
    omit?: SubscriptionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubscriptionInclude<ExtArgs> | null
    /**
     * Filter, which Subscription to fetch.
     */
    where?: SubscriptionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Subscriptions to fetch.
     */
    orderBy?: SubscriptionOrderByWithRelationInput | SubscriptionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Subscriptions.
     */
    cursor?: SubscriptionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Subscriptions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Subscriptions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Subscriptions.
     */
    distinct?: SubscriptionScalarFieldEnum | SubscriptionScalarFieldEnum[]
  }

  /**
   * Subscription findFirstOrThrow
   */
  export type SubscriptionFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Subscription
     */
    select?: SubscriptionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Subscription
     */
    omit?: SubscriptionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubscriptionInclude<ExtArgs> | null
    /**
     * Filter, which Subscription to fetch.
     */
    where?: SubscriptionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Subscriptions to fetch.
     */
    orderBy?: SubscriptionOrderByWithRelationInput | SubscriptionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Subscriptions.
     */
    cursor?: SubscriptionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Subscriptions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Subscriptions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Subscriptions.
     */
    distinct?: SubscriptionScalarFieldEnum | SubscriptionScalarFieldEnum[]
  }

  /**
   * Subscription findMany
   */
  export type SubscriptionFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Subscription
     */
    select?: SubscriptionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Subscription
     */
    omit?: SubscriptionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubscriptionInclude<ExtArgs> | null
    /**
     * Filter, which Subscriptions to fetch.
     */
    where?: SubscriptionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Subscriptions to fetch.
     */
    orderBy?: SubscriptionOrderByWithRelationInput | SubscriptionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Subscriptions.
     */
    cursor?: SubscriptionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Subscriptions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Subscriptions.
     */
    skip?: number
    distinct?: SubscriptionScalarFieldEnum | SubscriptionScalarFieldEnum[]
  }

  /**
   * Subscription create
   */
  export type SubscriptionCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Subscription
     */
    select?: SubscriptionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Subscription
     */
    omit?: SubscriptionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubscriptionInclude<ExtArgs> | null
    /**
     * The data needed to create a Subscription.
     */
    data: XOR<SubscriptionCreateInput, SubscriptionUncheckedCreateInput>
  }

  /**
   * Subscription createMany
   */
  export type SubscriptionCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Subscriptions.
     */
    data: SubscriptionCreateManyInput | SubscriptionCreateManyInput[]
  }

  /**
   * Subscription createManyAndReturn
   */
  export type SubscriptionCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Subscription
     */
    select?: SubscriptionSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Subscription
     */
    omit?: SubscriptionOmit<ExtArgs> | null
    /**
     * The data used to create many Subscriptions.
     */
    data: SubscriptionCreateManyInput | SubscriptionCreateManyInput[]
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubscriptionIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Subscription update
   */
  export type SubscriptionUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Subscription
     */
    select?: SubscriptionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Subscription
     */
    omit?: SubscriptionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubscriptionInclude<ExtArgs> | null
    /**
     * The data needed to update a Subscription.
     */
    data: XOR<SubscriptionUpdateInput, SubscriptionUncheckedUpdateInput>
    /**
     * Choose, which Subscription to update.
     */
    where: SubscriptionWhereUniqueInput
  }

  /**
   * Subscription updateMany
   */
  export type SubscriptionUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Subscriptions.
     */
    data: XOR<SubscriptionUpdateManyMutationInput, SubscriptionUncheckedUpdateManyInput>
    /**
     * Filter which Subscriptions to update
     */
    where?: SubscriptionWhereInput
    /**
     * Limit how many Subscriptions to update.
     */
    limit?: number
  }

  /**
   * Subscription updateManyAndReturn
   */
  export type SubscriptionUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Subscription
     */
    select?: SubscriptionSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Subscription
     */
    omit?: SubscriptionOmit<ExtArgs> | null
    /**
     * The data used to update Subscriptions.
     */
    data: XOR<SubscriptionUpdateManyMutationInput, SubscriptionUncheckedUpdateManyInput>
    /**
     * Filter which Subscriptions to update
     */
    where?: SubscriptionWhereInput
    /**
     * Limit how many Subscriptions to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubscriptionIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Subscription upsert
   */
  export type SubscriptionUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Subscription
     */
    select?: SubscriptionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Subscription
     */
    omit?: SubscriptionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubscriptionInclude<ExtArgs> | null
    /**
     * The filter to search for the Subscription to update in case it exists.
     */
    where: SubscriptionWhereUniqueInput
    /**
     * In case the Subscription found by the `where` argument doesn't exist, create a new Subscription with this data.
     */
    create: XOR<SubscriptionCreateInput, SubscriptionUncheckedCreateInput>
    /**
     * In case the Subscription was found with the provided `where` argument, update it with this data.
     */
    update: XOR<SubscriptionUpdateInput, SubscriptionUncheckedUpdateInput>
  }

  /**
   * Subscription delete
   */
  export type SubscriptionDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Subscription
     */
    select?: SubscriptionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Subscription
     */
    omit?: SubscriptionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubscriptionInclude<ExtArgs> | null
    /**
     * Filter which Subscription to delete.
     */
    where: SubscriptionWhereUniqueInput
  }

  /**
   * Subscription deleteMany
   */
  export type SubscriptionDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Subscriptions to delete
     */
    where?: SubscriptionWhereInput
    /**
     * Limit how many Subscriptions to delete.
     */
    limit?: number
  }

  /**
   * Subscription.invoices
   */
  export type Subscription$invoicesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Invoice
     */
    select?: InvoiceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Invoice
     */
    omit?: InvoiceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvoiceInclude<ExtArgs> | null
    where?: InvoiceWhereInput
    orderBy?: InvoiceOrderByWithRelationInput | InvoiceOrderByWithRelationInput[]
    cursor?: InvoiceWhereUniqueInput
    take?: number
    skip?: number
    distinct?: InvoiceScalarFieldEnum | InvoiceScalarFieldEnum[]
  }

  /**
   * Subscription without action
   */
  export type SubscriptionDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Subscription
     */
    select?: SubscriptionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Subscription
     */
    omit?: SubscriptionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubscriptionInclude<ExtArgs> | null
  }


  /**
   * Model Invoice
   */

  export type AggregateInvoice = {
    _count: InvoiceCountAggregateOutputType | null
    _avg: InvoiceAvgAggregateOutputType | null
    _sum: InvoiceSumAggregateOutputType | null
    _min: InvoiceMinAggregateOutputType | null
    _max: InvoiceMaxAggregateOutputType | null
  }

  export type InvoiceAvgAggregateOutputType = {
    amount: number | null
  }

  export type InvoiceSumAggregateOutputType = {
    amount: number | null
  }

  export type InvoiceMinAggregateOutputType = {
    id: string | null
    subscriptionId: string | null
    amount: number | null
    status: string | null
    dueDate: Date | null
    paidAt: Date | null
    createdAt: Date | null
  }

  export type InvoiceMaxAggregateOutputType = {
    id: string | null
    subscriptionId: string | null
    amount: number | null
    status: string | null
    dueDate: Date | null
    paidAt: Date | null
    createdAt: Date | null
  }

  export type InvoiceCountAggregateOutputType = {
    id: number
    subscriptionId: number
    amount: number
    status: number
    dueDate: number
    paidAt: number
    createdAt: number
    _all: number
  }


  export type InvoiceAvgAggregateInputType = {
    amount?: true
  }

  export type InvoiceSumAggregateInputType = {
    amount?: true
  }

  export type InvoiceMinAggregateInputType = {
    id?: true
    subscriptionId?: true
    amount?: true
    status?: true
    dueDate?: true
    paidAt?: true
    createdAt?: true
  }

  export type InvoiceMaxAggregateInputType = {
    id?: true
    subscriptionId?: true
    amount?: true
    status?: true
    dueDate?: true
    paidAt?: true
    createdAt?: true
  }

  export type InvoiceCountAggregateInputType = {
    id?: true
    subscriptionId?: true
    amount?: true
    status?: true
    dueDate?: true
    paidAt?: true
    createdAt?: true
    _all?: true
  }

  export type InvoiceAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Invoice to aggregate.
     */
    where?: InvoiceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Invoices to fetch.
     */
    orderBy?: InvoiceOrderByWithRelationInput | InvoiceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: InvoiceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Invoices from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Invoices.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Invoices
    **/
    _count?: true | InvoiceCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: InvoiceAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: InvoiceSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: InvoiceMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: InvoiceMaxAggregateInputType
  }

  export type GetInvoiceAggregateType<T extends InvoiceAggregateArgs> = {
        [P in keyof T & keyof AggregateInvoice]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateInvoice[P]>
      : GetScalarType<T[P], AggregateInvoice[P]>
  }




  export type InvoiceGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: InvoiceWhereInput
    orderBy?: InvoiceOrderByWithAggregationInput | InvoiceOrderByWithAggregationInput[]
    by: InvoiceScalarFieldEnum[] | InvoiceScalarFieldEnum
    having?: InvoiceScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: InvoiceCountAggregateInputType | true
    _avg?: InvoiceAvgAggregateInputType
    _sum?: InvoiceSumAggregateInputType
    _min?: InvoiceMinAggregateInputType
    _max?: InvoiceMaxAggregateInputType
  }

  export type InvoiceGroupByOutputType = {
    id: string
    subscriptionId: string
    amount: number
    status: string
    dueDate: Date
    paidAt: Date | null
    createdAt: Date
    _count: InvoiceCountAggregateOutputType | null
    _avg: InvoiceAvgAggregateOutputType | null
    _sum: InvoiceSumAggregateOutputType | null
    _min: InvoiceMinAggregateOutputType | null
    _max: InvoiceMaxAggregateOutputType | null
  }

  type GetInvoiceGroupByPayload<T extends InvoiceGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<InvoiceGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof InvoiceGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], InvoiceGroupByOutputType[P]>
            : GetScalarType<T[P], InvoiceGroupByOutputType[P]>
        }
      >
    >


  export type InvoiceSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    subscriptionId?: boolean
    amount?: boolean
    status?: boolean
    dueDate?: boolean
    paidAt?: boolean
    createdAt?: boolean
    subscription?: boolean | SubscriptionDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["invoice"]>

  export type InvoiceSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    subscriptionId?: boolean
    amount?: boolean
    status?: boolean
    dueDate?: boolean
    paidAt?: boolean
    createdAt?: boolean
    subscription?: boolean | SubscriptionDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["invoice"]>

  export type InvoiceSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    subscriptionId?: boolean
    amount?: boolean
    status?: boolean
    dueDate?: boolean
    paidAt?: boolean
    createdAt?: boolean
    subscription?: boolean | SubscriptionDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["invoice"]>

  export type InvoiceSelectScalar = {
    id?: boolean
    subscriptionId?: boolean
    amount?: boolean
    status?: boolean
    dueDate?: boolean
    paidAt?: boolean
    createdAt?: boolean
  }

  export type InvoiceOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "subscriptionId" | "amount" | "status" | "dueDate" | "paidAt" | "createdAt", ExtArgs["result"]["invoice"]>
  export type InvoiceInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    subscription?: boolean | SubscriptionDefaultArgs<ExtArgs>
  }
  export type InvoiceIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    subscription?: boolean | SubscriptionDefaultArgs<ExtArgs>
  }
  export type InvoiceIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    subscription?: boolean | SubscriptionDefaultArgs<ExtArgs>
  }

  export type $InvoicePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Invoice"
    objects: {
      subscription: Prisma.$SubscriptionPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      subscriptionId: string
      amount: number
      status: string
      dueDate: Date
      paidAt: Date | null
      createdAt: Date
    }, ExtArgs["result"]["invoice"]>
    composites: {}
  }

  type InvoiceGetPayload<S extends boolean | null | undefined | InvoiceDefaultArgs> = $Result.GetResult<Prisma.$InvoicePayload, S>

  type InvoiceCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<InvoiceFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: InvoiceCountAggregateInputType | true
    }

  export interface InvoiceDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Invoice'], meta: { name: 'Invoice' } }
    /**
     * Find zero or one Invoice that matches the filter.
     * @param {InvoiceFindUniqueArgs} args - Arguments to find a Invoice
     * @example
     * // Get one Invoice
     * const invoice = await prisma.invoice.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends InvoiceFindUniqueArgs>(args: SelectSubset<T, InvoiceFindUniqueArgs<ExtArgs>>): Prisma__InvoiceClient<$Result.GetResult<Prisma.$InvoicePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Invoice that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {InvoiceFindUniqueOrThrowArgs} args - Arguments to find a Invoice
     * @example
     * // Get one Invoice
     * const invoice = await prisma.invoice.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends InvoiceFindUniqueOrThrowArgs>(args: SelectSubset<T, InvoiceFindUniqueOrThrowArgs<ExtArgs>>): Prisma__InvoiceClient<$Result.GetResult<Prisma.$InvoicePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Invoice that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InvoiceFindFirstArgs} args - Arguments to find a Invoice
     * @example
     * // Get one Invoice
     * const invoice = await prisma.invoice.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends InvoiceFindFirstArgs>(args?: SelectSubset<T, InvoiceFindFirstArgs<ExtArgs>>): Prisma__InvoiceClient<$Result.GetResult<Prisma.$InvoicePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Invoice that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InvoiceFindFirstOrThrowArgs} args - Arguments to find a Invoice
     * @example
     * // Get one Invoice
     * const invoice = await prisma.invoice.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends InvoiceFindFirstOrThrowArgs>(args?: SelectSubset<T, InvoiceFindFirstOrThrowArgs<ExtArgs>>): Prisma__InvoiceClient<$Result.GetResult<Prisma.$InvoicePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Invoices that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InvoiceFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Invoices
     * const invoices = await prisma.invoice.findMany()
     * 
     * // Get first 10 Invoices
     * const invoices = await prisma.invoice.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const invoiceWithIdOnly = await prisma.invoice.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends InvoiceFindManyArgs>(args?: SelectSubset<T, InvoiceFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$InvoicePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Invoice.
     * @param {InvoiceCreateArgs} args - Arguments to create a Invoice.
     * @example
     * // Create one Invoice
     * const Invoice = await prisma.invoice.create({
     *   data: {
     *     // ... data to create a Invoice
     *   }
     * })
     * 
     */
    create<T extends InvoiceCreateArgs>(args: SelectSubset<T, InvoiceCreateArgs<ExtArgs>>): Prisma__InvoiceClient<$Result.GetResult<Prisma.$InvoicePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Invoices.
     * @param {InvoiceCreateManyArgs} args - Arguments to create many Invoices.
     * @example
     * // Create many Invoices
     * const invoice = await prisma.invoice.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends InvoiceCreateManyArgs>(args?: SelectSubset<T, InvoiceCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Invoices and returns the data saved in the database.
     * @param {InvoiceCreateManyAndReturnArgs} args - Arguments to create many Invoices.
     * @example
     * // Create many Invoices
     * const invoice = await prisma.invoice.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Invoices and only return the `id`
     * const invoiceWithIdOnly = await prisma.invoice.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends InvoiceCreateManyAndReturnArgs>(args?: SelectSubset<T, InvoiceCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$InvoicePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Invoice.
     * @param {InvoiceDeleteArgs} args - Arguments to delete one Invoice.
     * @example
     * // Delete one Invoice
     * const Invoice = await prisma.invoice.delete({
     *   where: {
     *     // ... filter to delete one Invoice
     *   }
     * })
     * 
     */
    delete<T extends InvoiceDeleteArgs>(args: SelectSubset<T, InvoiceDeleteArgs<ExtArgs>>): Prisma__InvoiceClient<$Result.GetResult<Prisma.$InvoicePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Invoice.
     * @param {InvoiceUpdateArgs} args - Arguments to update one Invoice.
     * @example
     * // Update one Invoice
     * const invoice = await prisma.invoice.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends InvoiceUpdateArgs>(args: SelectSubset<T, InvoiceUpdateArgs<ExtArgs>>): Prisma__InvoiceClient<$Result.GetResult<Prisma.$InvoicePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Invoices.
     * @param {InvoiceDeleteManyArgs} args - Arguments to filter Invoices to delete.
     * @example
     * // Delete a few Invoices
     * const { count } = await prisma.invoice.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends InvoiceDeleteManyArgs>(args?: SelectSubset<T, InvoiceDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Invoices.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InvoiceUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Invoices
     * const invoice = await prisma.invoice.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends InvoiceUpdateManyArgs>(args: SelectSubset<T, InvoiceUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Invoices and returns the data updated in the database.
     * @param {InvoiceUpdateManyAndReturnArgs} args - Arguments to update many Invoices.
     * @example
     * // Update many Invoices
     * const invoice = await prisma.invoice.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Invoices and only return the `id`
     * const invoiceWithIdOnly = await prisma.invoice.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends InvoiceUpdateManyAndReturnArgs>(args: SelectSubset<T, InvoiceUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$InvoicePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Invoice.
     * @param {InvoiceUpsertArgs} args - Arguments to update or create a Invoice.
     * @example
     * // Update or create a Invoice
     * const invoice = await prisma.invoice.upsert({
     *   create: {
     *     // ... data to create a Invoice
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Invoice we want to update
     *   }
     * })
     */
    upsert<T extends InvoiceUpsertArgs>(args: SelectSubset<T, InvoiceUpsertArgs<ExtArgs>>): Prisma__InvoiceClient<$Result.GetResult<Prisma.$InvoicePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Invoices.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InvoiceCountArgs} args - Arguments to filter Invoices to count.
     * @example
     * // Count the number of Invoices
     * const count = await prisma.invoice.count({
     *   where: {
     *     // ... the filter for the Invoices we want to count
     *   }
     * })
    **/
    count<T extends InvoiceCountArgs>(
      args?: Subset<T, InvoiceCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], InvoiceCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Invoice.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InvoiceAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends InvoiceAggregateArgs>(args: Subset<T, InvoiceAggregateArgs>): Prisma.PrismaPromise<GetInvoiceAggregateType<T>>

    /**
     * Group by Invoice.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InvoiceGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends InvoiceGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: InvoiceGroupByArgs['orderBy'] }
        : { orderBy?: InvoiceGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, InvoiceGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetInvoiceGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Invoice model
   */
  readonly fields: InvoiceFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Invoice.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__InvoiceClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    subscription<T extends SubscriptionDefaultArgs<ExtArgs> = {}>(args?: Subset<T, SubscriptionDefaultArgs<ExtArgs>>): Prisma__SubscriptionClient<$Result.GetResult<Prisma.$SubscriptionPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Invoice model
   */
  interface InvoiceFieldRefs {
    readonly id: FieldRef<"Invoice", 'String'>
    readonly subscriptionId: FieldRef<"Invoice", 'String'>
    readonly amount: FieldRef<"Invoice", 'Float'>
    readonly status: FieldRef<"Invoice", 'String'>
    readonly dueDate: FieldRef<"Invoice", 'DateTime'>
    readonly paidAt: FieldRef<"Invoice", 'DateTime'>
    readonly createdAt: FieldRef<"Invoice", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Invoice findUnique
   */
  export type InvoiceFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Invoice
     */
    select?: InvoiceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Invoice
     */
    omit?: InvoiceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvoiceInclude<ExtArgs> | null
    /**
     * Filter, which Invoice to fetch.
     */
    where: InvoiceWhereUniqueInput
  }

  /**
   * Invoice findUniqueOrThrow
   */
  export type InvoiceFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Invoice
     */
    select?: InvoiceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Invoice
     */
    omit?: InvoiceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvoiceInclude<ExtArgs> | null
    /**
     * Filter, which Invoice to fetch.
     */
    where: InvoiceWhereUniqueInput
  }

  /**
   * Invoice findFirst
   */
  export type InvoiceFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Invoice
     */
    select?: InvoiceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Invoice
     */
    omit?: InvoiceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvoiceInclude<ExtArgs> | null
    /**
     * Filter, which Invoice to fetch.
     */
    where?: InvoiceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Invoices to fetch.
     */
    orderBy?: InvoiceOrderByWithRelationInput | InvoiceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Invoices.
     */
    cursor?: InvoiceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Invoices from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Invoices.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Invoices.
     */
    distinct?: InvoiceScalarFieldEnum | InvoiceScalarFieldEnum[]
  }

  /**
   * Invoice findFirstOrThrow
   */
  export type InvoiceFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Invoice
     */
    select?: InvoiceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Invoice
     */
    omit?: InvoiceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvoiceInclude<ExtArgs> | null
    /**
     * Filter, which Invoice to fetch.
     */
    where?: InvoiceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Invoices to fetch.
     */
    orderBy?: InvoiceOrderByWithRelationInput | InvoiceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Invoices.
     */
    cursor?: InvoiceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Invoices from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Invoices.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Invoices.
     */
    distinct?: InvoiceScalarFieldEnum | InvoiceScalarFieldEnum[]
  }

  /**
   * Invoice findMany
   */
  export type InvoiceFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Invoice
     */
    select?: InvoiceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Invoice
     */
    omit?: InvoiceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvoiceInclude<ExtArgs> | null
    /**
     * Filter, which Invoices to fetch.
     */
    where?: InvoiceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Invoices to fetch.
     */
    orderBy?: InvoiceOrderByWithRelationInput | InvoiceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Invoices.
     */
    cursor?: InvoiceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Invoices from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Invoices.
     */
    skip?: number
    distinct?: InvoiceScalarFieldEnum | InvoiceScalarFieldEnum[]
  }

  /**
   * Invoice create
   */
  export type InvoiceCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Invoice
     */
    select?: InvoiceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Invoice
     */
    omit?: InvoiceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvoiceInclude<ExtArgs> | null
    /**
     * The data needed to create a Invoice.
     */
    data: XOR<InvoiceCreateInput, InvoiceUncheckedCreateInput>
  }

  /**
   * Invoice createMany
   */
  export type InvoiceCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Invoices.
     */
    data: InvoiceCreateManyInput | InvoiceCreateManyInput[]
  }

  /**
   * Invoice createManyAndReturn
   */
  export type InvoiceCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Invoice
     */
    select?: InvoiceSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Invoice
     */
    omit?: InvoiceOmit<ExtArgs> | null
    /**
     * The data used to create many Invoices.
     */
    data: InvoiceCreateManyInput | InvoiceCreateManyInput[]
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvoiceIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Invoice update
   */
  export type InvoiceUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Invoice
     */
    select?: InvoiceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Invoice
     */
    omit?: InvoiceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvoiceInclude<ExtArgs> | null
    /**
     * The data needed to update a Invoice.
     */
    data: XOR<InvoiceUpdateInput, InvoiceUncheckedUpdateInput>
    /**
     * Choose, which Invoice to update.
     */
    where: InvoiceWhereUniqueInput
  }

  /**
   * Invoice updateMany
   */
  export type InvoiceUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Invoices.
     */
    data: XOR<InvoiceUpdateManyMutationInput, InvoiceUncheckedUpdateManyInput>
    /**
     * Filter which Invoices to update
     */
    where?: InvoiceWhereInput
    /**
     * Limit how many Invoices to update.
     */
    limit?: number
  }

  /**
   * Invoice updateManyAndReturn
   */
  export type InvoiceUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Invoice
     */
    select?: InvoiceSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Invoice
     */
    omit?: InvoiceOmit<ExtArgs> | null
    /**
     * The data used to update Invoices.
     */
    data: XOR<InvoiceUpdateManyMutationInput, InvoiceUncheckedUpdateManyInput>
    /**
     * Filter which Invoices to update
     */
    where?: InvoiceWhereInput
    /**
     * Limit how many Invoices to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvoiceIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Invoice upsert
   */
  export type InvoiceUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Invoice
     */
    select?: InvoiceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Invoice
     */
    omit?: InvoiceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvoiceInclude<ExtArgs> | null
    /**
     * The filter to search for the Invoice to update in case it exists.
     */
    where: InvoiceWhereUniqueInput
    /**
     * In case the Invoice found by the `where` argument doesn't exist, create a new Invoice with this data.
     */
    create: XOR<InvoiceCreateInput, InvoiceUncheckedCreateInput>
    /**
     * In case the Invoice was found with the provided `where` argument, update it with this data.
     */
    update: XOR<InvoiceUpdateInput, InvoiceUncheckedUpdateInput>
  }

  /**
   * Invoice delete
   */
  export type InvoiceDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Invoice
     */
    select?: InvoiceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Invoice
     */
    omit?: InvoiceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvoiceInclude<ExtArgs> | null
    /**
     * Filter which Invoice to delete.
     */
    where: InvoiceWhereUniqueInput
  }

  /**
   * Invoice deleteMany
   */
  export type InvoiceDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Invoices to delete
     */
    where?: InvoiceWhereInput
    /**
     * Limit how many Invoices to delete.
     */
    limit?: number
  }

  /**
   * Invoice without action
   */
  export type InvoiceDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Invoice
     */
    select?: InvoiceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Invoice
     */
    omit?: InvoiceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvoiceInclude<ExtArgs> | null
  }


  /**
   * Model MikrotikDevice
   */

  export type AggregateMikrotikDevice = {
    _count: MikrotikDeviceCountAggregateOutputType | null
    _avg: MikrotikDeviceAvgAggregateOutputType | null
    _sum: MikrotikDeviceSumAggregateOutputType | null
    _min: MikrotikDeviceMinAggregateOutputType | null
    _max: MikrotikDeviceMaxAggregateOutputType | null
  }

  export type MikrotikDeviceAvgAggregateOutputType = {
    port: number | null
    cpu: number | null
    memory: number | null
    interfaces: number | null
  }

  export type MikrotikDeviceSumAggregateOutputType = {
    port: number | null
    cpu: number | null
    memory: number | null
    interfaces: number | null
  }

  export type MikrotikDeviceMinAggregateOutputType = {
    id: string | null
    name: string | null
    ip: string | null
    mac: string | null
    username: string | null
    password: string | null
    port: number | null
    status: string | null
    model: string | null
    version: string | null
    uptime: string | null
    cpu: number | null
    memory: number | null
    interfaces: number | null
    lastSeen: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type MikrotikDeviceMaxAggregateOutputType = {
    id: string | null
    name: string | null
    ip: string | null
    mac: string | null
    username: string | null
    password: string | null
    port: number | null
    status: string | null
    model: string | null
    version: string | null
    uptime: string | null
    cpu: number | null
    memory: number | null
    interfaces: number | null
    lastSeen: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type MikrotikDeviceCountAggregateOutputType = {
    id: number
    name: number
    ip: number
    mac: number
    username: number
    password: number
    port: number
    status: number
    model: number
    version: number
    uptime: number
    cpu: number
    memory: number
    interfaces: number
    lastSeen: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type MikrotikDeviceAvgAggregateInputType = {
    port?: true
    cpu?: true
    memory?: true
    interfaces?: true
  }

  export type MikrotikDeviceSumAggregateInputType = {
    port?: true
    cpu?: true
    memory?: true
    interfaces?: true
  }

  export type MikrotikDeviceMinAggregateInputType = {
    id?: true
    name?: true
    ip?: true
    mac?: true
    username?: true
    password?: true
    port?: true
    status?: true
    model?: true
    version?: true
    uptime?: true
    cpu?: true
    memory?: true
    interfaces?: true
    lastSeen?: true
    createdAt?: true
    updatedAt?: true
  }

  export type MikrotikDeviceMaxAggregateInputType = {
    id?: true
    name?: true
    ip?: true
    mac?: true
    username?: true
    password?: true
    port?: true
    status?: true
    model?: true
    version?: true
    uptime?: true
    cpu?: true
    memory?: true
    interfaces?: true
    lastSeen?: true
    createdAt?: true
    updatedAt?: true
  }

  export type MikrotikDeviceCountAggregateInputType = {
    id?: true
    name?: true
    ip?: true
    mac?: true
    username?: true
    password?: true
    port?: true
    status?: true
    model?: true
    version?: true
    uptime?: true
    cpu?: true
    memory?: true
    interfaces?: true
    lastSeen?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type MikrotikDeviceAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which MikrotikDevice to aggregate.
     */
    where?: MikrotikDeviceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MikrotikDevices to fetch.
     */
    orderBy?: MikrotikDeviceOrderByWithRelationInput | MikrotikDeviceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: MikrotikDeviceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MikrotikDevices from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MikrotikDevices.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned MikrotikDevices
    **/
    _count?: true | MikrotikDeviceCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: MikrotikDeviceAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: MikrotikDeviceSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: MikrotikDeviceMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: MikrotikDeviceMaxAggregateInputType
  }

  export type GetMikrotikDeviceAggregateType<T extends MikrotikDeviceAggregateArgs> = {
        [P in keyof T & keyof AggregateMikrotikDevice]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateMikrotikDevice[P]>
      : GetScalarType<T[P], AggregateMikrotikDevice[P]>
  }




  export type MikrotikDeviceGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MikrotikDeviceWhereInput
    orderBy?: MikrotikDeviceOrderByWithAggregationInput | MikrotikDeviceOrderByWithAggregationInput[]
    by: MikrotikDeviceScalarFieldEnum[] | MikrotikDeviceScalarFieldEnum
    having?: MikrotikDeviceScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: MikrotikDeviceCountAggregateInputType | true
    _avg?: MikrotikDeviceAvgAggregateInputType
    _sum?: MikrotikDeviceSumAggregateInputType
    _min?: MikrotikDeviceMinAggregateInputType
    _max?: MikrotikDeviceMaxAggregateInputType
  }

  export type MikrotikDeviceGroupByOutputType = {
    id: string
    name: string
    ip: string
    mac: string | null
    username: string
    password: string
    port: number
    status: string
    model: string | null
    version: string | null
    uptime: string | null
    cpu: number | null
    memory: number | null
    interfaces: number | null
    lastSeen: Date | null
    createdAt: Date
    updatedAt: Date
    _count: MikrotikDeviceCountAggregateOutputType | null
    _avg: MikrotikDeviceAvgAggregateOutputType | null
    _sum: MikrotikDeviceSumAggregateOutputType | null
    _min: MikrotikDeviceMinAggregateOutputType | null
    _max: MikrotikDeviceMaxAggregateOutputType | null
  }

  type GetMikrotikDeviceGroupByPayload<T extends MikrotikDeviceGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<MikrotikDeviceGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof MikrotikDeviceGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], MikrotikDeviceGroupByOutputType[P]>
            : GetScalarType<T[P], MikrotikDeviceGroupByOutputType[P]>
        }
      >
    >


  export type MikrotikDeviceSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    ip?: boolean
    mac?: boolean
    username?: boolean
    password?: boolean
    port?: boolean
    status?: boolean
    model?: boolean
    version?: boolean
    uptime?: boolean
    cpu?: boolean
    memory?: boolean
    interfaces?: boolean
    lastSeen?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["mikrotikDevice"]>

  export type MikrotikDeviceSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    ip?: boolean
    mac?: boolean
    username?: boolean
    password?: boolean
    port?: boolean
    status?: boolean
    model?: boolean
    version?: boolean
    uptime?: boolean
    cpu?: boolean
    memory?: boolean
    interfaces?: boolean
    lastSeen?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["mikrotikDevice"]>

  export type MikrotikDeviceSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    ip?: boolean
    mac?: boolean
    username?: boolean
    password?: boolean
    port?: boolean
    status?: boolean
    model?: boolean
    version?: boolean
    uptime?: boolean
    cpu?: boolean
    memory?: boolean
    interfaces?: boolean
    lastSeen?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["mikrotikDevice"]>

  export type MikrotikDeviceSelectScalar = {
    id?: boolean
    name?: boolean
    ip?: boolean
    mac?: boolean
    username?: boolean
    password?: boolean
    port?: boolean
    status?: boolean
    model?: boolean
    version?: boolean
    uptime?: boolean
    cpu?: boolean
    memory?: boolean
    interfaces?: boolean
    lastSeen?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type MikrotikDeviceOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "ip" | "mac" | "username" | "password" | "port" | "status" | "model" | "version" | "uptime" | "cpu" | "memory" | "interfaces" | "lastSeen" | "createdAt" | "updatedAt", ExtArgs["result"]["mikrotikDevice"]>

  export type $MikrotikDevicePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "MikrotikDevice"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      ip: string
      mac: string | null
      username: string
      password: string
      port: number
      status: string
      model: string | null
      version: string | null
      uptime: string | null
      cpu: number | null
      memory: number | null
      interfaces: number | null
      lastSeen: Date | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["mikrotikDevice"]>
    composites: {}
  }

  type MikrotikDeviceGetPayload<S extends boolean | null | undefined | MikrotikDeviceDefaultArgs> = $Result.GetResult<Prisma.$MikrotikDevicePayload, S>

  type MikrotikDeviceCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<MikrotikDeviceFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: MikrotikDeviceCountAggregateInputType | true
    }

  export interface MikrotikDeviceDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['MikrotikDevice'], meta: { name: 'MikrotikDevice' } }
    /**
     * Find zero or one MikrotikDevice that matches the filter.
     * @param {MikrotikDeviceFindUniqueArgs} args - Arguments to find a MikrotikDevice
     * @example
     * // Get one MikrotikDevice
     * const mikrotikDevice = await prisma.mikrotikDevice.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends MikrotikDeviceFindUniqueArgs>(args: SelectSubset<T, MikrotikDeviceFindUniqueArgs<ExtArgs>>): Prisma__MikrotikDeviceClient<$Result.GetResult<Prisma.$MikrotikDevicePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one MikrotikDevice that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {MikrotikDeviceFindUniqueOrThrowArgs} args - Arguments to find a MikrotikDevice
     * @example
     * // Get one MikrotikDevice
     * const mikrotikDevice = await prisma.mikrotikDevice.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends MikrotikDeviceFindUniqueOrThrowArgs>(args: SelectSubset<T, MikrotikDeviceFindUniqueOrThrowArgs<ExtArgs>>): Prisma__MikrotikDeviceClient<$Result.GetResult<Prisma.$MikrotikDevicePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first MikrotikDevice that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MikrotikDeviceFindFirstArgs} args - Arguments to find a MikrotikDevice
     * @example
     * // Get one MikrotikDevice
     * const mikrotikDevice = await prisma.mikrotikDevice.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends MikrotikDeviceFindFirstArgs>(args?: SelectSubset<T, MikrotikDeviceFindFirstArgs<ExtArgs>>): Prisma__MikrotikDeviceClient<$Result.GetResult<Prisma.$MikrotikDevicePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first MikrotikDevice that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MikrotikDeviceFindFirstOrThrowArgs} args - Arguments to find a MikrotikDevice
     * @example
     * // Get one MikrotikDevice
     * const mikrotikDevice = await prisma.mikrotikDevice.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends MikrotikDeviceFindFirstOrThrowArgs>(args?: SelectSubset<T, MikrotikDeviceFindFirstOrThrowArgs<ExtArgs>>): Prisma__MikrotikDeviceClient<$Result.GetResult<Prisma.$MikrotikDevicePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more MikrotikDevices that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MikrotikDeviceFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all MikrotikDevices
     * const mikrotikDevices = await prisma.mikrotikDevice.findMany()
     * 
     * // Get first 10 MikrotikDevices
     * const mikrotikDevices = await prisma.mikrotikDevice.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const mikrotikDeviceWithIdOnly = await prisma.mikrotikDevice.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends MikrotikDeviceFindManyArgs>(args?: SelectSubset<T, MikrotikDeviceFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MikrotikDevicePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a MikrotikDevice.
     * @param {MikrotikDeviceCreateArgs} args - Arguments to create a MikrotikDevice.
     * @example
     * // Create one MikrotikDevice
     * const MikrotikDevice = await prisma.mikrotikDevice.create({
     *   data: {
     *     // ... data to create a MikrotikDevice
     *   }
     * })
     * 
     */
    create<T extends MikrotikDeviceCreateArgs>(args: SelectSubset<T, MikrotikDeviceCreateArgs<ExtArgs>>): Prisma__MikrotikDeviceClient<$Result.GetResult<Prisma.$MikrotikDevicePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many MikrotikDevices.
     * @param {MikrotikDeviceCreateManyArgs} args - Arguments to create many MikrotikDevices.
     * @example
     * // Create many MikrotikDevices
     * const mikrotikDevice = await prisma.mikrotikDevice.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends MikrotikDeviceCreateManyArgs>(args?: SelectSubset<T, MikrotikDeviceCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many MikrotikDevices and returns the data saved in the database.
     * @param {MikrotikDeviceCreateManyAndReturnArgs} args - Arguments to create many MikrotikDevices.
     * @example
     * // Create many MikrotikDevices
     * const mikrotikDevice = await prisma.mikrotikDevice.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many MikrotikDevices and only return the `id`
     * const mikrotikDeviceWithIdOnly = await prisma.mikrotikDevice.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends MikrotikDeviceCreateManyAndReturnArgs>(args?: SelectSubset<T, MikrotikDeviceCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MikrotikDevicePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a MikrotikDevice.
     * @param {MikrotikDeviceDeleteArgs} args - Arguments to delete one MikrotikDevice.
     * @example
     * // Delete one MikrotikDevice
     * const MikrotikDevice = await prisma.mikrotikDevice.delete({
     *   where: {
     *     // ... filter to delete one MikrotikDevice
     *   }
     * })
     * 
     */
    delete<T extends MikrotikDeviceDeleteArgs>(args: SelectSubset<T, MikrotikDeviceDeleteArgs<ExtArgs>>): Prisma__MikrotikDeviceClient<$Result.GetResult<Prisma.$MikrotikDevicePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one MikrotikDevice.
     * @param {MikrotikDeviceUpdateArgs} args - Arguments to update one MikrotikDevice.
     * @example
     * // Update one MikrotikDevice
     * const mikrotikDevice = await prisma.mikrotikDevice.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends MikrotikDeviceUpdateArgs>(args: SelectSubset<T, MikrotikDeviceUpdateArgs<ExtArgs>>): Prisma__MikrotikDeviceClient<$Result.GetResult<Prisma.$MikrotikDevicePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more MikrotikDevices.
     * @param {MikrotikDeviceDeleteManyArgs} args - Arguments to filter MikrotikDevices to delete.
     * @example
     * // Delete a few MikrotikDevices
     * const { count } = await prisma.mikrotikDevice.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends MikrotikDeviceDeleteManyArgs>(args?: SelectSubset<T, MikrotikDeviceDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more MikrotikDevices.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MikrotikDeviceUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many MikrotikDevices
     * const mikrotikDevice = await prisma.mikrotikDevice.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends MikrotikDeviceUpdateManyArgs>(args: SelectSubset<T, MikrotikDeviceUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more MikrotikDevices and returns the data updated in the database.
     * @param {MikrotikDeviceUpdateManyAndReturnArgs} args - Arguments to update many MikrotikDevices.
     * @example
     * // Update many MikrotikDevices
     * const mikrotikDevice = await prisma.mikrotikDevice.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more MikrotikDevices and only return the `id`
     * const mikrotikDeviceWithIdOnly = await prisma.mikrotikDevice.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends MikrotikDeviceUpdateManyAndReturnArgs>(args: SelectSubset<T, MikrotikDeviceUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MikrotikDevicePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one MikrotikDevice.
     * @param {MikrotikDeviceUpsertArgs} args - Arguments to update or create a MikrotikDevice.
     * @example
     * // Update or create a MikrotikDevice
     * const mikrotikDevice = await prisma.mikrotikDevice.upsert({
     *   create: {
     *     // ... data to create a MikrotikDevice
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the MikrotikDevice we want to update
     *   }
     * })
     */
    upsert<T extends MikrotikDeviceUpsertArgs>(args: SelectSubset<T, MikrotikDeviceUpsertArgs<ExtArgs>>): Prisma__MikrotikDeviceClient<$Result.GetResult<Prisma.$MikrotikDevicePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of MikrotikDevices.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MikrotikDeviceCountArgs} args - Arguments to filter MikrotikDevices to count.
     * @example
     * // Count the number of MikrotikDevices
     * const count = await prisma.mikrotikDevice.count({
     *   where: {
     *     // ... the filter for the MikrotikDevices we want to count
     *   }
     * })
    **/
    count<T extends MikrotikDeviceCountArgs>(
      args?: Subset<T, MikrotikDeviceCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], MikrotikDeviceCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a MikrotikDevice.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MikrotikDeviceAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends MikrotikDeviceAggregateArgs>(args: Subset<T, MikrotikDeviceAggregateArgs>): Prisma.PrismaPromise<GetMikrotikDeviceAggregateType<T>>

    /**
     * Group by MikrotikDevice.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MikrotikDeviceGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends MikrotikDeviceGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: MikrotikDeviceGroupByArgs['orderBy'] }
        : { orderBy?: MikrotikDeviceGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, MikrotikDeviceGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetMikrotikDeviceGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the MikrotikDevice model
   */
  readonly fields: MikrotikDeviceFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for MikrotikDevice.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__MikrotikDeviceClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the MikrotikDevice model
   */
  interface MikrotikDeviceFieldRefs {
    readonly id: FieldRef<"MikrotikDevice", 'String'>
    readonly name: FieldRef<"MikrotikDevice", 'String'>
    readonly ip: FieldRef<"MikrotikDevice", 'String'>
    readonly mac: FieldRef<"MikrotikDevice", 'String'>
    readonly username: FieldRef<"MikrotikDevice", 'String'>
    readonly password: FieldRef<"MikrotikDevice", 'String'>
    readonly port: FieldRef<"MikrotikDevice", 'Int'>
    readonly status: FieldRef<"MikrotikDevice", 'String'>
    readonly model: FieldRef<"MikrotikDevice", 'String'>
    readonly version: FieldRef<"MikrotikDevice", 'String'>
    readonly uptime: FieldRef<"MikrotikDevice", 'String'>
    readonly cpu: FieldRef<"MikrotikDevice", 'Float'>
    readonly memory: FieldRef<"MikrotikDevice", 'Float'>
    readonly interfaces: FieldRef<"MikrotikDevice", 'Int'>
    readonly lastSeen: FieldRef<"MikrotikDevice", 'DateTime'>
    readonly createdAt: FieldRef<"MikrotikDevice", 'DateTime'>
    readonly updatedAt: FieldRef<"MikrotikDevice", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * MikrotikDevice findUnique
   */
  export type MikrotikDeviceFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MikrotikDevice
     */
    select?: MikrotikDeviceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MikrotikDevice
     */
    omit?: MikrotikDeviceOmit<ExtArgs> | null
    /**
     * Filter, which MikrotikDevice to fetch.
     */
    where: MikrotikDeviceWhereUniqueInput
  }

  /**
   * MikrotikDevice findUniqueOrThrow
   */
  export type MikrotikDeviceFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MikrotikDevice
     */
    select?: MikrotikDeviceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MikrotikDevice
     */
    omit?: MikrotikDeviceOmit<ExtArgs> | null
    /**
     * Filter, which MikrotikDevice to fetch.
     */
    where: MikrotikDeviceWhereUniqueInput
  }

  /**
   * MikrotikDevice findFirst
   */
  export type MikrotikDeviceFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MikrotikDevice
     */
    select?: MikrotikDeviceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MikrotikDevice
     */
    omit?: MikrotikDeviceOmit<ExtArgs> | null
    /**
     * Filter, which MikrotikDevice to fetch.
     */
    where?: MikrotikDeviceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MikrotikDevices to fetch.
     */
    orderBy?: MikrotikDeviceOrderByWithRelationInput | MikrotikDeviceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for MikrotikDevices.
     */
    cursor?: MikrotikDeviceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MikrotikDevices from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MikrotikDevices.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of MikrotikDevices.
     */
    distinct?: MikrotikDeviceScalarFieldEnum | MikrotikDeviceScalarFieldEnum[]
  }

  /**
   * MikrotikDevice findFirstOrThrow
   */
  export type MikrotikDeviceFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MikrotikDevice
     */
    select?: MikrotikDeviceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MikrotikDevice
     */
    omit?: MikrotikDeviceOmit<ExtArgs> | null
    /**
     * Filter, which MikrotikDevice to fetch.
     */
    where?: MikrotikDeviceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MikrotikDevices to fetch.
     */
    orderBy?: MikrotikDeviceOrderByWithRelationInput | MikrotikDeviceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for MikrotikDevices.
     */
    cursor?: MikrotikDeviceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MikrotikDevices from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MikrotikDevices.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of MikrotikDevices.
     */
    distinct?: MikrotikDeviceScalarFieldEnum | MikrotikDeviceScalarFieldEnum[]
  }

  /**
   * MikrotikDevice findMany
   */
  export type MikrotikDeviceFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MikrotikDevice
     */
    select?: MikrotikDeviceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MikrotikDevice
     */
    omit?: MikrotikDeviceOmit<ExtArgs> | null
    /**
     * Filter, which MikrotikDevices to fetch.
     */
    where?: MikrotikDeviceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MikrotikDevices to fetch.
     */
    orderBy?: MikrotikDeviceOrderByWithRelationInput | MikrotikDeviceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing MikrotikDevices.
     */
    cursor?: MikrotikDeviceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MikrotikDevices from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MikrotikDevices.
     */
    skip?: number
    distinct?: MikrotikDeviceScalarFieldEnum | MikrotikDeviceScalarFieldEnum[]
  }

  /**
   * MikrotikDevice create
   */
  export type MikrotikDeviceCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MikrotikDevice
     */
    select?: MikrotikDeviceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MikrotikDevice
     */
    omit?: MikrotikDeviceOmit<ExtArgs> | null
    /**
     * The data needed to create a MikrotikDevice.
     */
    data: XOR<MikrotikDeviceCreateInput, MikrotikDeviceUncheckedCreateInput>
  }

  /**
   * MikrotikDevice createMany
   */
  export type MikrotikDeviceCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many MikrotikDevices.
     */
    data: MikrotikDeviceCreateManyInput | MikrotikDeviceCreateManyInput[]
  }

  /**
   * MikrotikDevice createManyAndReturn
   */
  export type MikrotikDeviceCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MikrotikDevice
     */
    select?: MikrotikDeviceSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the MikrotikDevice
     */
    omit?: MikrotikDeviceOmit<ExtArgs> | null
    /**
     * The data used to create many MikrotikDevices.
     */
    data: MikrotikDeviceCreateManyInput | MikrotikDeviceCreateManyInput[]
  }

  /**
   * MikrotikDevice update
   */
  export type MikrotikDeviceUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MikrotikDevice
     */
    select?: MikrotikDeviceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MikrotikDevice
     */
    omit?: MikrotikDeviceOmit<ExtArgs> | null
    /**
     * The data needed to update a MikrotikDevice.
     */
    data: XOR<MikrotikDeviceUpdateInput, MikrotikDeviceUncheckedUpdateInput>
    /**
     * Choose, which MikrotikDevice to update.
     */
    where: MikrotikDeviceWhereUniqueInput
  }

  /**
   * MikrotikDevice updateMany
   */
  export type MikrotikDeviceUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update MikrotikDevices.
     */
    data: XOR<MikrotikDeviceUpdateManyMutationInput, MikrotikDeviceUncheckedUpdateManyInput>
    /**
     * Filter which MikrotikDevices to update
     */
    where?: MikrotikDeviceWhereInput
    /**
     * Limit how many MikrotikDevices to update.
     */
    limit?: number
  }

  /**
   * MikrotikDevice updateManyAndReturn
   */
  export type MikrotikDeviceUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MikrotikDevice
     */
    select?: MikrotikDeviceSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the MikrotikDevice
     */
    omit?: MikrotikDeviceOmit<ExtArgs> | null
    /**
     * The data used to update MikrotikDevices.
     */
    data: XOR<MikrotikDeviceUpdateManyMutationInput, MikrotikDeviceUncheckedUpdateManyInput>
    /**
     * Filter which MikrotikDevices to update
     */
    where?: MikrotikDeviceWhereInput
    /**
     * Limit how many MikrotikDevices to update.
     */
    limit?: number
  }

  /**
   * MikrotikDevice upsert
   */
  export type MikrotikDeviceUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MikrotikDevice
     */
    select?: MikrotikDeviceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MikrotikDevice
     */
    omit?: MikrotikDeviceOmit<ExtArgs> | null
    /**
     * The filter to search for the MikrotikDevice to update in case it exists.
     */
    where: MikrotikDeviceWhereUniqueInput
    /**
     * In case the MikrotikDevice found by the `where` argument doesn't exist, create a new MikrotikDevice with this data.
     */
    create: XOR<MikrotikDeviceCreateInput, MikrotikDeviceUncheckedCreateInput>
    /**
     * In case the MikrotikDevice was found with the provided `where` argument, update it with this data.
     */
    update: XOR<MikrotikDeviceUpdateInput, MikrotikDeviceUncheckedUpdateInput>
  }

  /**
   * MikrotikDevice delete
   */
  export type MikrotikDeviceDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MikrotikDevice
     */
    select?: MikrotikDeviceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MikrotikDevice
     */
    omit?: MikrotikDeviceOmit<ExtArgs> | null
    /**
     * Filter which MikrotikDevice to delete.
     */
    where: MikrotikDeviceWhereUniqueInput
  }

  /**
   * MikrotikDevice deleteMany
   */
  export type MikrotikDeviceDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which MikrotikDevices to delete
     */
    where?: MikrotikDeviceWhereInput
    /**
     * Limit how many MikrotikDevices to delete.
     */
    limit?: number
  }

  /**
   * MikrotikDevice without action
   */
  export type MikrotikDeviceDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MikrotikDevice
     */
    select?: MikrotikDeviceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MikrotikDevice
     */
    omit?: MikrotikDeviceOmit<ExtArgs> | null
  }


  /**
   * Model Domain
   */

  export type AggregateDomain = {
    _count: DomainCountAggregateOutputType | null
    _avg: DomainAvgAggregateOutputType | null
    _sum: DomainSumAggregateOutputType | null
    _min: DomainMinAggregateOutputType | null
    _max: DomainMaxAggregateOutputType | null
  }

  export type DomainAvgAggregateOutputType = {
    dnsRecords: number | null
  }

  export type DomainSumAggregateOutputType = {
    dnsRecords: number | null
  }

  export type DomainMinAggregateOutputType = {
    id: string | null
    name: string | null
    cloudflareId: string | null
    status: string | null
    nameservers: string | null
    created: Date | null
    expires: Date | null
    sslStatus: string | null
    dnsRecords: number | null
    raw: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type DomainMaxAggregateOutputType = {
    id: string | null
    name: string | null
    cloudflareId: string | null
    status: string | null
    nameservers: string | null
    created: Date | null
    expires: Date | null
    sslStatus: string | null
    dnsRecords: number | null
    raw: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type DomainCountAggregateOutputType = {
    id: number
    name: number
    cloudflareId: number
    status: number
    nameservers: number
    created: number
    expires: number
    sslStatus: number
    dnsRecords: number
    raw: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type DomainAvgAggregateInputType = {
    dnsRecords?: true
  }

  export type DomainSumAggregateInputType = {
    dnsRecords?: true
  }

  export type DomainMinAggregateInputType = {
    id?: true
    name?: true
    cloudflareId?: true
    status?: true
    nameservers?: true
    created?: true
    expires?: true
    sslStatus?: true
    dnsRecords?: true
    raw?: true
    createdAt?: true
    updatedAt?: true
  }

  export type DomainMaxAggregateInputType = {
    id?: true
    name?: true
    cloudflareId?: true
    status?: true
    nameservers?: true
    created?: true
    expires?: true
    sslStatus?: true
    dnsRecords?: true
    raw?: true
    createdAt?: true
    updatedAt?: true
  }

  export type DomainCountAggregateInputType = {
    id?: true
    name?: true
    cloudflareId?: true
    status?: true
    nameservers?: true
    created?: true
    expires?: true
    sslStatus?: true
    dnsRecords?: true
    raw?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type DomainAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Domain to aggregate.
     */
    where?: DomainWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Domains to fetch.
     */
    orderBy?: DomainOrderByWithRelationInput | DomainOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: DomainWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Domains from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Domains.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Domains
    **/
    _count?: true | DomainCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: DomainAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: DomainSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: DomainMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: DomainMaxAggregateInputType
  }

  export type GetDomainAggregateType<T extends DomainAggregateArgs> = {
        [P in keyof T & keyof AggregateDomain]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateDomain[P]>
      : GetScalarType<T[P], AggregateDomain[P]>
  }




  export type DomainGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: DomainWhereInput
    orderBy?: DomainOrderByWithAggregationInput | DomainOrderByWithAggregationInput[]
    by: DomainScalarFieldEnum[] | DomainScalarFieldEnum
    having?: DomainScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: DomainCountAggregateInputType | true
    _avg?: DomainAvgAggregateInputType
    _sum?: DomainSumAggregateInputType
    _min?: DomainMinAggregateInputType
    _max?: DomainMaxAggregateInputType
  }

  export type DomainGroupByOutputType = {
    id: string
    name: string
    cloudflareId: string | null
    status: string
    nameservers: string | null
    created: Date | null
    expires: Date | null
    sslStatus: string | null
    dnsRecords: number
    raw: string | null
    createdAt: Date
    updatedAt: Date
    _count: DomainCountAggregateOutputType | null
    _avg: DomainAvgAggregateOutputType | null
    _sum: DomainSumAggregateOutputType | null
    _min: DomainMinAggregateOutputType | null
    _max: DomainMaxAggregateOutputType | null
  }

  type GetDomainGroupByPayload<T extends DomainGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<DomainGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof DomainGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], DomainGroupByOutputType[P]>
            : GetScalarType<T[P], DomainGroupByOutputType[P]>
        }
      >
    >


  export type DomainSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    cloudflareId?: boolean
    status?: boolean
    nameservers?: boolean
    created?: boolean
    expires?: boolean
    sslStatus?: boolean
    dnsRecords?: boolean
    raw?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["domain"]>

  export type DomainSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    cloudflareId?: boolean
    status?: boolean
    nameservers?: boolean
    created?: boolean
    expires?: boolean
    sslStatus?: boolean
    dnsRecords?: boolean
    raw?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["domain"]>

  export type DomainSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    cloudflareId?: boolean
    status?: boolean
    nameservers?: boolean
    created?: boolean
    expires?: boolean
    sslStatus?: boolean
    dnsRecords?: boolean
    raw?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["domain"]>

  export type DomainSelectScalar = {
    id?: boolean
    name?: boolean
    cloudflareId?: boolean
    status?: boolean
    nameservers?: boolean
    created?: boolean
    expires?: boolean
    sslStatus?: boolean
    dnsRecords?: boolean
    raw?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type DomainOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "cloudflareId" | "status" | "nameservers" | "created" | "expires" | "sslStatus" | "dnsRecords" | "raw" | "createdAt" | "updatedAt", ExtArgs["result"]["domain"]>

  export type $DomainPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Domain"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      cloudflareId: string | null
      status: string
      nameservers: string | null
      created: Date | null
      expires: Date | null
      sslStatus: string | null
      dnsRecords: number
      raw: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["domain"]>
    composites: {}
  }

  type DomainGetPayload<S extends boolean | null | undefined | DomainDefaultArgs> = $Result.GetResult<Prisma.$DomainPayload, S>

  type DomainCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<DomainFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: DomainCountAggregateInputType | true
    }

  export interface DomainDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Domain'], meta: { name: 'Domain' } }
    /**
     * Find zero or one Domain that matches the filter.
     * @param {DomainFindUniqueArgs} args - Arguments to find a Domain
     * @example
     * // Get one Domain
     * const domain = await prisma.domain.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends DomainFindUniqueArgs>(args: SelectSubset<T, DomainFindUniqueArgs<ExtArgs>>): Prisma__DomainClient<$Result.GetResult<Prisma.$DomainPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Domain that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {DomainFindUniqueOrThrowArgs} args - Arguments to find a Domain
     * @example
     * // Get one Domain
     * const domain = await prisma.domain.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends DomainFindUniqueOrThrowArgs>(args: SelectSubset<T, DomainFindUniqueOrThrowArgs<ExtArgs>>): Prisma__DomainClient<$Result.GetResult<Prisma.$DomainPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Domain that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DomainFindFirstArgs} args - Arguments to find a Domain
     * @example
     * // Get one Domain
     * const domain = await prisma.domain.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends DomainFindFirstArgs>(args?: SelectSubset<T, DomainFindFirstArgs<ExtArgs>>): Prisma__DomainClient<$Result.GetResult<Prisma.$DomainPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Domain that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DomainFindFirstOrThrowArgs} args - Arguments to find a Domain
     * @example
     * // Get one Domain
     * const domain = await prisma.domain.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends DomainFindFirstOrThrowArgs>(args?: SelectSubset<T, DomainFindFirstOrThrowArgs<ExtArgs>>): Prisma__DomainClient<$Result.GetResult<Prisma.$DomainPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Domains that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DomainFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Domains
     * const domains = await prisma.domain.findMany()
     * 
     * // Get first 10 Domains
     * const domains = await prisma.domain.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const domainWithIdOnly = await prisma.domain.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends DomainFindManyArgs>(args?: SelectSubset<T, DomainFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DomainPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Domain.
     * @param {DomainCreateArgs} args - Arguments to create a Domain.
     * @example
     * // Create one Domain
     * const Domain = await prisma.domain.create({
     *   data: {
     *     // ... data to create a Domain
     *   }
     * })
     * 
     */
    create<T extends DomainCreateArgs>(args: SelectSubset<T, DomainCreateArgs<ExtArgs>>): Prisma__DomainClient<$Result.GetResult<Prisma.$DomainPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Domains.
     * @param {DomainCreateManyArgs} args - Arguments to create many Domains.
     * @example
     * // Create many Domains
     * const domain = await prisma.domain.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends DomainCreateManyArgs>(args?: SelectSubset<T, DomainCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Domains and returns the data saved in the database.
     * @param {DomainCreateManyAndReturnArgs} args - Arguments to create many Domains.
     * @example
     * // Create many Domains
     * const domain = await prisma.domain.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Domains and only return the `id`
     * const domainWithIdOnly = await prisma.domain.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends DomainCreateManyAndReturnArgs>(args?: SelectSubset<T, DomainCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DomainPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Domain.
     * @param {DomainDeleteArgs} args - Arguments to delete one Domain.
     * @example
     * // Delete one Domain
     * const Domain = await prisma.domain.delete({
     *   where: {
     *     // ... filter to delete one Domain
     *   }
     * })
     * 
     */
    delete<T extends DomainDeleteArgs>(args: SelectSubset<T, DomainDeleteArgs<ExtArgs>>): Prisma__DomainClient<$Result.GetResult<Prisma.$DomainPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Domain.
     * @param {DomainUpdateArgs} args - Arguments to update one Domain.
     * @example
     * // Update one Domain
     * const domain = await prisma.domain.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends DomainUpdateArgs>(args: SelectSubset<T, DomainUpdateArgs<ExtArgs>>): Prisma__DomainClient<$Result.GetResult<Prisma.$DomainPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Domains.
     * @param {DomainDeleteManyArgs} args - Arguments to filter Domains to delete.
     * @example
     * // Delete a few Domains
     * const { count } = await prisma.domain.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends DomainDeleteManyArgs>(args?: SelectSubset<T, DomainDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Domains.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DomainUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Domains
     * const domain = await prisma.domain.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends DomainUpdateManyArgs>(args: SelectSubset<T, DomainUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Domains and returns the data updated in the database.
     * @param {DomainUpdateManyAndReturnArgs} args - Arguments to update many Domains.
     * @example
     * // Update many Domains
     * const domain = await prisma.domain.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Domains and only return the `id`
     * const domainWithIdOnly = await prisma.domain.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends DomainUpdateManyAndReturnArgs>(args: SelectSubset<T, DomainUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DomainPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Domain.
     * @param {DomainUpsertArgs} args - Arguments to update or create a Domain.
     * @example
     * // Update or create a Domain
     * const domain = await prisma.domain.upsert({
     *   create: {
     *     // ... data to create a Domain
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Domain we want to update
     *   }
     * })
     */
    upsert<T extends DomainUpsertArgs>(args: SelectSubset<T, DomainUpsertArgs<ExtArgs>>): Prisma__DomainClient<$Result.GetResult<Prisma.$DomainPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Domains.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DomainCountArgs} args - Arguments to filter Domains to count.
     * @example
     * // Count the number of Domains
     * const count = await prisma.domain.count({
     *   where: {
     *     // ... the filter for the Domains we want to count
     *   }
     * })
    **/
    count<T extends DomainCountArgs>(
      args?: Subset<T, DomainCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], DomainCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Domain.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DomainAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends DomainAggregateArgs>(args: Subset<T, DomainAggregateArgs>): Prisma.PrismaPromise<GetDomainAggregateType<T>>

    /**
     * Group by Domain.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DomainGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends DomainGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: DomainGroupByArgs['orderBy'] }
        : { orderBy?: DomainGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, DomainGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetDomainGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Domain model
   */
  readonly fields: DomainFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Domain.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__DomainClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Domain model
   */
  interface DomainFieldRefs {
    readonly id: FieldRef<"Domain", 'String'>
    readonly name: FieldRef<"Domain", 'String'>
    readonly cloudflareId: FieldRef<"Domain", 'String'>
    readonly status: FieldRef<"Domain", 'String'>
    readonly nameservers: FieldRef<"Domain", 'String'>
    readonly created: FieldRef<"Domain", 'DateTime'>
    readonly expires: FieldRef<"Domain", 'DateTime'>
    readonly sslStatus: FieldRef<"Domain", 'String'>
    readonly dnsRecords: FieldRef<"Domain", 'Int'>
    readonly raw: FieldRef<"Domain", 'String'>
    readonly createdAt: FieldRef<"Domain", 'DateTime'>
    readonly updatedAt: FieldRef<"Domain", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Domain findUnique
   */
  export type DomainFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Domain
     */
    select?: DomainSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Domain
     */
    omit?: DomainOmit<ExtArgs> | null
    /**
     * Filter, which Domain to fetch.
     */
    where: DomainWhereUniqueInput
  }

  /**
   * Domain findUniqueOrThrow
   */
  export type DomainFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Domain
     */
    select?: DomainSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Domain
     */
    omit?: DomainOmit<ExtArgs> | null
    /**
     * Filter, which Domain to fetch.
     */
    where: DomainWhereUniqueInput
  }

  /**
   * Domain findFirst
   */
  export type DomainFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Domain
     */
    select?: DomainSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Domain
     */
    omit?: DomainOmit<ExtArgs> | null
    /**
     * Filter, which Domain to fetch.
     */
    where?: DomainWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Domains to fetch.
     */
    orderBy?: DomainOrderByWithRelationInput | DomainOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Domains.
     */
    cursor?: DomainWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Domains from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Domains.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Domains.
     */
    distinct?: DomainScalarFieldEnum | DomainScalarFieldEnum[]
  }

  /**
   * Domain findFirstOrThrow
   */
  export type DomainFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Domain
     */
    select?: DomainSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Domain
     */
    omit?: DomainOmit<ExtArgs> | null
    /**
     * Filter, which Domain to fetch.
     */
    where?: DomainWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Domains to fetch.
     */
    orderBy?: DomainOrderByWithRelationInput | DomainOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Domains.
     */
    cursor?: DomainWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Domains from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Domains.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Domains.
     */
    distinct?: DomainScalarFieldEnum | DomainScalarFieldEnum[]
  }

  /**
   * Domain findMany
   */
  export type DomainFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Domain
     */
    select?: DomainSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Domain
     */
    omit?: DomainOmit<ExtArgs> | null
    /**
     * Filter, which Domains to fetch.
     */
    where?: DomainWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Domains to fetch.
     */
    orderBy?: DomainOrderByWithRelationInput | DomainOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Domains.
     */
    cursor?: DomainWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Domains from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Domains.
     */
    skip?: number
    distinct?: DomainScalarFieldEnum | DomainScalarFieldEnum[]
  }

  /**
   * Domain create
   */
  export type DomainCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Domain
     */
    select?: DomainSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Domain
     */
    omit?: DomainOmit<ExtArgs> | null
    /**
     * The data needed to create a Domain.
     */
    data: XOR<DomainCreateInput, DomainUncheckedCreateInput>
  }

  /**
   * Domain createMany
   */
  export type DomainCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Domains.
     */
    data: DomainCreateManyInput | DomainCreateManyInput[]
  }

  /**
   * Domain createManyAndReturn
   */
  export type DomainCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Domain
     */
    select?: DomainSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Domain
     */
    omit?: DomainOmit<ExtArgs> | null
    /**
     * The data used to create many Domains.
     */
    data: DomainCreateManyInput | DomainCreateManyInput[]
  }

  /**
   * Domain update
   */
  export type DomainUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Domain
     */
    select?: DomainSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Domain
     */
    omit?: DomainOmit<ExtArgs> | null
    /**
     * The data needed to update a Domain.
     */
    data: XOR<DomainUpdateInput, DomainUncheckedUpdateInput>
    /**
     * Choose, which Domain to update.
     */
    where: DomainWhereUniqueInput
  }

  /**
   * Domain updateMany
   */
  export type DomainUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Domains.
     */
    data: XOR<DomainUpdateManyMutationInput, DomainUncheckedUpdateManyInput>
    /**
     * Filter which Domains to update
     */
    where?: DomainWhereInput
    /**
     * Limit how many Domains to update.
     */
    limit?: number
  }

  /**
   * Domain updateManyAndReturn
   */
  export type DomainUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Domain
     */
    select?: DomainSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Domain
     */
    omit?: DomainOmit<ExtArgs> | null
    /**
     * The data used to update Domains.
     */
    data: XOR<DomainUpdateManyMutationInput, DomainUncheckedUpdateManyInput>
    /**
     * Filter which Domains to update
     */
    where?: DomainWhereInput
    /**
     * Limit how many Domains to update.
     */
    limit?: number
  }

  /**
   * Domain upsert
   */
  export type DomainUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Domain
     */
    select?: DomainSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Domain
     */
    omit?: DomainOmit<ExtArgs> | null
    /**
     * The filter to search for the Domain to update in case it exists.
     */
    where: DomainWhereUniqueInput
    /**
     * In case the Domain found by the `where` argument doesn't exist, create a new Domain with this data.
     */
    create: XOR<DomainCreateInput, DomainUncheckedCreateInput>
    /**
     * In case the Domain was found with the provided `where` argument, update it with this data.
     */
    update: XOR<DomainUpdateInput, DomainUncheckedUpdateInput>
  }

  /**
   * Domain delete
   */
  export type DomainDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Domain
     */
    select?: DomainSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Domain
     */
    omit?: DomainOmit<ExtArgs> | null
    /**
     * Filter which Domain to delete.
     */
    where: DomainWhereUniqueInput
  }

  /**
   * Domain deleteMany
   */
  export type DomainDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Domains to delete
     */
    where?: DomainWhereInput
    /**
     * Limit how many Domains to delete.
     */
    limit?: number
  }

  /**
   * Domain without action
   */
  export type DomainDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Domain
     */
    select?: DomainSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Domain
     */
    omit?: DomainOmit<ExtArgs> | null
  }


  /**
   * Model ProxmoxServer
   */

  export type AggregateProxmoxServer = {
    _count: ProxmoxServerCountAggregateOutputType | null
    _min: ProxmoxServerMinAggregateOutputType | null
    _max: ProxmoxServerMaxAggregateOutputType | null
  }

  export type ProxmoxServerMinAggregateOutputType = {
    id: string | null
    name: string | null
    baseUrl: string | null
    user: string | null
    tokenId: string | null
    tokenSecret: string | null
    insecure: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ProxmoxServerMaxAggregateOutputType = {
    id: string | null
    name: string | null
    baseUrl: string | null
    user: string | null
    tokenId: string | null
    tokenSecret: string | null
    insecure: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ProxmoxServerCountAggregateOutputType = {
    id: number
    name: number
    baseUrl: number
    user: number
    tokenId: number
    tokenSecret: number
    insecure: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type ProxmoxServerMinAggregateInputType = {
    id?: true
    name?: true
    baseUrl?: true
    user?: true
    tokenId?: true
    tokenSecret?: true
    insecure?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ProxmoxServerMaxAggregateInputType = {
    id?: true
    name?: true
    baseUrl?: true
    user?: true
    tokenId?: true
    tokenSecret?: true
    insecure?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ProxmoxServerCountAggregateInputType = {
    id?: true
    name?: true
    baseUrl?: true
    user?: true
    tokenId?: true
    tokenSecret?: true
    insecure?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type ProxmoxServerAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ProxmoxServer to aggregate.
     */
    where?: ProxmoxServerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProxmoxServers to fetch.
     */
    orderBy?: ProxmoxServerOrderByWithRelationInput | ProxmoxServerOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ProxmoxServerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProxmoxServers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProxmoxServers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ProxmoxServers
    **/
    _count?: true | ProxmoxServerCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ProxmoxServerMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ProxmoxServerMaxAggregateInputType
  }

  export type GetProxmoxServerAggregateType<T extends ProxmoxServerAggregateArgs> = {
        [P in keyof T & keyof AggregateProxmoxServer]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateProxmoxServer[P]>
      : GetScalarType<T[P], AggregateProxmoxServer[P]>
  }




  export type ProxmoxServerGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ProxmoxServerWhereInput
    orderBy?: ProxmoxServerOrderByWithAggregationInput | ProxmoxServerOrderByWithAggregationInput[]
    by: ProxmoxServerScalarFieldEnum[] | ProxmoxServerScalarFieldEnum
    having?: ProxmoxServerScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ProxmoxServerCountAggregateInputType | true
    _min?: ProxmoxServerMinAggregateInputType
    _max?: ProxmoxServerMaxAggregateInputType
  }

  export type ProxmoxServerGroupByOutputType = {
    id: string
    name: string
    baseUrl: string
    user: string
    tokenId: string
    tokenSecret: string
    insecure: boolean
    createdAt: Date
    updatedAt: Date
    _count: ProxmoxServerCountAggregateOutputType | null
    _min: ProxmoxServerMinAggregateOutputType | null
    _max: ProxmoxServerMaxAggregateOutputType | null
  }

  type GetProxmoxServerGroupByPayload<T extends ProxmoxServerGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ProxmoxServerGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ProxmoxServerGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ProxmoxServerGroupByOutputType[P]>
            : GetScalarType<T[P], ProxmoxServerGroupByOutputType[P]>
        }
      >
    >


  export type ProxmoxServerSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    baseUrl?: boolean
    user?: boolean
    tokenId?: boolean
    tokenSecret?: boolean
    insecure?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    nodes?: boolean | ProxmoxServer$nodesArgs<ExtArgs>
    vms?: boolean | ProxmoxServer$vmsArgs<ExtArgs>
    _count?: boolean | ProxmoxServerCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["proxmoxServer"]>

  export type ProxmoxServerSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    baseUrl?: boolean
    user?: boolean
    tokenId?: boolean
    tokenSecret?: boolean
    insecure?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["proxmoxServer"]>

  export type ProxmoxServerSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    baseUrl?: boolean
    user?: boolean
    tokenId?: boolean
    tokenSecret?: boolean
    insecure?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["proxmoxServer"]>

  export type ProxmoxServerSelectScalar = {
    id?: boolean
    name?: boolean
    baseUrl?: boolean
    user?: boolean
    tokenId?: boolean
    tokenSecret?: boolean
    insecure?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type ProxmoxServerOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "baseUrl" | "user" | "tokenId" | "tokenSecret" | "insecure" | "createdAt" | "updatedAt", ExtArgs["result"]["proxmoxServer"]>
  export type ProxmoxServerInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    nodes?: boolean | ProxmoxServer$nodesArgs<ExtArgs>
    vms?: boolean | ProxmoxServer$vmsArgs<ExtArgs>
    _count?: boolean | ProxmoxServerCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type ProxmoxServerIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type ProxmoxServerIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $ProxmoxServerPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ProxmoxServer"
    objects: {
      nodes: Prisma.$ProxmoxNodePayload<ExtArgs>[]
      vms: Prisma.$ProxmoxVMPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      baseUrl: string
      user: string
      tokenId: string
      tokenSecret: string
      insecure: boolean
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["proxmoxServer"]>
    composites: {}
  }

  type ProxmoxServerGetPayload<S extends boolean | null | undefined | ProxmoxServerDefaultArgs> = $Result.GetResult<Prisma.$ProxmoxServerPayload, S>

  type ProxmoxServerCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ProxmoxServerFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ProxmoxServerCountAggregateInputType | true
    }

  export interface ProxmoxServerDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ProxmoxServer'], meta: { name: 'ProxmoxServer' } }
    /**
     * Find zero or one ProxmoxServer that matches the filter.
     * @param {ProxmoxServerFindUniqueArgs} args - Arguments to find a ProxmoxServer
     * @example
     * // Get one ProxmoxServer
     * const proxmoxServer = await prisma.proxmoxServer.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ProxmoxServerFindUniqueArgs>(args: SelectSubset<T, ProxmoxServerFindUniqueArgs<ExtArgs>>): Prisma__ProxmoxServerClient<$Result.GetResult<Prisma.$ProxmoxServerPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one ProxmoxServer that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ProxmoxServerFindUniqueOrThrowArgs} args - Arguments to find a ProxmoxServer
     * @example
     * // Get one ProxmoxServer
     * const proxmoxServer = await prisma.proxmoxServer.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ProxmoxServerFindUniqueOrThrowArgs>(args: SelectSubset<T, ProxmoxServerFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ProxmoxServerClient<$Result.GetResult<Prisma.$ProxmoxServerPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ProxmoxServer that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProxmoxServerFindFirstArgs} args - Arguments to find a ProxmoxServer
     * @example
     * // Get one ProxmoxServer
     * const proxmoxServer = await prisma.proxmoxServer.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ProxmoxServerFindFirstArgs>(args?: SelectSubset<T, ProxmoxServerFindFirstArgs<ExtArgs>>): Prisma__ProxmoxServerClient<$Result.GetResult<Prisma.$ProxmoxServerPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ProxmoxServer that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProxmoxServerFindFirstOrThrowArgs} args - Arguments to find a ProxmoxServer
     * @example
     * // Get one ProxmoxServer
     * const proxmoxServer = await prisma.proxmoxServer.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ProxmoxServerFindFirstOrThrowArgs>(args?: SelectSubset<T, ProxmoxServerFindFirstOrThrowArgs<ExtArgs>>): Prisma__ProxmoxServerClient<$Result.GetResult<Prisma.$ProxmoxServerPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more ProxmoxServers that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProxmoxServerFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ProxmoxServers
     * const proxmoxServers = await prisma.proxmoxServer.findMany()
     * 
     * // Get first 10 ProxmoxServers
     * const proxmoxServers = await prisma.proxmoxServer.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const proxmoxServerWithIdOnly = await prisma.proxmoxServer.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ProxmoxServerFindManyArgs>(args?: SelectSubset<T, ProxmoxServerFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProxmoxServerPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a ProxmoxServer.
     * @param {ProxmoxServerCreateArgs} args - Arguments to create a ProxmoxServer.
     * @example
     * // Create one ProxmoxServer
     * const ProxmoxServer = await prisma.proxmoxServer.create({
     *   data: {
     *     // ... data to create a ProxmoxServer
     *   }
     * })
     * 
     */
    create<T extends ProxmoxServerCreateArgs>(args: SelectSubset<T, ProxmoxServerCreateArgs<ExtArgs>>): Prisma__ProxmoxServerClient<$Result.GetResult<Prisma.$ProxmoxServerPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many ProxmoxServers.
     * @param {ProxmoxServerCreateManyArgs} args - Arguments to create many ProxmoxServers.
     * @example
     * // Create many ProxmoxServers
     * const proxmoxServer = await prisma.proxmoxServer.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ProxmoxServerCreateManyArgs>(args?: SelectSubset<T, ProxmoxServerCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many ProxmoxServers and returns the data saved in the database.
     * @param {ProxmoxServerCreateManyAndReturnArgs} args - Arguments to create many ProxmoxServers.
     * @example
     * // Create many ProxmoxServers
     * const proxmoxServer = await prisma.proxmoxServer.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many ProxmoxServers and only return the `id`
     * const proxmoxServerWithIdOnly = await prisma.proxmoxServer.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ProxmoxServerCreateManyAndReturnArgs>(args?: SelectSubset<T, ProxmoxServerCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProxmoxServerPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a ProxmoxServer.
     * @param {ProxmoxServerDeleteArgs} args - Arguments to delete one ProxmoxServer.
     * @example
     * // Delete one ProxmoxServer
     * const ProxmoxServer = await prisma.proxmoxServer.delete({
     *   where: {
     *     // ... filter to delete one ProxmoxServer
     *   }
     * })
     * 
     */
    delete<T extends ProxmoxServerDeleteArgs>(args: SelectSubset<T, ProxmoxServerDeleteArgs<ExtArgs>>): Prisma__ProxmoxServerClient<$Result.GetResult<Prisma.$ProxmoxServerPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one ProxmoxServer.
     * @param {ProxmoxServerUpdateArgs} args - Arguments to update one ProxmoxServer.
     * @example
     * // Update one ProxmoxServer
     * const proxmoxServer = await prisma.proxmoxServer.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ProxmoxServerUpdateArgs>(args: SelectSubset<T, ProxmoxServerUpdateArgs<ExtArgs>>): Prisma__ProxmoxServerClient<$Result.GetResult<Prisma.$ProxmoxServerPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more ProxmoxServers.
     * @param {ProxmoxServerDeleteManyArgs} args - Arguments to filter ProxmoxServers to delete.
     * @example
     * // Delete a few ProxmoxServers
     * const { count } = await prisma.proxmoxServer.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ProxmoxServerDeleteManyArgs>(args?: SelectSubset<T, ProxmoxServerDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ProxmoxServers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProxmoxServerUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ProxmoxServers
     * const proxmoxServer = await prisma.proxmoxServer.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ProxmoxServerUpdateManyArgs>(args: SelectSubset<T, ProxmoxServerUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ProxmoxServers and returns the data updated in the database.
     * @param {ProxmoxServerUpdateManyAndReturnArgs} args - Arguments to update many ProxmoxServers.
     * @example
     * // Update many ProxmoxServers
     * const proxmoxServer = await prisma.proxmoxServer.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more ProxmoxServers and only return the `id`
     * const proxmoxServerWithIdOnly = await prisma.proxmoxServer.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ProxmoxServerUpdateManyAndReturnArgs>(args: SelectSubset<T, ProxmoxServerUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProxmoxServerPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one ProxmoxServer.
     * @param {ProxmoxServerUpsertArgs} args - Arguments to update or create a ProxmoxServer.
     * @example
     * // Update or create a ProxmoxServer
     * const proxmoxServer = await prisma.proxmoxServer.upsert({
     *   create: {
     *     // ... data to create a ProxmoxServer
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ProxmoxServer we want to update
     *   }
     * })
     */
    upsert<T extends ProxmoxServerUpsertArgs>(args: SelectSubset<T, ProxmoxServerUpsertArgs<ExtArgs>>): Prisma__ProxmoxServerClient<$Result.GetResult<Prisma.$ProxmoxServerPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of ProxmoxServers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProxmoxServerCountArgs} args - Arguments to filter ProxmoxServers to count.
     * @example
     * // Count the number of ProxmoxServers
     * const count = await prisma.proxmoxServer.count({
     *   where: {
     *     // ... the filter for the ProxmoxServers we want to count
     *   }
     * })
    **/
    count<T extends ProxmoxServerCountArgs>(
      args?: Subset<T, ProxmoxServerCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ProxmoxServerCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ProxmoxServer.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProxmoxServerAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ProxmoxServerAggregateArgs>(args: Subset<T, ProxmoxServerAggregateArgs>): Prisma.PrismaPromise<GetProxmoxServerAggregateType<T>>

    /**
     * Group by ProxmoxServer.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProxmoxServerGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ProxmoxServerGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ProxmoxServerGroupByArgs['orderBy'] }
        : { orderBy?: ProxmoxServerGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ProxmoxServerGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetProxmoxServerGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ProxmoxServer model
   */
  readonly fields: ProxmoxServerFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ProxmoxServer.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ProxmoxServerClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    nodes<T extends ProxmoxServer$nodesArgs<ExtArgs> = {}>(args?: Subset<T, ProxmoxServer$nodesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProxmoxNodePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    vms<T extends ProxmoxServer$vmsArgs<ExtArgs> = {}>(args?: Subset<T, ProxmoxServer$vmsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProxmoxVMPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ProxmoxServer model
   */
  interface ProxmoxServerFieldRefs {
    readonly id: FieldRef<"ProxmoxServer", 'String'>
    readonly name: FieldRef<"ProxmoxServer", 'String'>
    readonly baseUrl: FieldRef<"ProxmoxServer", 'String'>
    readonly user: FieldRef<"ProxmoxServer", 'String'>
    readonly tokenId: FieldRef<"ProxmoxServer", 'String'>
    readonly tokenSecret: FieldRef<"ProxmoxServer", 'String'>
    readonly insecure: FieldRef<"ProxmoxServer", 'Boolean'>
    readonly createdAt: FieldRef<"ProxmoxServer", 'DateTime'>
    readonly updatedAt: FieldRef<"ProxmoxServer", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * ProxmoxServer findUnique
   */
  export type ProxmoxServerFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProxmoxServer
     */
    select?: ProxmoxServerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProxmoxServer
     */
    omit?: ProxmoxServerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProxmoxServerInclude<ExtArgs> | null
    /**
     * Filter, which ProxmoxServer to fetch.
     */
    where: ProxmoxServerWhereUniqueInput
  }

  /**
   * ProxmoxServer findUniqueOrThrow
   */
  export type ProxmoxServerFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProxmoxServer
     */
    select?: ProxmoxServerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProxmoxServer
     */
    omit?: ProxmoxServerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProxmoxServerInclude<ExtArgs> | null
    /**
     * Filter, which ProxmoxServer to fetch.
     */
    where: ProxmoxServerWhereUniqueInput
  }

  /**
   * ProxmoxServer findFirst
   */
  export type ProxmoxServerFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProxmoxServer
     */
    select?: ProxmoxServerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProxmoxServer
     */
    omit?: ProxmoxServerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProxmoxServerInclude<ExtArgs> | null
    /**
     * Filter, which ProxmoxServer to fetch.
     */
    where?: ProxmoxServerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProxmoxServers to fetch.
     */
    orderBy?: ProxmoxServerOrderByWithRelationInput | ProxmoxServerOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ProxmoxServers.
     */
    cursor?: ProxmoxServerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProxmoxServers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProxmoxServers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ProxmoxServers.
     */
    distinct?: ProxmoxServerScalarFieldEnum | ProxmoxServerScalarFieldEnum[]
  }

  /**
   * ProxmoxServer findFirstOrThrow
   */
  export type ProxmoxServerFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProxmoxServer
     */
    select?: ProxmoxServerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProxmoxServer
     */
    omit?: ProxmoxServerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProxmoxServerInclude<ExtArgs> | null
    /**
     * Filter, which ProxmoxServer to fetch.
     */
    where?: ProxmoxServerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProxmoxServers to fetch.
     */
    orderBy?: ProxmoxServerOrderByWithRelationInput | ProxmoxServerOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ProxmoxServers.
     */
    cursor?: ProxmoxServerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProxmoxServers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProxmoxServers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ProxmoxServers.
     */
    distinct?: ProxmoxServerScalarFieldEnum | ProxmoxServerScalarFieldEnum[]
  }

  /**
   * ProxmoxServer findMany
   */
  export type ProxmoxServerFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProxmoxServer
     */
    select?: ProxmoxServerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProxmoxServer
     */
    omit?: ProxmoxServerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProxmoxServerInclude<ExtArgs> | null
    /**
     * Filter, which ProxmoxServers to fetch.
     */
    where?: ProxmoxServerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProxmoxServers to fetch.
     */
    orderBy?: ProxmoxServerOrderByWithRelationInput | ProxmoxServerOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ProxmoxServers.
     */
    cursor?: ProxmoxServerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProxmoxServers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProxmoxServers.
     */
    skip?: number
    distinct?: ProxmoxServerScalarFieldEnum | ProxmoxServerScalarFieldEnum[]
  }

  /**
   * ProxmoxServer create
   */
  export type ProxmoxServerCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProxmoxServer
     */
    select?: ProxmoxServerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProxmoxServer
     */
    omit?: ProxmoxServerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProxmoxServerInclude<ExtArgs> | null
    /**
     * The data needed to create a ProxmoxServer.
     */
    data: XOR<ProxmoxServerCreateInput, ProxmoxServerUncheckedCreateInput>
  }

  /**
   * ProxmoxServer createMany
   */
  export type ProxmoxServerCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ProxmoxServers.
     */
    data: ProxmoxServerCreateManyInput | ProxmoxServerCreateManyInput[]
  }

  /**
   * ProxmoxServer createManyAndReturn
   */
  export type ProxmoxServerCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProxmoxServer
     */
    select?: ProxmoxServerSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ProxmoxServer
     */
    omit?: ProxmoxServerOmit<ExtArgs> | null
    /**
     * The data used to create many ProxmoxServers.
     */
    data: ProxmoxServerCreateManyInput | ProxmoxServerCreateManyInput[]
  }

  /**
   * ProxmoxServer update
   */
  export type ProxmoxServerUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProxmoxServer
     */
    select?: ProxmoxServerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProxmoxServer
     */
    omit?: ProxmoxServerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProxmoxServerInclude<ExtArgs> | null
    /**
     * The data needed to update a ProxmoxServer.
     */
    data: XOR<ProxmoxServerUpdateInput, ProxmoxServerUncheckedUpdateInput>
    /**
     * Choose, which ProxmoxServer to update.
     */
    where: ProxmoxServerWhereUniqueInput
  }

  /**
   * ProxmoxServer updateMany
   */
  export type ProxmoxServerUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ProxmoxServers.
     */
    data: XOR<ProxmoxServerUpdateManyMutationInput, ProxmoxServerUncheckedUpdateManyInput>
    /**
     * Filter which ProxmoxServers to update
     */
    where?: ProxmoxServerWhereInput
    /**
     * Limit how many ProxmoxServers to update.
     */
    limit?: number
  }

  /**
   * ProxmoxServer updateManyAndReturn
   */
  export type ProxmoxServerUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProxmoxServer
     */
    select?: ProxmoxServerSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ProxmoxServer
     */
    omit?: ProxmoxServerOmit<ExtArgs> | null
    /**
     * The data used to update ProxmoxServers.
     */
    data: XOR<ProxmoxServerUpdateManyMutationInput, ProxmoxServerUncheckedUpdateManyInput>
    /**
     * Filter which ProxmoxServers to update
     */
    where?: ProxmoxServerWhereInput
    /**
     * Limit how many ProxmoxServers to update.
     */
    limit?: number
  }

  /**
   * ProxmoxServer upsert
   */
  export type ProxmoxServerUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProxmoxServer
     */
    select?: ProxmoxServerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProxmoxServer
     */
    omit?: ProxmoxServerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProxmoxServerInclude<ExtArgs> | null
    /**
     * The filter to search for the ProxmoxServer to update in case it exists.
     */
    where: ProxmoxServerWhereUniqueInput
    /**
     * In case the ProxmoxServer found by the `where` argument doesn't exist, create a new ProxmoxServer with this data.
     */
    create: XOR<ProxmoxServerCreateInput, ProxmoxServerUncheckedCreateInput>
    /**
     * In case the ProxmoxServer was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ProxmoxServerUpdateInput, ProxmoxServerUncheckedUpdateInput>
  }

  /**
   * ProxmoxServer delete
   */
  export type ProxmoxServerDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProxmoxServer
     */
    select?: ProxmoxServerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProxmoxServer
     */
    omit?: ProxmoxServerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProxmoxServerInclude<ExtArgs> | null
    /**
     * Filter which ProxmoxServer to delete.
     */
    where: ProxmoxServerWhereUniqueInput
  }

  /**
   * ProxmoxServer deleteMany
   */
  export type ProxmoxServerDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ProxmoxServers to delete
     */
    where?: ProxmoxServerWhereInput
    /**
     * Limit how many ProxmoxServers to delete.
     */
    limit?: number
  }

  /**
   * ProxmoxServer.nodes
   */
  export type ProxmoxServer$nodesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProxmoxNode
     */
    select?: ProxmoxNodeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProxmoxNode
     */
    omit?: ProxmoxNodeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProxmoxNodeInclude<ExtArgs> | null
    where?: ProxmoxNodeWhereInput
    orderBy?: ProxmoxNodeOrderByWithRelationInput | ProxmoxNodeOrderByWithRelationInput[]
    cursor?: ProxmoxNodeWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ProxmoxNodeScalarFieldEnum | ProxmoxNodeScalarFieldEnum[]
  }

  /**
   * ProxmoxServer.vms
   */
  export type ProxmoxServer$vmsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProxmoxVM
     */
    select?: ProxmoxVMSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProxmoxVM
     */
    omit?: ProxmoxVMOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProxmoxVMInclude<ExtArgs> | null
    where?: ProxmoxVMWhereInput
    orderBy?: ProxmoxVMOrderByWithRelationInput | ProxmoxVMOrderByWithRelationInput[]
    cursor?: ProxmoxVMWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ProxmoxVMScalarFieldEnum | ProxmoxVMScalarFieldEnum[]
  }

  /**
   * ProxmoxServer without action
   */
  export type ProxmoxServerDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProxmoxServer
     */
    select?: ProxmoxServerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProxmoxServer
     */
    omit?: ProxmoxServerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProxmoxServerInclude<ExtArgs> | null
  }


  /**
   * Model ProxmoxNode
   */

  export type AggregateProxmoxNode = {
    _count: ProxmoxNodeCountAggregateOutputType | null
    _avg: ProxmoxNodeAvgAggregateOutputType | null
    _sum: ProxmoxNodeSumAggregateOutputType | null
    _min: ProxmoxNodeMinAggregateOutputType | null
    _max: ProxmoxNodeMaxAggregateOutputType | null
  }

  export type ProxmoxNodeAvgAggregateOutputType = {
    maxcpu: number | null
    maxmem: number | null
    cpu: number | null
    mem: number | null
    uptime: number | null
  }

  export type ProxmoxNodeSumAggregateOutputType = {
    maxcpu: number | null
    maxmem: bigint | null
    cpu: number | null
    mem: bigint | null
    uptime: number | null
  }

  export type ProxmoxNodeMinAggregateOutputType = {
    id: string | null
    name: string | null
    status: string | null
    maxcpu: number | null
    maxmem: bigint | null
    cpu: number | null
    mem: bigint | null
    uptime: number | null
    raw: string | null
    createdAt: Date | null
    updatedAt: Date | null
    serverId: string | null
  }

  export type ProxmoxNodeMaxAggregateOutputType = {
    id: string | null
    name: string | null
    status: string | null
    maxcpu: number | null
    maxmem: bigint | null
    cpu: number | null
    mem: bigint | null
    uptime: number | null
    raw: string | null
    createdAt: Date | null
    updatedAt: Date | null
    serverId: string | null
  }

  export type ProxmoxNodeCountAggregateOutputType = {
    id: number
    name: number
    status: number
    maxcpu: number
    maxmem: number
    cpu: number
    mem: number
    uptime: number
    raw: number
    createdAt: number
    updatedAt: number
    serverId: number
    _all: number
  }


  export type ProxmoxNodeAvgAggregateInputType = {
    maxcpu?: true
    maxmem?: true
    cpu?: true
    mem?: true
    uptime?: true
  }

  export type ProxmoxNodeSumAggregateInputType = {
    maxcpu?: true
    maxmem?: true
    cpu?: true
    mem?: true
    uptime?: true
  }

  export type ProxmoxNodeMinAggregateInputType = {
    id?: true
    name?: true
    status?: true
    maxcpu?: true
    maxmem?: true
    cpu?: true
    mem?: true
    uptime?: true
    raw?: true
    createdAt?: true
    updatedAt?: true
    serverId?: true
  }

  export type ProxmoxNodeMaxAggregateInputType = {
    id?: true
    name?: true
    status?: true
    maxcpu?: true
    maxmem?: true
    cpu?: true
    mem?: true
    uptime?: true
    raw?: true
    createdAt?: true
    updatedAt?: true
    serverId?: true
  }

  export type ProxmoxNodeCountAggregateInputType = {
    id?: true
    name?: true
    status?: true
    maxcpu?: true
    maxmem?: true
    cpu?: true
    mem?: true
    uptime?: true
    raw?: true
    createdAt?: true
    updatedAt?: true
    serverId?: true
    _all?: true
  }

  export type ProxmoxNodeAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ProxmoxNode to aggregate.
     */
    where?: ProxmoxNodeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProxmoxNodes to fetch.
     */
    orderBy?: ProxmoxNodeOrderByWithRelationInput | ProxmoxNodeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ProxmoxNodeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProxmoxNodes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProxmoxNodes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ProxmoxNodes
    **/
    _count?: true | ProxmoxNodeCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ProxmoxNodeAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ProxmoxNodeSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ProxmoxNodeMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ProxmoxNodeMaxAggregateInputType
  }

  export type GetProxmoxNodeAggregateType<T extends ProxmoxNodeAggregateArgs> = {
        [P in keyof T & keyof AggregateProxmoxNode]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateProxmoxNode[P]>
      : GetScalarType<T[P], AggregateProxmoxNode[P]>
  }




  export type ProxmoxNodeGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ProxmoxNodeWhereInput
    orderBy?: ProxmoxNodeOrderByWithAggregationInput | ProxmoxNodeOrderByWithAggregationInput[]
    by: ProxmoxNodeScalarFieldEnum[] | ProxmoxNodeScalarFieldEnum
    having?: ProxmoxNodeScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ProxmoxNodeCountAggregateInputType | true
    _avg?: ProxmoxNodeAvgAggregateInputType
    _sum?: ProxmoxNodeSumAggregateInputType
    _min?: ProxmoxNodeMinAggregateInputType
    _max?: ProxmoxNodeMaxAggregateInputType
  }

  export type ProxmoxNodeGroupByOutputType = {
    id: string
    name: string
    status: string | null
    maxcpu: number | null
    maxmem: bigint | null
    cpu: number | null
    mem: bigint | null
    uptime: number | null
    raw: string | null
    createdAt: Date
    updatedAt: Date
    serverId: string | null
    _count: ProxmoxNodeCountAggregateOutputType | null
    _avg: ProxmoxNodeAvgAggregateOutputType | null
    _sum: ProxmoxNodeSumAggregateOutputType | null
    _min: ProxmoxNodeMinAggregateOutputType | null
    _max: ProxmoxNodeMaxAggregateOutputType | null
  }

  type GetProxmoxNodeGroupByPayload<T extends ProxmoxNodeGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ProxmoxNodeGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ProxmoxNodeGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ProxmoxNodeGroupByOutputType[P]>
            : GetScalarType<T[P], ProxmoxNodeGroupByOutputType[P]>
        }
      >
    >


  export type ProxmoxNodeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    status?: boolean
    maxcpu?: boolean
    maxmem?: boolean
    cpu?: boolean
    mem?: boolean
    uptime?: boolean
    raw?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    serverId?: boolean
    vms?: boolean | ProxmoxNode$vmsArgs<ExtArgs>
    server?: boolean | ProxmoxNode$serverArgs<ExtArgs>
    _count?: boolean | ProxmoxNodeCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["proxmoxNode"]>

  export type ProxmoxNodeSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    status?: boolean
    maxcpu?: boolean
    maxmem?: boolean
    cpu?: boolean
    mem?: boolean
    uptime?: boolean
    raw?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    serverId?: boolean
    server?: boolean | ProxmoxNode$serverArgs<ExtArgs>
  }, ExtArgs["result"]["proxmoxNode"]>

  export type ProxmoxNodeSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    status?: boolean
    maxcpu?: boolean
    maxmem?: boolean
    cpu?: boolean
    mem?: boolean
    uptime?: boolean
    raw?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    serverId?: boolean
    server?: boolean | ProxmoxNode$serverArgs<ExtArgs>
  }, ExtArgs["result"]["proxmoxNode"]>

  export type ProxmoxNodeSelectScalar = {
    id?: boolean
    name?: boolean
    status?: boolean
    maxcpu?: boolean
    maxmem?: boolean
    cpu?: boolean
    mem?: boolean
    uptime?: boolean
    raw?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    serverId?: boolean
  }

  export type ProxmoxNodeOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "status" | "maxcpu" | "maxmem" | "cpu" | "mem" | "uptime" | "raw" | "createdAt" | "updatedAt" | "serverId", ExtArgs["result"]["proxmoxNode"]>
  export type ProxmoxNodeInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    vms?: boolean | ProxmoxNode$vmsArgs<ExtArgs>
    server?: boolean | ProxmoxNode$serverArgs<ExtArgs>
    _count?: boolean | ProxmoxNodeCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type ProxmoxNodeIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    server?: boolean | ProxmoxNode$serverArgs<ExtArgs>
  }
  export type ProxmoxNodeIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    server?: boolean | ProxmoxNode$serverArgs<ExtArgs>
  }

  export type $ProxmoxNodePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ProxmoxNode"
    objects: {
      vms: Prisma.$ProxmoxVMPayload<ExtArgs>[]
      server: Prisma.$ProxmoxServerPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      status: string | null
      maxcpu: number | null
      maxmem: bigint | null
      cpu: number | null
      mem: bigint | null
      uptime: number | null
      raw: string | null
      createdAt: Date
      updatedAt: Date
      serverId: string | null
    }, ExtArgs["result"]["proxmoxNode"]>
    composites: {}
  }

  type ProxmoxNodeGetPayload<S extends boolean | null | undefined | ProxmoxNodeDefaultArgs> = $Result.GetResult<Prisma.$ProxmoxNodePayload, S>

  type ProxmoxNodeCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ProxmoxNodeFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ProxmoxNodeCountAggregateInputType | true
    }

  export interface ProxmoxNodeDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ProxmoxNode'], meta: { name: 'ProxmoxNode' } }
    /**
     * Find zero or one ProxmoxNode that matches the filter.
     * @param {ProxmoxNodeFindUniqueArgs} args - Arguments to find a ProxmoxNode
     * @example
     * // Get one ProxmoxNode
     * const proxmoxNode = await prisma.proxmoxNode.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ProxmoxNodeFindUniqueArgs>(args: SelectSubset<T, ProxmoxNodeFindUniqueArgs<ExtArgs>>): Prisma__ProxmoxNodeClient<$Result.GetResult<Prisma.$ProxmoxNodePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one ProxmoxNode that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ProxmoxNodeFindUniqueOrThrowArgs} args - Arguments to find a ProxmoxNode
     * @example
     * // Get one ProxmoxNode
     * const proxmoxNode = await prisma.proxmoxNode.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ProxmoxNodeFindUniqueOrThrowArgs>(args: SelectSubset<T, ProxmoxNodeFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ProxmoxNodeClient<$Result.GetResult<Prisma.$ProxmoxNodePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ProxmoxNode that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProxmoxNodeFindFirstArgs} args - Arguments to find a ProxmoxNode
     * @example
     * // Get one ProxmoxNode
     * const proxmoxNode = await prisma.proxmoxNode.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ProxmoxNodeFindFirstArgs>(args?: SelectSubset<T, ProxmoxNodeFindFirstArgs<ExtArgs>>): Prisma__ProxmoxNodeClient<$Result.GetResult<Prisma.$ProxmoxNodePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ProxmoxNode that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProxmoxNodeFindFirstOrThrowArgs} args - Arguments to find a ProxmoxNode
     * @example
     * // Get one ProxmoxNode
     * const proxmoxNode = await prisma.proxmoxNode.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ProxmoxNodeFindFirstOrThrowArgs>(args?: SelectSubset<T, ProxmoxNodeFindFirstOrThrowArgs<ExtArgs>>): Prisma__ProxmoxNodeClient<$Result.GetResult<Prisma.$ProxmoxNodePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more ProxmoxNodes that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProxmoxNodeFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ProxmoxNodes
     * const proxmoxNodes = await prisma.proxmoxNode.findMany()
     * 
     * // Get first 10 ProxmoxNodes
     * const proxmoxNodes = await prisma.proxmoxNode.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const proxmoxNodeWithIdOnly = await prisma.proxmoxNode.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ProxmoxNodeFindManyArgs>(args?: SelectSubset<T, ProxmoxNodeFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProxmoxNodePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a ProxmoxNode.
     * @param {ProxmoxNodeCreateArgs} args - Arguments to create a ProxmoxNode.
     * @example
     * // Create one ProxmoxNode
     * const ProxmoxNode = await prisma.proxmoxNode.create({
     *   data: {
     *     // ... data to create a ProxmoxNode
     *   }
     * })
     * 
     */
    create<T extends ProxmoxNodeCreateArgs>(args: SelectSubset<T, ProxmoxNodeCreateArgs<ExtArgs>>): Prisma__ProxmoxNodeClient<$Result.GetResult<Prisma.$ProxmoxNodePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many ProxmoxNodes.
     * @param {ProxmoxNodeCreateManyArgs} args - Arguments to create many ProxmoxNodes.
     * @example
     * // Create many ProxmoxNodes
     * const proxmoxNode = await prisma.proxmoxNode.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ProxmoxNodeCreateManyArgs>(args?: SelectSubset<T, ProxmoxNodeCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many ProxmoxNodes and returns the data saved in the database.
     * @param {ProxmoxNodeCreateManyAndReturnArgs} args - Arguments to create many ProxmoxNodes.
     * @example
     * // Create many ProxmoxNodes
     * const proxmoxNode = await prisma.proxmoxNode.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many ProxmoxNodes and only return the `id`
     * const proxmoxNodeWithIdOnly = await prisma.proxmoxNode.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ProxmoxNodeCreateManyAndReturnArgs>(args?: SelectSubset<T, ProxmoxNodeCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProxmoxNodePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a ProxmoxNode.
     * @param {ProxmoxNodeDeleteArgs} args - Arguments to delete one ProxmoxNode.
     * @example
     * // Delete one ProxmoxNode
     * const ProxmoxNode = await prisma.proxmoxNode.delete({
     *   where: {
     *     // ... filter to delete one ProxmoxNode
     *   }
     * })
     * 
     */
    delete<T extends ProxmoxNodeDeleteArgs>(args: SelectSubset<T, ProxmoxNodeDeleteArgs<ExtArgs>>): Prisma__ProxmoxNodeClient<$Result.GetResult<Prisma.$ProxmoxNodePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one ProxmoxNode.
     * @param {ProxmoxNodeUpdateArgs} args - Arguments to update one ProxmoxNode.
     * @example
     * // Update one ProxmoxNode
     * const proxmoxNode = await prisma.proxmoxNode.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ProxmoxNodeUpdateArgs>(args: SelectSubset<T, ProxmoxNodeUpdateArgs<ExtArgs>>): Prisma__ProxmoxNodeClient<$Result.GetResult<Prisma.$ProxmoxNodePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more ProxmoxNodes.
     * @param {ProxmoxNodeDeleteManyArgs} args - Arguments to filter ProxmoxNodes to delete.
     * @example
     * // Delete a few ProxmoxNodes
     * const { count } = await prisma.proxmoxNode.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ProxmoxNodeDeleteManyArgs>(args?: SelectSubset<T, ProxmoxNodeDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ProxmoxNodes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProxmoxNodeUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ProxmoxNodes
     * const proxmoxNode = await prisma.proxmoxNode.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ProxmoxNodeUpdateManyArgs>(args: SelectSubset<T, ProxmoxNodeUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ProxmoxNodes and returns the data updated in the database.
     * @param {ProxmoxNodeUpdateManyAndReturnArgs} args - Arguments to update many ProxmoxNodes.
     * @example
     * // Update many ProxmoxNodes
     * const proxmoxNode = await prisma.proxmoxNode.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more ProxmoxNodes and only return the `id`
     * const proxmoxNodeWithIdOnly = await prisma.proxmoxNode.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ProxmoxNodeUpdateManyAndReturnArgs>(args: SelectSubset<T, ProxmoxNodeUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProxmoxNodePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one ProxmoxNode.
     * @param {ProxmoxNodeUpsertArgs} args - Arguments to update or create a ProxmoxNode.
     * @example
     * // Update or create a ProxmoxNode
     * const proxmoxNode = await prisma.proxmoxNode.upsert({
     *   create: {
     *     // ... data to create a ProxmoxNode
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ProxmoxNode we want to update
     *   }
     * })
     */
    upsert<T extends ProxmoxNodeUpsertArgs>(args: SelectSubset<T, ProxmoxNodeUpsertArgs<ExtArgs>>): Prisma__ProxmoxNodeClient<$Result.GetResult<Prisma.$ProxmoxNodePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of ProxmoxNodes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProxmoxNodeCountArgs} args - Arguments to filter ProxmoxNodes to count.
     * @example
     * // Count the number of ProxmoxNodes
     * const count = await prisma.proxmoxNode.count({
     *   where: {
     *     // ... the filter for the ProxmoxNodes we want to count
     *   }
     * })
    **/
    count<T extends ProxmoxNodeCountArgs>(
      args?: Subset<T, ProxmoxNodeCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ProxmoxNodeCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ProxmoxNode.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProxmoxNodeAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ProxmoxNodeAggregateArgs>(args: Subset<T, ProxmoxNodeAggregateArgs>): Prisma.PrismaPromise<GetProxmoxNodeAggregateType<T>>

    /**
     * Group by ProxmoxNode.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProxmoxNodeGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ProxmoxNodeGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ProxmoxNodeGroupByArgs['orderBy'] }
        : { orderBy?: ProxmoxNodeGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ProxmoxNodeGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetProxmoxNodeGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ProxmoxNode model
   */
  readonly fields: ProxmoxNodeFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ProxmoxNode.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ProxmoxNodeClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    vms<T extends ProxmoxNode$vmsArgs<ExtArgs> = {}>(args?: Subset<T, ProxmoxNode$vmsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProxmoxVMPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    server<T extends ProxmoxNode$serverArgs<ExtArgs> = {}>(args?: Subset<T, ProxmoxNode$serverArgs<ExtArgs>>): Prisma__ProxmoxServerClient<$Result.GetResult<Prisma.$ProxmoxServerPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ProxmoxNode model
   */
  interface ProxmoxNodeFieldRefs {
    readonly id: FieldRef<"ProxmoxNode", 'String'>
    readonly name: FieldRef<"ProxmoxNode", 'String'>
    readonly status: FieldRef<"ProxmoxNode", 'String'>
    readonly maxcpu: FieldRef<"ProxmoxNode", 'Int'>
    readonly maxmem: FieldRef<"ProxmoxNode", 'BigInt'>
    readonly cpu: FieldRef<"ProxmoxNode", 'Float'>
    readonly mem: FieldRef<"ProxmoxNode", 'BigInt'>
    readonly uptime: FieldRef<"ProxmoxNode", 'Int'>
    readonly raw: FieldRef<"ProxmoxNode", 'String'>
    readonly createdAt: FieldRef<"ProxmoxNode", 'DateTime'>
    readonly updatedAt: FieldRef<"ProxmoxNode", 'DateTime'>
    readonly serverId: FieldRef<"ProxmoxNode", 'String'>
  }
    

  // Custom InputTypes
  /**
   * ProxmoxNode findUnique
   */
  export type ProxmoxNodeFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProxmoxNode
     */
    select?: ProxmoxNodeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProxmoxNode
     */
    omit?: ProxmoxNodeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProxmoxNodeInclude<ExtArgs> | null
    /**
     * Filter, which ProxmoxNode to fetch.
     */
    where: ProxmoxNodeWhereUniqueInput
  }

  /**
   * ProxmoxNode findUniqueOrThrow
   */
  export type ProxmoxNodeFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProxmoxNode
     */
    select?: ProxmoxNodeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProxmoxNode
     */
    omit?: ProxmoxNodeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProxmoxNodeInclude<ExtArgs> | null
    /**
     * Filter, which ProxmoxNode to fetch.
     */
    where: ProxmoxNodeWhereUniqueInput
  }

  /**
   * ProxmoxNode findFirst
   */
  export type ProxmoxNodeFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProxmoxNode
     */
    select?: ProxmoxNodeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProxmoxNode
     */
    omit?: ProxmoxNodeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProxmoxNodeInclude<ExtArgs> | null
    /**
     * Filter, which ProxmoxNode to fetch.
     */
    where?: ProxmoxNodeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProxmoxNodes to fetch.
     */
    orderBy?: ProxmoxNodeOrderByWithRelationInput | ProxmoxNodeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ProxmoxNodes.
     */
    cursor?: ProxmoxNodeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProxmoxNodes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProxmoxNodes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ProxmoxNodes.
     */
    distinct?: ProxmoxNodeScalarFieldEnum | ProxmoxNodeScalarFieldEnum[]
  }

  /**
   * ProxmoxNode findFirstOrThrow
   */
  export type ProxmoxNodeFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProxmoxNode
     */
    select?: ProxmoxNodeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProxmoxNode
     */
    omit?: ProxmoxNodeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProxmoxNodeInclude<ExtArgs> | null
    /**
     * Filter, which ProxmoxNode to fetch.
     */
    where?: ProxmoxNodeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProxmoxNodes to fetch.
     */
    orderBy?: ProxmoxNodeOrderByWithRelationInput | ProxmoxNodeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ProxmoxNodes.
     */
    cursor?: ProxmoxNodeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProxmoxNodes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProxmoxNodes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ProxmoxNodes.
     */
    distinct?: ProxmoxNodeScalarFieldEnum | ProxmoxNodeScalarFieldEnum[]
  }

  /**
   * ProxmoxNode findMany
   */
  export type ProxmoxNodeFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProxmoxNode
     */
    select?: ProxmoxNodeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProxmoxNode
     */
    omit?: ProxmoxNodeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProxmoxNodeInclude<ExtArgs> | null
    /**
     * Filter, which ProxmoxNodes to fetch.
     */
    where?: ProxmoxNodeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProxmoxNodes to fetch.
     */
    orderBy?: ProxmoxNodeOrderByWithRelationInput | ProxmoxNodeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ProxmoxNodes.
     */
    cursor?: ProxmoxNodeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProxmoxNodes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProxmoxNodes.
     */
    skip?: number
    distinct?: ProxmoxNodeScalarFieldEnum | ProxmoxNodeScalarFieldEnum[]
  }

  /**
   * ProxmoxNode create
   */
  export type ProxmoxNodeCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProxmoxNode
     */
    select?: ProxmoxNodeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProxmoxNode
     */
    omit?: ProxmoxNodeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProxmoxNodeInclude<ExtArgs> | null
    /**
     * The data needed to create a ProxmoxNode.
     */
    data: XOR<ProxmoxNodeCreateInput, ProxmoxNodeUncheckedCreateInput>
  }

  /**
   * ProxmoxNode createMany
   */
  export type ProxmoxNodeCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ProxmoxNodes.
     */
    data: ProxmoxNodeCreateManyInput | ProxmoxNodeCreateManyInput[]
  }

  /**
   * ProxmoxNode createManyAndReturn
   */
  export type ProxmoxNodeCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProxmoxNode
     */
    select?: ProxmoxNodeSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ProxmoxNode
     */
    omit?: ProxmoxNodeOmit<ExtArgs> | null
    /**
     * The data used to create many ProxmoxNodes.
     */
    data: ProxmoxNodeCreateManyInput | ProxmoxNodeCreateManyInput[]
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProxmoxNodeIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * ProxmoxNode update
   */
  export type ProxmoxNodeUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProxmoxNode
     */
    select?: ProxmoxNodeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProxmoxNode
     */
    omit?: ProxmoxNodeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProxmoxNodeInclude<ExtArgs> | null
    /**
     * The data needed to update a ProxmoxNode.
     */
    data: XOR<ProxmoxNodeUpdateInput, ProxmoxNodeUncheckedUpdateInput>
    /**
     * Choose, which ProxmoxNode to update.
     */
    where: ProxmoxNodeWhereUniqueInput
  }

  /**
   * ProxmoxNode updateMany
   */
  export type ProxmoxNodeUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ProxmoxNodes.
     */
    data: XOR<ProxmoxNodeUpdateManyMutationInput, ProxmoxNodeUncheckedUpdateManyInput>
    /**
     * Filter which ProxmoxNodes to update
     */
    where?: ProxmoxNodeWhereInput
    /**
     * Limit how many ProxmoxNodes to update.
     */
    limit?: number
  }

  /**
   * ProxmoxNode updateManyAndReturn
   */
  export type ProxmoxNodeUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProxmoxNode
     */
    select?: ProxmoxNodeSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ProxmoxNode
     */
    omit?: ProxmoxNodeOmit<ExtArgs> | null
    /**
     * The data used to update ProxmoxNodes.
     */
    data: XOR<ProxmoxNodeUpdateManyMutationInput, ProxmoxNodeUncheckedUpdateManyInput>
    /**
     * Filter which ProxmoxNodes to update
     */
    where?: ProxmoxNodeWhereInput
    /**
     * Limit how many ProxmoxNodes to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProxmoxNodeIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * ProxmoxNode upsert
   */
  export type ProxmoxNodeUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProxmoxNode
     */
    select?: ProxmoxNodeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProxmoxNode
     */
    omit?: ProxmoxNodeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProxmoxNodeInclude<ExtArgs> | null
    /**
     * The filter to search for the ProxmoxNode to update in case it exists.
     */
    where: ProxmoxNodeWhereUniqueInput
    /**
     * In case the ProxmoxNode found by the `where` argument doesn't exist, create a new ProxmoxNode with this data.
     */
    create: XOR<ProxmoxNodeCreateInput, ProxmoxNodeUncheckedCreateInput>
    /**
     * In case the ProxmoxNode was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ProxmoxNodeUpdateInput, ProxmoxNodeUncheckedUpdateInput>
  }

  /**
   * ProxmoxNode delete
   */
  export type ProxmoxNodeDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProxmoxNode
     */
    select?: ProxmoxNodeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProxmoxNode
     */
    omit?: ProxmoxNodeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProxmoxNodeInclude<ExtArgs> | null
    /**
     * Filter which ProxmoxNode to delete.
     */
    where: ProxmoxNodeWhereUniqueInput
  }

  /**
   * ProxmoxNode deleteMany
   */
  export type ProxmoxNodeDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ProxmoxNodes to delete
     */
    where?: ProxmoxNodeWhereInput
    /**
     * Limit how many ProxmoxNodes to delete.
     */
    limit?: number
  }

  /**
   * ProxmoxNode.vms
   */
  export type ProxmoxNode$vmsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProxmoxVM
     */
    select?: ProxmoxVMSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProxmoxVM
     */
    omit?: ProxmoxVMOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProxmoxVMInclude<ExtArgs> | null
    where?: ProxmoxVMWhereInput
    orderBy?: ProxmoxVMOrderByWithRelationInput | ProxmoxVMOrderByWithRelationInput[]
    cursor?: ProxmoxVMWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ProxmoxVMScalarFieldEnum | ProxmoxVMScalarFieldEnum[]
  }

  /**
   * ProxmoxNode.server
   */
  export type ProxmoxNode$serverArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProxmoxServer
     */
    select?: ProxmoxServerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProxmoxServer
     */
    omit?: ProxmoxServerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProxmoxServerInclude<ExtArgs> | null
    where?: ProxmoxServerWhereInput
  }

  /**
   * ProxmoxNode without action
   */
  export type ProxmoxNodeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProxmoxNode
     */
    select?: ProxmoxNodeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProxmoxNode
     */
    omit?: ProxmoxNodeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProxmoxNodeInclude<ExtArgs> | null
  }


  /**
   * Model ProxmoxVM
   */

  export type AggregateProxmoxVM = {
    _count: ProxmoxVMCountAggregateOutputType | null
    _avg: ProxmoxVMAvgAggregateOutputType | null
    _sum: ProxmoxVMSumAggregateOutputType | null
    _min: ProxmoxVMMinAggregateOutputType | null
    _max: ProxmoxVMMaxAggregateOutputType | null
  }

  export type ProxmoxVMAvgAggregateOutputType = {
    vmid: number | null
    maxcpu: number | null
    maxmem: number | null
    cpu: number | null
    mem: number | null
    sshPort: number | null
  }

  export type ProxmoxVMSumAggregateOutputType = {
    vmid: number | null
    maxcpu: number | null
    maxmem: bigint | null
    cpu: number | null
    mem: bigint | null
    sshPort: number | null
  }

  export type ProxmoxVMMinAggregateOutputType = {
    id: string | null
    vmid: number | null
    nodeName: string | null
    serverId: string | null
    name: string | null
    type: string | null
    status: string | null
    maxcpu: number | null
    maxmem: bigint | null
    cpu: number | null
    mem: bigint | null
    tags: string | null
    sshHost: string | null
    sshPort: number | null
    sshUser: string | null
    raw: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ProxmoxVMMaxAggregateOutputType = {
    id: string | null
    vmid: number | null
    nodeName: string | null
    serverId: string | null
    name: string | null
    type: string | null
    status: string | null
    maxcpu: number | null
    maxmem: bigint | null
    cpu: number | null
    mem: bigint | null
    tags: string | null
    sshHost: string | null
    sshPort: number | null
    sshUser: string | null
    raw: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ProxmoxVMCountAggregateOutputType = {
    id: number
    vmid: number
    nodeName: number
    serverId: number
    name: number
    type: number
    status: number
    maxcpu: number
    maxmem: number
    cpu: number
    mem: number
    tags: number
    sshHost: number
    sshPort: number
    sshUser: number
    raw: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type ProxmoxVMAvgAggregateInputType = {
    vmid?: true
    maxcpu?: true
    maxmem?: true
    cpu?: true
    mem?: true
    sshPort?: true
  }

  export type ProxmoxVMSumAggregateInputType = {
    vmid?: true
    maxcpu?: true
    maxmem?: true
    cpu?: true
    mem?: true
    sshPort?: true
  }

  export type ProxmoxVMMinAggregateInputType = {
    id?: true
    vmid?: true
    nodeName?: true
    serverId?: true
    name?: true
    type?: true
    status?: true
    maxcpu?: true
    maxmem?: true
    cpu?: true
    mem?: true
    tags?: true
    sshHost?: true
    sshPort?: true
    sshUser?: true
    raw?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ProxmoxVMMaxAggregateInputType = {
    id?: true
    vmid?: true
    nodeName?: true
    serverId?: true
    name?: true
    type?: true
    status?: true
    maxcpu?: true
    maxmem?: true
    cpu?: true
    mem?: true
    tags?: true
    sshHost?: true
    sshPort?: true
    sshUser?: true
    raw?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ProxmoxVMCountAggregateInputType = {
    id?: true
    vmid?: true
    nodeName?: true
    serverId?: true
    name?: true
    type?: true
    status?: true
    maxcpu?: true
    maxmem?: true
    cpu?: true
    mem?: true
    tags?: true
    sshHost?: true
    sshPort?: true
    sshUser?: true
    raw?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type ProxmoxVMAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ProxmoxVM to aggregate.
     */
    where?: ProxmoxVMWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProxmoxVMS to fetch.
     */
    orderBy?: ProxmoxVMOrderByWithRelationInput | ProxmoxVMOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ProxmoxVMWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProxmoxVMS from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProxmoxVMS.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ProxmoxVMS
    **/
    _count?: true | ProxmoxVMCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ProxmoxVMAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ProxmoxVMSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ProxmoxVMMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ProxmoxVMMaxAggregateInputType
  }

  export type GetProxmoxVMAggregateType<T extends ProxmoxVMAggregateArgs> = {
        [P in keyof T & keyof AggregateProxmoxVM]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateProxmoxVM[P]>
      : GetScalarType<T[P], AggregateProxmoxVM[P]>
  }




  export type ProxmoxVMGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ProxmoxVMWhereInput
    orderBy?: ProxmoxVMOrderByWithAggregationInput | ProxmoxVMOrderByWithAggregationInput[]
    by: ProxmoxVMScalarFieldEnum[] | ProxmoxVMScalarFieldEnum
    having?: ProxmoxVMScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ProxmoxVMCountAggregateInputType | true
    _avg?: ProxmoxVMAvgAggregateInputType
    _sum?: ProxmoxVMSumAggregateInputType
    _min?: ProxmoxVMMinAggregateInputType
    _max?: ProxmoxVMMaxAggregateInputType
  }

  export type ProxmoxVMGroupByOutputType = {
    id: string
    vmid: number
    nodeName: string
    serverId: string | null
    name: string | null
    type: string | null
    status: string | null
    maxcpu: number | null
    maxmem: bigint | null
    cpu: number | null
    mem: bigint | null
    tags: string | null
    sshHost: string | null
    sshPort: number | null
    sshUser: string | null
    raw: string | null
    createdAt: Date
    updatedAt: Date
    _count: ProxmoxVMCountAggregateOutputType | null
    _avg: ProxmoxVMAvgAggregateOutputType | null
    _sum: ProxmoxVMSumAggregateOutputType | null
    _min: ProxmoxVMMinAggregateOutputType | null
    _max: ProxmoxVMMaxAggregateOutputType | null
  }

  type GetProxmoxVMGroupByPayload<T extends ProxmoxVMGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ProxmoxVMGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ProxmoxVMGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ProxmoxVMGroupByOutputType[P]>
            : GetScalarType<T[P], ProxmoxVMGroupByOutputType[P]>
        }
      >
    >


  export type ProxmoxVMSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    vmid?: boolean
    nodeName?: boolean
    serverId?: boolean
    name?: boolean
    type?: boolean
    status?: boolean
    maxcpu?: boolean
    maxmem?: boolean
    cpu?: boolean
    mem?: boolean
    tags?: boolean
    sshHost?: boolean
    sshPort?: boolean
    sshUser?: boolean
    raw?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    node?: boolean | ProxmoxVM$nodeArgs<ExtArgs>
    metrics?: boolean | ProxmoxVM$metricsArgs<ExtArgs>
    server?: boolean | ProxmoxVM$serverArgs<ExtArgs>
    _count?: boolean | ProxmoxVMCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["proxmoxVM"]>

  export type ProxmoxVMSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    vmid?: boolean
    nodeName?: boolean
    serverId?: boolean
    name?: boolean
    type?: boolean
    status?: boolean
    maxcpu?: boolean
    maxmem?: boolean
    cpu?: boolean
    mem?: boolean
    tags?: boolean
    sshHost?: boolean
    sshPort?: boolean
    sshUser?: boolean
    raw?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    node?: boolean | ProxmoxVM$nodeArgs<ExtArgs>
    server?: boolean | ProxmoxVM$serverArgs<ExtArgs>
  }, ExtArgs["result"]["proxmoxVM"]>

  export type ProxmoxVMSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    vmid?: boolean
    nodeName?: boolean
    serverId?: boolean
    name?: boolean
    type?: boolean
    status?: boolean
    maxcpu?: boolean
    maxmem?: boolean
    cpu?: boolean
    mem?: boolean
    tags?: boolean
    sshHost?: boolean
    sshPort?: boolean
    sshUser?: boolean
    raw?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    node?: boolean | ProxmoxVM$nodeArgs<ExtArgs>
    server?: boolean | ProxmoxVM$serverArgs<ExtArgs>
  }, ExtArgs["result"]["proxmoxVM"]>

  export type ProxmoxVMSelectScalar = {
    id?: boolean
    vmid?: boolean
    nodeName?: boolean
    serverId?: boolean
    name?: boolean
    type?: boolean
    status?: boolean
    maxcpu?: boolean
    maxmem?: boolean
    cpu?: boolean
    mem?: boolean
    tags?: boolean
    sshHost?: boolean
    sshPort?: boolean
    sshUser?: boolean
    raw?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type ProxmoxVMOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "vmid" | "nodeName" | "serverId" | "name" | "type" | "status" | "maxcpu" | "maxmem" | "cpu" | "mem" | "tags" | "sshHost" | "sshPort" | "sshUser" | "raw" | "createdAt" | "updatedAt", ExtArgs["result"]["proxmoxVM"]>
  export type ProxmoxVMInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    node?: boolean | ProxmoxVM$nodeArgs<ExtArgs>
    metrics?: boolean | ProxmoxVM$metricsArgs<ExtArgs>
    server?: boolean | ProxmoxVM$serverArgs<ExtArgs>
    _count?: boolean | ProxmoxVMCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type ProxmoxVMIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    node?: boolean | ProxmoxVM$nodeArgs<ExtArgs>
    server?: boolean | ProxmoxVM$serverArgs<ExtArgs>
  }
  export type ProxmoxVMIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    node?: boolean | ProxmoxVM$nodeArgs<ExtArgs>
    server?: boolean | ProxmoxVM$serverArgs<ExtArgs>
  }

  export type $ProxmoxVMPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ProxmoxVM"
    objects: {
      node: Prisma.$ProxmoxNodePayload<ExtArgs> | null
      metrics: Prisma.$ProxmoxMetricPayload<ExtArgs>[]
      server: Prisma.$ProxmoxServerPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      vmid: number
      nodeName: string
      serverId: string | null
      name: string | null
      type: string | null
      status: string | null
      maxcpu: number | null
      maxmem: bigint | null
      cpu: number | null
      mem: bigint | null
      tags: string | null
      sshHost: string | null
      sshPort: number | null
      sshUser: string | null
      raw: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["proxmoxVM"]>
    composites: {}
  }

  type ProxmoxVMGetPayload<S extends boolean | null | undefined | ProxmoxVMDefaultArgs> = $Result.GetResult<Prisma.$ProxmoxVMPayload, S>

  type ProxmoxVMCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ProxmoxVMFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ProxmoxVMCountAggregateInputType | true
    }

  export interface ProxmoxVMDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ProxmoxVM'], meta: { name: 'ProxmoxVM' } }
    /**
     * Find zero or one ProxmoxVM that matches the filter.
     * @param {ProxmoxVMFindUniqueArgs} args - Arguments to find a ProxmoxVM
     * @example
     * // Get one ProxmoxVM
     * const proxmoxVM = await prisma.proxmoxVM.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ProxmoxVMFindUniqueArgs>(args: SelectSubset<T, ProxmoxVMFindUniqueArgs<ExtArgs>>): Prisma__ProxmoxVMClient<$Result.GetResult<Prisma.$ProxmoxVMPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one ProxmoxVM that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ProxmoxVMFindUniqueOrThrowArgs} args - Arguments to find a ProxmoxVM
     * @example
     * // Get one ProxmoxVM
     * const proxmoxVM = await prisma.proxmoxVM.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ProxmoxVMFindUniqueOrThrowArgs>(args: SelectSubset<T, ProxmoxVMFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ProxmoxVMClient<$Result.GetResult<Prisma.$ProxmoxVMPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ProxmoxVM that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProxmoxVMFindFirstArgs} args - Arguments to find a ProxmoxVM
     * @example
     * // Get one ProxmoxVM
     * const proxmoxVM = await prisma.proxmoxVM.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ProxmoxVMFindFirstArgs>(args?: SelectSubset<T, ProxmoxVMFindFirstArgs<ExtArgs>>): Prisma__ProxmoxVMClient<$Result.GetResult<Prisma.$ProxmoxVMPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ProxmoxVM that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProxmoxVMFindFirstOrThrowArgs} args - Arguments to find a ProxmoxVM
     * @example
     * // Get one ProxmoxVM
     * const proxmoxVM = await prisma.proxmoxVM.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ProxmoxVMFindFirstOrThrowArgs>(args?: SelectSubset<T, ProxmoxVMFindFirstOrThrowArgs<ExtArgs>>): Prisma__ProxmoxVMClient<$Result.GetResult<Prisma.$ProxmoxVMPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more ProxmoxVMS that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProxmoxVMFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ProxmoxVMS
     * const proxmoxVMS = await prisma.proxmoxVM.findMany()
     * 
     * // Get first 10 ProxmoxVMS
     * const proxmoxVMS = await prisma.proxmoxVM.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const proxmoxVMWithIdOnly = await prisma.proxmoxVM.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ProxmoxVMFindManyArgs>(args?: SelectSubset<T, ProxmoxVMFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProxmoxVMPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a ProxmoxVM.
     * @param {ProxmoxVMCreateArgs} args - Arguments to create a ProxmoxVM.
     * @example
     * // Create one ProxmoxVM
     * const ProxmoxVM = await prisma.proxmoxVM.create({
     *   data: {
     *     // ... data to create a ProxmoxVM
     *   }
     * })
     * 
     */
    create<T extends ProxmoxVMCreateArgs>(args: SelectSubset<T, ProxmoxVMCreateArgs<ExtArgs>>): Prisma__ProxmoxVMClient<$Result.GetResult<Prisma.$ProxmoxVMPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many ProxmoxVMS.
     * @param {ProxmoxVMCreateManyArgs} args - Arguments to create many ProxmoxVMS.
     * @example
     * // Create many ProxmoxVMS
     * const proxmoxVM = await prisma.proxmoxVM.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ProxmoxVMCreateManyArgs>(args?: SelectSubset<T, ProxmoxVMCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many ProxmoxVMS and returns the data saved in the database.
     * @param {ProxmoxVMCreateManyAndReturnArgs} args - Arguments to create many ProxmoxVMS.
     * @example
     * // Create many ProxmoxVMS
     * const proxmoxVM = await prisma.proxmoxVM.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many ProxmoxVMS and only return the `id`
     * const proxmoxVMWithIdOnly = await prisma.proxmoxVM.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ProxmoxVMCreateManyAndReturnArgs>(args?: SelectSubset<T, ProxmoxVMCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProxmoxVMPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a ProxmoxVM.
     * @param {ProxmoxVMDeleteArgs} args - Arguments to delete one ProxmoxVM.
     * @example
     * // Delete one ProxmoxVM
     * const ProxmoxVM = await prisma.proxmoxVM.delete({
     *   where: {
     *     // ... filter to delete one ProxmoxVM
     *   }
     * })
     * 
     */
    delete<T extends ProxmoxVMDeleteArgs>(args: SelectSubset<T, ProxmoxVMDeleteArgs<ExtArgs>>): Prisma__ProxmoxVMClient<$Result.GetResult<Prisma.$ProxmoxVMPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one ProxmoxVM.
     * @param {ProxmoxVMUpdateArgs} args - Arguments to update one ProxmoxVM.
     * @example
     * // Update one ProxmoxVM
     * const proxmoxVM = await prisma.proxmoxVM.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ProxmoxVMUpdateArgs>(args: SelectSubset<T, ProxmoxVMUpdateArgs<ExtArgs>>): Prisma__ProxmoxVMClient<$Result.GetResult<Prisma.$ProxmoxVMPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more ProxmoxVMS.
     * @param {ProxmoxVMDeleteManyArgs} args - Arguments to filter ProxmoxVMS to delete.
     * @example
     * // Delete a few ProxmoxVMS
     * const { count } = await prisma.proxmoxVM.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ProxmoxVMDeleteManyArgs>(args?: SelectSubset<T, ProxmoxVMDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ProxmoxVMS.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProxmoxVMUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ProxmoxVMS
     * const proxmoxVM = await prisma.proxmoxVM.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ProxmoxVMUpdateManyArgs>(args: SelectSubset<T, ProxmoxVMUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ProxmoxVMS and returns the data updated in the database.
     * @param {ProxmoxVMUpdateManyAndReturnArgs} args - Arguments to update many ProxmoxVMS.
     * @example
     * // Update many ProxmoxVMS
     * const proxmoxVM = await prisma.proxmoxVM.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more ProxmoxVMS and only return the `id`
     * const proxmoxVMWithIdOnly = await prisma.proxmoxVM.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ProxmoxVMUpdateManyAndReturnArgs>(args: SelectSubset<T, ProxmoxVMUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProxmoxVMPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one ProxmoxVM.
     * @param {ProxmoxVMUpsertArgs} args - Arguments to update or create a ProxmoxVM.
     * @example
     * // Update or create a ProxmoxVM
     * const proxmoxVM = await prisma.proxmoxVM.upsert({
     *   create: {
     *     // ... data to create a ProxmoxVM
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ProxmoxVM we want to update
     *   }
     * })
     */
    upsert<T extends ProxmoxVMUpsertArgs>(args: SelectSubset<T, ProxmoxVMUpsertArgs<ExtArgs>>): Prisma__ProxmoxVMClient<$Result.GetResult<Prisma.$ProxmoxVMPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of ProxmoxVMS.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProxmoxVMCountArgs} args - Arguments to filter ProxmoxVMS to count.
     * @example
     * // Count the number of ProxmoxVMS
     * const count = await prisma.proxmoxVM.count({
     *   where: {
     *     // ... the filter for the ProxmoxVMS we want to count
     *   }
     * })
    **/
    count<T extends ProxmoxVMCountArgs>(
      args?: Subset<T, ProxmoxVMCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ProxmoxVMCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ProxmoxVM.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProxmoxVMAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ProxmoxVMAggregateArgs>(args: Subset<T, ProxmoxVMAggregateArgs>): Prisma.PrismaPromise<GetProxmoxVMAggregateType<T>>

    /**
     * Group by ProxmoxVM.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProxmoxVMGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ProxmoxVMGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ProxmoxVMGroupByArgs['orderBy'] }
        : { orderBy?: ProxmoxVMGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ProxmoxVMGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetProxmoxVMGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ProxmoxVM model
   */
  readonly fields: ProxmoxVMFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ProxmoxVM.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ProxmoxVMClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    node<T extends ProxmoxVM$nodeArgs<ExtArgs> = {}>(args?: Subset<T, ProxmoxVM$nodeArgs<ExtArgs>>): Prisma__ProxmoxNodeClient<$Result.GetResult<Prisma.$ProxmoxNodePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    metrics<T extends ProxmoxVM$metricsArgs<ExtArgs> = {}>(args?: Subset<T, ProxmoxVM$metricsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProxmoxMetricPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    server<T extends ProxmoxVM$serverArgs<ExtArgs> = {}>(args?: Subset<T, ProxmoxVM$serverArgs<ExtArgs>>): Prisma__ProxmoxServerClient<$Result.GetResult<Prisma.$ProxmoxServerPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ProxmoxVM model
   */
  interface ProxmoxVMFieldRefs {
    readonly id: FieldRef<"ProxmoxVM", 'String'>
    readonly vmid: FieldRef<"ProxmoxVM", 'Int'>
    readonly nodeName: FieldRef<"ProxmoxVM", 'String'>
    readonly serverId: FieldRef<"ProxmoxVM", 'String'>
    readonly name: FieldRef<"ProxmoxVM", 'String'>
    readonly type: FieldRef<"ProxmoxVM", 'String'>
    readonly status: FieldRef<"ProxmoxVM", 'String'>
    readonly maxcpu: FieldRef<"ProxmoxVM", 'Int'>
    readonly maxmem: FieldRef<"ProxmoxVM", 'BigInt'>
    readonly cpu: FieldRef<"ProxmoxVM", 'Float'>
    readonly mem: FieldRef<"ProxmoxVM", 'BigInt'>
    readonly tags: FieldRef<"ProxmoxVM", 'String'>
    readonly sshHost: FieldRef<"ProxmoxVM", 'String'>
    readonly sshPort: FieldRef<"ProxmoxVM", 'Int'>
    readonly sshUser: FieldRef<"ProxmoxVM", 'String'>
    readonly raw: FieldRef<"ProxmoxVM", 'String'>
    readonly createdAt: FieldRef<"ProxmoxVM", 'DateTime'>
    readonly updatedAt: FieldRef<"ProxmoxVM", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * ProxmoxVM findUnique
   */
  export type ProxmoxVMFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProxmoxVM
     */
    select?: ProxmoxVMSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProxmoxVM
     */
    omit?: ProxmoxVMOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProxmoxVMInclude<ExtArgs> | null
    /**
     * Filter, which ProxmoxVM to fetch.
     */
    where: ProxmoxVMWhereUniqueInput
  }

  /**
   * ProxmoxVM findUniqueOrThrow
   */
  export type ProxmoxVMFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProxmoxVM
     */
    select?: ProxmoxVMSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProxmoxVM
     */
    omit?: ProxmoxVMOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProxmoxVMInclude<ExtArgs> | null
    /**
     * Filter, which ProxmoxVM to fetch.
     */
    where: ProxmoxVMWhereUniqueInput
  }

  /**
   * ProxmoxVM findFirst
   */
  export type ProxmoxVMFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProxmoxVM
     */
    select?: ProxmoxVMSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProxmoxVM
     */
    omit?: ProxmoxVMOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProxmoxVMInclude<ExtArgs> | null
    /**
     * Filter, which ProxmoxVM to fetch.
     */
    where?: ProxmoxVMWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProxmoxVMS to fetch.
     */
    orderBy?: ProxmoxVMOrderByWithRelationInput | ProxmoxVMOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ProxmoxVMS.
     */
    cursor?: ProxmoxVMWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProxmoxVMS from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProxmoxVMS.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ProxmoxVMS.
     */
    distinct?: ProxmoxVMScalarFieldEnum | ProxmoxVMScalarFieldEnum[]
  }

  /**
   * ProxmoxVM findFirstOrThrow
   */
  export type ProxmoxVMFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProxmoxVM
     */
    select?: ProxmoxVMSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProxmoxVM
     */
    omit?: ProxmoxVMOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProxmoxVMInclude<ExtArgs> | null
    /**
     * Filter, which ProxmoxVM to fetch.
     */
    where?: ProxmoxVMWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProxmoxVMS to fetch.
     */
    orderBy?: ProxmoxVMOrderByWithRelationInput | ProxmoxVMOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ProxmoxVMS.
     */
    cursor?: ProxmoxVMWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProxmoxVMS from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProxmoxVMS.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ProxmoxVMS.
     */
    distinct?: ProxmoxVMScalarFieldEnum | ProxmoxVMScalarFieldEnum[]
  }

  /**
   * ProxmoxVM findMany
   */
  export type ProxmoxVMFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProxmoxVM
     */
    select?: ProxmoxVMSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProxmoxVM
     */
    omit?: ProxmoxVMOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProxmoxVMInclude<ExtArgs> | null
    /**
     * Filter, which ProxmoxVMS to fetch.
     */
    where?: ProxmoxVMWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProxmoxVMS to fetch.
     */
    orderBy?: ProxmoxVMOrderByWithRelationInput | ProxmoxVMOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ProxmoxVMS.
     */
    cursor?: ProxmoxVMWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProxmoxVMS from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProxmoxVMS.
     */
    skip?: number
    distinct?: ProxmoxVMScalarFieldEnum | ProxmoxVMScalarFieldEnum[]
  }

  /**
   * ProxmoxVM create
   */
  export type ProxmoxVMCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProxmoxVM
     */
    select?: ProxmoxVMSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProxmoxVM
     */
    omit?: ProxmoxVMOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProxmoxVMInclude<ExtArgs> | null
    /**
     * The data needed to create a ProxmoxVM.
     */
    data: XOR<ProxmoxVMCreateInput, ProxmoxVMUncheckedCreateInput>
  }

  /**
   * ProxmoxVM createMany
   */
  export type ProxmoxVMCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ProxmoxVMS.
     */
    data: ProxmoxVMCreateManyInput | ProxmoxVMCreateManyInput[]
  }

  /**
   * ProxmoxVM createManyAndReturn
   */
  export type ProxmoxVMCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProxmoxVM
     */
    select?: ProxmoxVMSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ProxmoxVM
     */
    omit?: ProxmoxVMOmit<ExtArgs> | null
    /**
     * The data used to create many ProxmoxVMS.
     */
    data: ProxmoxVMCreateManyInput | ProxmoxVMCreateManyInput[]
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProxmoxVMIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * ProxmoxVM update
   */
  export type ProxmoxVMUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProxmoxVM
     */
    select?: ProxmoxVMSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProxmoxVM
     */
    omit?: ProxmoxVMOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProxmoxVMInclude<ExtArgs> | null
    /**
     * The data needed to update a ProxmoxVM.
     */
    data: XOR<ProxmoxVMUpdateInput, ProxmoxVMUncheckedUpdateInput>
    /**
     * Choose, which ProxmoxVM to update.
     */
    where: ProxmoxVMWhereUniqueInput
  }

  /**
   * ProxmoxVM updateMany
   */
  export type ProxmoxVMUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ProxmoxVMS.
     */
    data: XOR<ProxmoxVMUpdateManyMutationInput, ProxmoxVMUncheckedUpdateManyInput>
    /**
     * Filter which ProxmoxVMS to update
     */
    where?: ProxmoxVMWhereInput
    /**
     * Limit how many ProxmoxVMS to update.
     */
    limit?: number
  }

  /**
   * ProxmoxVM updateManyAndReturn
   */
  export type ProxmoxVMUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProxmoxVM
     */
    select?: ProxmoxVMSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ProxmoxVM
     */
    omit?: ProxmoxVMOmit<ExtArgs> | null
    /**
     * The data used to update ProxmoxVMS.
     */
    data: XOR<ProxmoxVMUpdateManyMutationInput, ProxmoxVMUncheckedUpdateManyInput>
    /**
     * Filter which ProxmoxVMS to update
     */
    where?: ProxmoxVMWhereInput
    /**
     * Limit how many ProxmoxVMS to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProxmoxVMIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * ProxmoxVM upsert
   */
  export type ProxmoxVMUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProxmoxVM
     */
    select?: ProxmoxVMSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProxmoxVM
     */
    omit?: ProxmoxVMOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProxmoxVMInclude<ExtArgs> | null
    /**
     * The filter to search for the ProxmoxVM to update in case it exists.
     */
    where: ProxmoxVMWhereUniqueInput
    /**
     * In case the ProxmoxVM found by the `where` argument doesn't exist, create a new ProxmoxVM with this data.
     */
    create: XOR<ProxmoxVMCreateInput, ProxmoxVMUncheckedCreateInput>
    /**
     * In case the ProxmoxVM was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ProxmoxVMUpdateInput, ProxmoxVMUncheckedUpdateInput>
  }

  /**
   * ProxmoxVM delete
   */
  export type ProxmoxVMDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProxmoxVM
     */
    select?: ProxmoxVMSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProxmoxVM
     */
    omit?: ProxmoxVMOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProxmoxVMInclude<ExtArgs> | null
    /**
     * Filter which ProxmoxVM to delete.
     */
    where: ProxmoxVMWhereUniqueInput
  }

  /**
   * ProxmoxVM deleteMany
   */
  export type ProxmoxVMDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ProxmoxVMS to delete
     */
    where?: ProxmoxVMWhereInput
    /**
     * Limit how many ProxmoxVMS to delete.
     */
    limit?: number
  }

  /**
   * ProxmoxVM.node
   */
  export type ProxmoxVM$nodeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProxmoxNode
     */
    select?: ProxmoxNodeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProxmoxNode
     */
    omit?: ProxmoxNodeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProxmoxNodeInclude<ExtArgs> | null
    where?: ProxmoxNodeWhereInput
  }

  /**
   * ProxmoxVM.metrics
   */
  export type ProxmoxVM$metricsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProxmoxMetric
     */
    select?: ProxmoxMetricSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProxmoxMetric
     */
    omit?: ProxmoxMetricOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProxmoxMetricInclude<ExtArgs> | null
    where?: ProxmoxMetricWhereInput
    orderBy?: ProxmoxMetricOrderByWithRelationInput | ProxmoxMetricOrderByWithRelationInput[]
    cursor?: ProxmoxMetricWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ProxmoxMetricScalarFieldEnum | ProxmoxMetricScalarFieldEnum[]
  }

  /**
   * ProxmoxVM.server
   */
  export type ProxmoxVM$serverArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProxmoxServer
     */
    select?: ProxmoxServerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProxmoxServer
     */
    omit?: ProxmoxServerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProxmoxServerInclude<ExtArgs> | null
    where?: ProxmoxServerWhereInput
  }

  /**
   * ProxmoxVM without action
   */
  export type ProxmoxVMDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProxmoxVM
     */
    select?: ProxmoxVMSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProxmoxVM
     */
    omit?: ProxmoxVMOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProxmoxVMInclude<ExtArgs> | null
  }


  /**
   * Model ProxmoxMetric
   */

  export type AggregateProxmoxMetric = {
    _count: ProxmoxMetricCountAggregateOutputType | null
    _avg: ProxmoxMetricAvgAggregateOutputType | null
    _sum: ProxmoxMetricSumAggregateOutputType | null
    _min: ProxmoxMetricMinAggregateOutputType | null
    _max: ProxmoxMetricMaxAggregateOutputType | null
  }

  export type ProxmoxMetricAvgAggregateOutputType = {
    vmNumericId: number | null
    cpu: number | null
    mem: number | null
    disk: number | null
    netin: number | null
    netout: number | null
  }

  export type ProxmoxMetricSumAggregateOutputType = {
    vmNumericId: number | null
    cpu: number | null
    mem: bigint | null
    disk: number | null
    netin: bigint | null
    netout: bigint | null
  }

  export type ProxmoxMetricMinAggregateOutputType = {
    id: string | null
    vmId: string | null
    vmNumericId: number | null
    nodeName: string | null
    serverId: string | null
    cpu: number | null
    mem: bigint | null
    disk: number | null
    netin: bigint | null
    netout: bigint | null
    ts: Date | null
  }

  export type ProxmoxMetricMaxAggregateOutputType = {
    id: string | null
    vmId: string | null
    vmNumericId: number | null
    nodeName: string | null
    serverId: string | null
    cpu: number | null
    mem: bigint | null
    disk: number | null
    netin: bigint | null
    netout: bigint | null
    ts: Date | null
  }

  export type ProxmoxMetricCountAggregateOutputType = {
    id: number
    vmId: number
    vmNumericId: number
    nodeName: number
    serverId: number
    cpu: number
    mem: number
    disk: number
    netin: number
    netout: number
    ts: number
    _all: number
  }


  export type ProxmoxMetricAvgAggregateInputType = {
    vmNumericId?: true
    cpu?: true
    mem?: true
    disk?: true
    netin?: true
    netout?: true
  }

  export type ProxmoxMetricSumAggregateInputType = {
    vmNumericId?: true
    cpu?: true
    mem?: true
    disk?: true
    netin?: true
    netout?: true
  }

  export type ProxmoxMetricMinAggregateInputType = {
    id?: true
    vmId?: true
    vmNumericId?: true
    nodeName?: true
    serverId?: true
    cpu?: true
    mem?: true
    disk?: true
    netin?: true
    netout?: true
    ts?: true
  }

  export type ProxmoxMetricMaxAggregateInputType = {
    id?: true
    vmId?: true
    vmNumericId?: true
    nodeName?: true
    serverId?: true
    cpu?: true
    mem?: true
    disk?: true
    netin?: true
    netout?: true
    ts?: true
  }

  export type ProxmoxMetricCountAggregateInputType = {
    id?: true
    vmId?: true
    vmNumericId?: true
    nodeName?: true
    serverId?: true
    cpu?: true
    mem?: true
    disk?: true
    netin?: true
    netout?: true
    ts?: true
    _all?: true
  }

  export type ProxmoxMetricAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ProxmoxMetric to aggregate.
     */
    where?: ProxmoxMetricWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProxmoxMetrics to fetch.
     */
    orderBy?: ProxmoxMetricOrderByWithRelationInput | ProxmoxMetricOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ProxmoxMetricWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProxmoxMetrics from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProxmoxMetrics.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ProxmoxMetrics
    **/
    _count?: true | ProxmoxMetricCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ProxmoxMetricAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ProxmoxMetricSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ProxmoxMetricMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ProxmoxMetricMaxAggregateInputType
  }

  export type GetProxmoxMetricAggregateType<T extends ProxmoxMetricAggregateArgs> = {
        [P in keyof T & keyof AggregateProxmoxMetric]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateProxmoxMetric[P]>
      : GetScalarType<T[P], AggregateProxmoxMetric[P]>
  }




  export type ProxmoxMetricGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ProxmoxMetricWhereInput
    orderBy?: ProxmoxMetricOrderByWithAggregationInput | ProxmoxMetricOrderByWithAggregationInput[]
    by: ProxmoxMetricScalarFieldEnum[] | ProxmoxMetricScalarFieldEnum
    having?: ProxmoxMetricScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ProxmoxMetricCountAggregateInputType | true
    _avg?: ProxmoxMetricAvgAggregateInputType
    _sum?: ProxmoxMetricSumAggregateInputType
    _min?: ProxmoxMetricMinAggregateInputType
    _max?: ProxmoxMetricMaxAggregateInputType
  }

  export type ProxmoxMetricGroupByOutputType = {
    id: string
    vmId: string | null
    vmNumericId: number | null
    nodeName: string | null
    serverId: string | null
    cpu: number | null
    mem: bigint | null
    disk: number | null
    netin: bigint | null
    netout: bigint | null
    ts: Date
    _count: ProxmoxMetricCountAggregateOutputType | null
    _avg: ProxmoxMetricAvgAggregateOutputType | null
    _sum: ProxmoxMetricSumAggregateOutputType | null
    _min: ProxmoxMetricMinAggregateOutputType | null
    _max: ProxmoxMetricMaxAggregateOutputType | null
  }

  type GetProxmoxMetricGroupByPayload<T extends ProxmoxMetricGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ProxmoxMetricGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ProxmoxMetricGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ProxmoxMetricGroupByOutputType[P]>
            : GetScalarType<T[P], ProxmoxMetricGroupByOutputType[P]>
        }
      >
    >


  export type ProxmoxMetricSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    vmId?: boolean
    vmNumericId?: boolean
    nodeName?: boolean
    serverId?: boolean
    cpu?: boolean
    mem?: boolean
    disk?: boolean
    netin?: boolean
    netout?: boolean
    ts?: boolean
    vm?: boolean | ProxmoxMetric$vmArgs<ExtArgs>
  }, ExtArgs["result"]["proxmoxMetric"]>

  export type ProxmoxMetricSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    vmId?: boolean
    vmNumericId?: boolean
    nodeName?: boolean
    serverId?: boolean
    cpu?: boolean
    mem?: boolean
    disk?: boolean
    netin?: boolean
    netout?: boolean
    ts?: boolean
    vm?: boolean | ProxmoxMetric$vmArgs<ExtArgs>
  }, ExtArgs["result"]["proxmoxMetric"]>

  export type ProxmoxMetricSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    vmId?: boolean
    vmNumericId?: boolean
    nodeName?: boolean
    serverId?: boolean
    cpu?: boolean
    mem?: boolean
    disk?: boolean
    netin?: boolean
    netout?: boolean
    ts?: boolean
    vm?: boolean | ProxmoxMetric$vmArgs<ExtArgs>
  }, ExtArgs["result"]["proxmoxMetric"]>

  export type ProxmoxMetricSelectScalar = {
    id?: boolean
    vmId?: boolean
    vmNumericId?: boolean
    nodeName?: boolean
    serverId?: boolean
    cpu?: boolean
    mem?: boolean
    disk?: boolean
    netin?: boolean
    netout?: boolean
    ts?: boolean
  }

  export type ProxmoxMetricOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "vmId" | "vmNumericId" | "nodeName" | "serverId" | "cpu" | "mem" | "disk" | "netin" | "netout" | "ts", ExtArgs["result"]["proxmoxMetric"]>
  export type ProxmoxMetricInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    vm?: boolean | ProxmoxMetric$vmArgs<ExtArgs>
  }
  export type ProxmoxMetricIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    vm?: boolean | ProxmoxMetric$vmArgs<ExtArgs>
  }
  export type ProxmoxMetricIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    vm?: boolean | ProxmoxMetric$vmArgs<ExtArgs>
  }

  export type $ProxmoxMetricPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ProxmoxMetric"
    objects: {
      vm: Prisma.$ProxmoxVMPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      vmId: string | null
      vmNumericId: number | null
      nodeName: string | null
      serverId: string | null
      cpu: number | null
      mem: bigint | null
      disk: number | null
      netin: bigint | null
      netout: bigint | null
      ts: Date
    }, ExtArgs["result"]["proxmoxMetric"]>
    composites: {}
  }

  type ProxmoxMetricGetPayload<S extends boolean | null | undefined | ProxmoxMetricDefaultArgs> = $Result.GetResult<Prisma.$ProxmoxMetricPayload, S>

  type ProxmoxMetricCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ProxmoxMetricFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ProxmoxMetricCountAggregateInputType | true
    }

  export interface ProxmoxMetricDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ProxmoxMetric'], meta: { name: 'ProxmoxMetric' } }
    /**
     * Find zero or one ProxmoxMetric that matches the filter.
     * @param {ProxmoxMetricFindUniqueArgs} args - Arguments to find a ProxmoxMetric
     * @example
     * // Get one ProxmoxMetric
     * const proxmoxMetric = await prisma.proxmoxMetric.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ProxmoxMetricFindUniqueArgs>(args: SelectSubset<T, ProxmoxMetricFindUniqueArgs<ExtArgs>>): Prisma__ProxmoxMetricClient<$Result.GetResult<Prisma.$ProxmoxMetricPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one ProxmoxMetric that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ProxmoxMetricFindUniqueOrThrowArgs} args - Arguments to find a ProxmoxMetric
     * @example
     * // Get one ProxmoxMetric
     * const proxmoxMetric = await prisma.proxmoxMetric.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ProxmoxMetricFindUniqueOrThrowArgs>(args: SelectSubset<T, ProxmoxMetricFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ProxmoxMetricClient<$Result.GetResult<Prisma.$ProxmoxMetricPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ProxmoxMetric that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProxmoxMetricFindFirstArgs} args - Arguments to find a ProxmoxMetric
     * @example
     * // Get one ProxmoxMetric
     * const proxmoxMetric = await prisma.proxmoxMetric.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ProxmoxMetricFindFirstArgs>(args?: SelectSubset<T, ProxmoxMetricFindFirstArgs<ExtArgs>>): Prisma__ProxmoxMetricClient<$Result.GetResult<Prisma.$ProxmoxMetricPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ProxmoxMetric that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProxmoxMetricFindFirstOrThrowArgs} args - Arguments to find a ProxmoxMetric
     * @example
     * // Get one ProxmoxMetric
     * const proxmoxMetric = await prisma.proxmoxMetric.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ProxmoxMetricFindFirstOrThrowArgs>(args?: SelectSubset<T, ProxmoxMetricFindFirstOrThrowArgs<ExtArgs>>): Prisma__ProxmoxMetricClient<$Result.GetResult<Prisma.$ProxmoxMetricPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more ProxmoxMetrics that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProxmoxMetricFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ProxmoxMetrics
     * const proxmoxMetrics = await prisma.proxmoxMetric.findMany()
     * 
     * // Get first 10 ProxmoxMetrics
     * const proxmoxMetrics = await prisma.proxmoxMetric.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const proxmoxMetricWithIdOnly = await prisma.proxmoxMetric.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ProxmoxMetricFindManyArgs>(args?: SelectSubset<T, ProxmoxMetricFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProxmoxMetricPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a ProxmoxMetric.
     * @param {ProxmoxMetricCreateArgs} args - Arguments to create a ProxmoxMetric.
     * @example
     * // Create one ProxmoxMetric
     * const ProxmoxMetric = await prisma.proxmoxMetric.create({
     *   data: {
     *     // ... data to create a ProxmoxMetric
     *   }
     * })
     * 
     */
    create<T extends ProxmoxMetricCreateArgs>(args: SelectSubset<T, ProxmoxMetricCreateArgs<ExtArgs>>): Prisma__ProxmoxMetricClient<$Result.GetResult<Prisma.$ProxmoxMetricPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many ProxmoxMetrics.
     * @param {ProxmoxMetricCreateManyArgs} args - Arguments to create many ProxmoxMetrics.
     * @example
     * // Create many ProxmoxMetrics
     * const proxmoxMetric = await prisma.proxmoxMetric.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ProxmoxMetricCreateManyArgs>(args?: SelectSubset<T, ProxmoxMetricCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many ProxmoxMetrics and returns the data saved in the database.
     * @param {ProxmoxMetricCreateManyAndReturnArgs} args - Arguments to create many ProxmoxMetrics.
     * @example
     * // Create many ProxmoxMetrics
     * const proxmoxMetric = await prisma.proxmoxMetric.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many ProxmoxMetrics and only return the `id`
     * const proxmoxMetricWithIdOnly = await prisma.proxmoxMetric.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ProxmoxMetricCreateManyAndReturnArgs>(args?: SelectSubset<T, ProxmoxMetricCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProxmoxMetricPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a ProxmoxMetric.
     * @param {ProxmoxMetricDeleteArgs} args - Arguments to delete one ProxmoxMetric.
     * @example
     * // Delete one ProxmoxMetric
     * const ProxmoxMetric = await prisma.proxmoxMetric.delete({
     *   where: {
     *     // ... filter to delete one ProxmoxMetric
     *   }
     * })
     * 
     */
    delete<T extends ProxmoxMetricDeleteArgs>(args: SelectSubset<T, ProxmoxMetricDeleteArgs<ExtArgs>>): Prisma__ProxmoxMetricClient<$Result.GetResult<Prisma.$ProxmoxMetricPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one ProxmoxMetric.
     * @param {ProxmoxMetricUpdateArgs} args - Arguments to update one ProxmoxMetric.
     * @example
     * // Update one ProxmoxMetric
     * const proxmoxMetric = await prisma.proxmoxMetric.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ProxmoxMetricUpdateArgs>(args: SelectSubset<T, ProxmoxMetricUpdateArgs<ExtArgs>>): Prisma__ProxmoxMetricClient<$Result.GetResult<Prisma.$ProxmoxMetricPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more ProxmoxMetrics.
     * @param {ProxmoxMetricDeleteManyArgs} args - Arguments to filter ProxmoxMetrics to delete.
     * @example
     * // Delete a few ProxmoxMetrics
     * const { count } = await prisma.proxmoxMetric.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ProxmoxMetricDeleteManyArgs>(args?: SelectSubset<T, ProxmoxMetricDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ProxmoxMetrics.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProxmoxMetricUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ProxmoxMetrics
     * const proxmoxMetric = await prisma.proxmoxMetric.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ProxmoxMetricUpdateManyArgs>(args: SelectSubset<T, ProxmoxMetricUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ProxmoxMetrics and returns the data updated in the database.
     * @param {ProxmoxMetricUpdateManyAndReturnArgs} args - Arguments to update many ProxmoxMetrics.
     * @example
     * // Update many ProxmoxMetrics
     * const proxmoxMetric = await prisma.proxmoxMetric.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more ProxmoxMetrics and only return the `id`
     * const proxmoxMetricWithIdOnly = await prisma.proxmoxMetric.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ProxmoxMetricUpdateManyAndReturnArgs>(args: SelectSubset<T, ProxmoxMetricUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProxmoxMetricPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one ProxmoxMetric.
     * @param {ProxmoxMetricUpsertArgs} args - Arguments to update or create a ProxmoxMetric.
     * @example
     * // Update or create a ProxmoxMetric
     * const proxmoxMetric = await prisma.proxmoxMetric.upsert({
     *   create: {
     *     // ... data to create a ProxmoxMetric
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ProxmoxMetric we want to update
     *   }
     * })
     */
    upsert<T extends ProxmoxMetricUpsertArgs>(args: SelectSubset<T, ProxmoxMetricUpsertArgs<ExtArgs>>): Prisma__ProxmoxMetricClient<$Result.GetResult<Prisma.$ProxmoxMetricPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of ProxmoxMetrics.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProxmoxMetricCountArgs} args - Arguments to filter ProxmoxMetrics to count.
     * @example
     * // Count the number of ProxmoxMetrics
     * const count = await prisma.proxmoxMetric.count({
     *   where: {
     *     // ... the filter for the ProxmoxMetrics we want to count
     *   }
     * })
    **/
    count<T extends ProxmoxMetricCountArgs>(
      args?: Subset<T, ProxmoxMetricCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ProxmoxMetricCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ProxmoxMetric.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProxmoxMetricAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ProxmoxMetricAggregateArgs>(args: Subset<T, ProxmoxMetricAggregateArgs>): Prisma.PrismaPromise<GetProxmoxMetricAggregateType<T>>

    /**
     * Group by ProxmoxMetric.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProxmoxMetricGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ProxmoxMetricGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ProxmoxMetricGroupByArgs['orderBy'] }
        : { orderBy?: ProxmoxMetricGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ProxmoxMetricGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetProxmoxMetricGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ProxmoxMetric model
   */
  readonly fields: ProxmoxMetricFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ProxmoxMetric.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ProxmoxMetricClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    vm<T extends ProxmoxMetric$vmArgs<ExtArgs> = {}>(args?: Subset<T, ProxmoxMetric$vmArgs<ExtArgs>>): Prisma__ProxmoxVMClient<$Result.GetResult<Prisma.$ProxmoxVMPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ProxmoxMetric model
   */
  interface ProxmoxMetricFieldRefs {
    readonly id: FieldRef<"ProxmoxMetric", 'String'>
    readonly vmId: FieldRef<"ProxmoxMetric", 'String'>
    readonly vmNumericId: FieldRef<"ProxmoxMetric", 'Int'>
    readonly nodeName: FieldRef<"ProxmoxMetric", 'String'>
    readonly serverId: FieldRef<"ProxmoxMetric", 'String'>
    readonly cpu: FieldRef<"ProxmoxMetric", 'Float'>
    readonly mem: FieldRef<"ProxmoxMetric", 'BigInt'>
    readonly disk: FieldRef<"ProxmoxMetric", 'Float'>
    readonly netin: FieldRef<"ProxmoxMetric", 'BigInt'>
    readonly netout: FieldRef<"ProxmoxMetric", 'BigInt'>
    readonly ts: FieldRef<"ProxmoxMetric", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * ProxmoxMetric findUnique
   */
  export type ProxmoxMetricFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProxmoxMetric
     */
    select?: ProxmoxMetricSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProxmoxMetric
     */
    omit?: ProxmoxMetricOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProxmoxMetricInclude<ExtArgs> | null
    /**
     * Filter, which ProxmoxMetric to fetch.
     */
    where: ProxmoxMetricWhereUniqueInput
  }

  /**
   * ProxmoxMetric findUniqueOrThrow
   */
  export type ProxmoxMetricFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProxmoxMetric
     */
    select?: ProxmoxMetricSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProxmoxMetric
     */
    omit?: ProxmoxMetricOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProxmoxMetricInclude<ExtArgs> | null
    /**
     * Filter, which ProxmoxMetric to fetch.
     */
    where: ProxmoxMetricWhereUniqueInput
  }

  /**
   * ProxmoxMetric findFirst
   */
  export type ProxmoxMetricFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProxmoxMetric
     */
    select?: ProxmoxMetricSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProxmoxMetric
     */
    omit?: ProxmoxMetricOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProxmoxMetricInclude<ExtArgs> | null
    /**
     * Filter, which ProxmoxMetric to fetch.
     */
    where?: ProxmoxMetricWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProxmoxMetrics to fetch.
     */
    orderBy?: ProxmoxMetricOrderByWithRelationInput | ProxmoxMetricOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ProxmoxMetrics.
     */
    cursor?: ProxmoxMetricWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProxmoxMetrics from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProxmoxMetrics.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ProxmoxMetrics.
     */
    distinct?: ProxmoxMetricScalarFieldEnum | ProxmoxMetricScalarFieldEnum[]
  }

  /**
   * ProxmoxMetric findFirstOrThrow
   */
  export type ProxmoxMetricFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProxmoxMetric
     */
    select?: ProxmoxMetricSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProxmoxMetric
     */
    omit?: ProxmoxMetricOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProxmoxMetricInclude<ExtArgs> | null
    /**
     * Filter, which ProxmoxMetric to fetch.
     */
    where?: ProxmoxMetricWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProxmoxMetrics to fetch.
     */
    orderBy?: ProxmoxMetricOrderByWithRelationInput | ProxmoxMetricOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ProxmoxMetrics.
     */
    cursor?: ProxmoxMetricWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProxmoxMetrics from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProxmoxMetrics.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ProxmoxMetrics.
     */
    distinct?: ProxmoxMetricScalarFieldEnum | ProxmoxMetricScalarFieldEnum[]
  }

  /**
   * ProxmoxMetric findMany
   */
  export type ProxmoxMetricFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProxmoxMetric
     */
    select?: ProxmoxMetricSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProxmoxMetric
     */
    omit?: ProxmoxMetricOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProxmoxMetricInclude<ExtArgs> | null
    /**
     * Filter, which ProxmoxMetrics to fetch.
     */
    where?: ProxmoxMetricWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProxmoxMetrics to fetch.
     */
    orderBy?: ProxmoxMetricOrderByWithRelationInput | ProxmoxMetricOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ProxmoxMetrics.
     */
    cursor?: ProxmoxMetricWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProxmoxMetrics from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProxmoxMetrics.
     */
    skip?: number
    distinct?: ProxmoxMetricScalarFieldEnum | ProxmoxMetricScalarFieldEnum[]
  }

  /**
   * ProxmoxMetric create
   */
  export type ProxmoxMetricCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProxmoxMetric
     */
    select?: ProxmoxMetricSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProxmoxMetric
     */
    omit?: ProxmoxMetricOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProxmoxMetricInclude<ExtArgs> | null
    /**
     * The data needed to create a ProxmoxMetric.
     */
    data?: XOR<ProxmoxMetricCreateInput, ProxmoxMetricUncheckedCreateInput>
  }

  /**
   * ProxmoxMetric createMany
   */
  export type ProxmoxMetricCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ProxmoxMetrics.
     */
    data: ProxmoxMetricCreateManyInput | ProxmoxMetricCreateManyInput[]
  }

  /**
   * ProxmoxMetric createManyAndReturn
   */
  export type ProxmoxMetricCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProxmoxMetric
     */
    select?: ProxmoxMetricSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ProxmoxMetric
     */
    omit?: ProxmoxMetricOmit<ExtArgs> | null
    /**
     * The data used to create many ProxmoxMetrics.
     */
    data: ProxmoxMetricCreateManyInput | ProxmoxMetricCreateManyInput[]
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProxmoxMetricIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * ProxmoxMetric update
   */
  export type ProxmoxMetricUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProxmoxMetric
     */
    select?: ProxmoxMetricSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProxmoxMetric
     */
    omit?: ProxmoxMetricOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProxmoxMetricInclude<ExtArgs> | null
    /**
     * The data needed to update a ProxmoxMetric.
     */
    data: XOR<ProxmoxMetricUpdateInput, ProxmoxMetricUncheckedUpdateInput>
    /**
     * Choose, which ProxmoxMetric to update.
     */
    where: ProxmoxMetricWhereUniqueInput
  }

  /**
   * ProxmoxMetric updateMany
   */
  export type ProxmoxMetricUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ProxmoxMetrics.
     */
    data: XOR<ProxmoxMetricUpdateManyMutationInput, ProxmoxMetricUncheckedUpdateManyInput>
    /**
     * Filter which ProxmoxMetrics to update
     */
    where?: ProxmoxMetricWhereInput
    /**
     * Limit how many ProxmoxMetrics to update.
     */
    limit?: number
  }

  /**
   * ProxmoxMetric updateManyAndReturn
   */
  export type ProxmoxMetricUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProxmoxMetric
     */
    select?: ProxmoxMetricSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ProxmoxMetric
     */
    omit?: ProxmoxMetricOmit<ExtArgs> | null
    /**
     * The data used to update ProxmoxMetrics.
     */
    data: XOR<ProxmoxMetricUpdateManyMutationInput, ProxmoxMetricUncheckedUpdateManyInput>
    /**
     * Filter which ProxmoxMetrics to update
     */
    where?: ProxmoxMetricWhereInput
    /**
     * Limit how many ProxmoxMetrics to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProxmoxMetricIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * ProxmoxMetric upsert
   */
  export type ProxmoxMetricUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProxmoxMetric
     */
    select?: ProxmoxMetricSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProxmoxMetric
     */
    omit?: ProxmoxMetricOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProxmoxMetricInclude<ExtArgs> | null
    /**
     * The filter to search for the ProxmoxMetric to update in case it exists.
     */
    where: ProxmoxMetricWhereUniqueInput
    /**
     * In case the ProxmoxMetric found by the `where` argument doesn't exist, create a new ProxmoxMetric with this data.
     */
    create: XOR<ProxmoxMetricCreateInput, ProxmoxMetricUncheckedCreateInput>
    /**
     * In case the ProxmoxMetric was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ProxmoxMetricUpdateInput, ProxmoxMetricUncheckedUpdateInput>
  }

  /**
   * ProxmoxMetric delete
   */
  export type ProxmoxMetricDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProxmoxMetric
     */
    select?: ProxmoxMetricSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProxmoxMetric
     */
    omit?: ProxmoxMetricOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProxmoxMetricInclude<ExtArgs> | null
    /**
     * Filter which ProxmoxMetric to delete.
     */
    where: ProxmoxMetricWhereUniqueInput
  }

  /**
   * ProxmoxMetric deleteMany
   */
  export type ProxmoxMetricDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ProxmoxMetrics to delete
     */
    where?: ProxmoxMetricWhereInput
    /**
     * Limit how many ProxmoxMetrics to delete.
     */
    limit?: number
  }

  /**
   * ProxmoxMetric.vm
   */
  export type ProxmoxMetric$vmArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProxmoxVM
     */
    select?: ProxmoxVMSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProxmoxVM
     */
    omit?: ProxmoxVMOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProxmoxVMInclude<ExtArgs> | null
    where?: ProxmoxVMWhereInput
  }

  /**
   * ProxmoxMetric without action
   */
  export type ProxmoxMetricDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProxmoxMetric
     */
    select?: ProxmoxMetricSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProxmoxMetric
     */
    omit?: ProxmoxMetricOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProxmoxMetricInclude<ExtArgs> | null
  }


  /**
   * Model Site
   */

  export type AggregateSite = {
    _count: SiteCountAggregateOutputType | null
    _min: SiteMinAggregateOutputType | null
    _max: SiteMaxAggregateOutputType | null
  }

  export type SiteMinAggregateOutputType = {
    id: string | null
    name: string | null
    address: string | null
    notes: string | null
    tags: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type SiteMaxAggregateOutputType = {
    id: string | null
    name: string | null
    address: string | null
    notes: string | null
    tags: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type SiteCountAggregateOutputType = {
    id: number
    name: number
    address: number
    notes: number
    tags: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type SiteMinAggregateInputType = {
    id?: true
    name?: true
    address?: true
    notes?: true
    tags?: true
    createdAt?: true
    updatedAt?: true
  }

  export type SiteMaxAggregateInputType = {
    id?: true
    name?: true
    address?: true
    notes?: true
    tags?: true
    createdAt?: true
    updatedAt?: true
  }

  export type SiteCountAggregateInputType = {
    id?: true
    name?: true
    address?: true
    notes?: true
    tags?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type SiteAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Site to aggregate.
     */
    where?: SiteWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Sites to fetch.
     */
    orderBy?: SiteOrderByWithRelationInput | SiteOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: SiteWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Sites from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Sites.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Sites
    **/
    _count?: true | SiteCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SiteMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SiteMaxAggregateInputType
  }

  export type GetSiteAggregateType<T extends SiteAggregateArgs> = {
        [P in keyof T & keyof AggregateSite]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSite[P]>
      : GetScalarType<T[P], AggregateSite[P]>
  }




  export type SiteGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SiteWhereInput
    orderBy?: SiteOrderByWithAggregationInput | SiteOrderByWithAggregationInput[]
    by: SiteScalarFieldEnum[] | SiteScalarFieldEnum
    having?: SiteScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SiteCountAggregateInputType | true
    _min?: SiteMinAggregateInputType
    _max?: SiteMaxAggregateInputType
  }

  export type SiteGroupByOutputType = {
    id: string
    name: string
    address: string | null
    notes: string | null
    tags: string | null
    createdAt: Date
    updatedAt: Date
    _count: SiteCountAggregateOutputType | null
    _min: SiteMinAggregateOutputType | null
    _max: SiteMaxAggregateOutputType | null
  }

  type GetSiteGroupByPayload<T extends SiteGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<SiteGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SiteGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SiteGroupByOutputType[P]>
            : GetScalarType<T[P], SiteGroupByOutputType[P]>
        }
      >
    >


  export type SiteSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    address?: boolean
    notes?: boolean
    tags?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    subnets?: boolean | Site$subnetsArgs<ExtArgs>
    devices?: boolean | Site$devicesArgs<ExtArgs>
    vlans?: boolean | Site$vlansArgs<ExtArgs>
    _count?: boolean | SiteCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["site"]>

  export type SiteSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    address?: boolean
    notes?: boolean
    tags?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["site"]>

  export type SiteSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    address?: boolean
    notes?: boolean
    tags?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["site"]>

  export type SiteSelectScalar = {
    id?: boolean
    name?: boolean
    address?: boolean
    notes?: boolean
    tags?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type SiteOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "address" | "notes" | "tags" | "createdAt" | "updatedAt", ExtArgs["result"]["site"]>
  export type SiteInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    subnets?: boolean | Site$subnetsArgs<ExtArgs>
    devices?: boolean | Site$devicesArgs<ExtArgs>
    vlans?: boolean | Site$vlansArgs<ExtArgs>
    _count?: boolean | SiteCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type SiteIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type SiteIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $SitePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Site"
    objects: {
      subnets: Prisma.$NetworkSubnetPayload<ExtArgs>[]
      devices: Prisma.$NetworkDevicePayload<ExtArgs>[]
      vlans: Prisma.$VlanPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      address: string | null
      notes: string | null
      tags: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["site"]>
    composites: {}
  }

  type SiteGetPayload<S extends boolean | null | undefined | SiteDefaultArgs> = $Result.GetResult<Prisma.$SitePayload, S>

  type SiteCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<SiteFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: SiteCountAggregateInputType | true
    }

  export interface SiteDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Site'], meta: { name: 'Site' } }
    /**
     * Find zero or one Site that matches the filter.
     * @param {SiteFindUniqueArgs} args - Arguments to find a Site
     * @example
     * // Get one Site
     * const site = await prisma.site.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends SiteFindUniqueArgs>(args: SelectSubset<T, SiteFindUniqueArgs<ExtArgs>>): Prisma__SiteClient<$Result.GetResult<Prisma.$SitePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Site that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {SiteFindUniqueOrThrowArgs} args - Arguments to find a Site
     * @example
     * // Get one Site
     * const site = await prisma.site.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends SiteFindUniqueOrThrowArgs>(args: SelectSubset<T, SiteFindUniqueOrThrowArgs<ExtArgs>>): Prisma__SiteClient<$Result.GetResult<Prisma.$SitePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Site that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SiteFindFirstArgs} args - Arguments to find a Site
     * @example
     * // Get one Site
     * const site = await prisma.site.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends SiteFindFirstArgs>(args?: SelectSubset<T, SiteFindFirstArgs<ExtArgs>>): Prisma__SiteClient<$Result.GetResult<Prisma.$SitePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Site that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SiteFindFirstOrThrowArgs} args - Arguments to find a Site
     * @example
     * // Get one Site
     * const site = await prisma.site.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends SiteFindFirstOrThrowArgs>(args?: SelectSubset<T, SiteFindFirstOrThrowArgs<ExtArgs>>): Prisma__SiteClient<$Result.GetResult<Prisma.$SitePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Sites that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SiteFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Sites
     * const sites = await prisma.site.findMany()
     * 
     * // Get first 10 Sites
     * const sites = await prisma.site.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const siteWithIdOnly = await prisma.site.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends SiteFindManyArgs>(args?: SelectSubset<T, SiteFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SitePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Site.
     * @param {SiteCreateArgs} args - Arguments to create a Site.
     * @example
     * // Create one Site
     * const Site = await prisma.site.create({
     *   data: {
     *     // ... data to create a Site
     *   }
     * })
     * 
     */
    create<T extends SiteCreateArgs>(args: SelectSubset<T, SiteCreateArgs<ExtArgs>>): Prisma__SiteClient<$Result.GetResult<Prisma.$SitePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Sites.
     * @param {SiteCreateManyArgs} args - Arguments to create many Sites.
     * @example
     * // Create many Sites
     * const site = await prisma.site.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends SiteCreateManyArgs>(args?: SelectSubset<T, SiteCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Sites and returns the data saved in the database.
     * @param {SiteCreateManyAndReturnArgs} args - Arguments to create many Sites.
     * @example
     * // Create many Sites
     * const site = await prisma.site.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Sites and only return the `id`
     * const siteWithIdOnly = await prisma.site.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends SiteCreateManyAndReturnArgs>(args?: SelectSubset<T, SiteCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SitePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Site.
     * @param {SiteDeleteArgs} args - Arguments to delete one Site.
     * @example
     * // Delete one Site
     * const Site = await prisma.site.delete({
     *   where: {
     *     // ... filter to delete one Site
     *   }
     * })
     * 
     */
    delete<T extends SiteDeleteArgs>(args: SelectSubset<T, SiteDeleteArgs<ExtArgs>>): Prisma__SiteClient<$Result.GetResult<Prisma.$SitePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Site.
     * @param {SiteUpdateArgs} args - Arguments to update one Site.
     * @example
     * // Update one Site
     * const site = await prisma.site.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends SiteUpdateArgs>(args: SelectSubset<T, SiteUpdateArgs<ExtArgs>>): Prisma__SiteClient<$Result.GetResult<Prisma.$SitePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Sites.
     * @param {SiteDeleteManyArgs} args - Arguments to filter Sites to delete.
     * @example
     * // Delete a few Sites
     * const { count } = await prisma.site.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends SiteDeleteManyArgs>(args?: SelectSubset<T, SiteDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Sites.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SiteUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Sites
     * const site = await prisma.site.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends SiteUpdateManyArgs>(args: SelectSubset<T, SiteUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Sites and returns the data updated in the database.
     * @param {SiteUpdateManyAndReturnArgs} args - Arguments to update many Sites.
     * @example
     * // Update many Sites
     * const site = await prisma.site.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Sites and only return the `id`
     * const siteWithIdOnly = await prisma.site.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends SiteUpdateManyAndReturnArgs>(args: SelectSubset<T, SiteUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SitePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Site.
     * @param {SiteUpsertArgs} args - Arguments to update or create a Site.
     * @example
     * // Update or create a Site
     * const site = await prisma.site.upsert({
     *   create: {
     *     // ... data to create a Site
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Site we want to update
     *   }
     * })
     */
    upsert<T extends SiteUpsertArgs>(args: SelectSubset<T, SiteUpsertArgs<ExtArgs>>): Prisma__SiteClient<$Result.GetResult<Prisma.$SitePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Sites.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SiteCountArgs} args - Arguments to filter Sites to count.
     * @example
     * // Count the number of Sites
     * const count = await prisma.site.count({
     *   where: {
     *     // ... the filter for the Sites we want to count
     *   }
     * })
    **/
    count<T extends SiteCountArgs>(
      args?: Subset<T, SiteCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SiteCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Site.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SiteAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SiteAggregateArgs>(args: Subset<T, SiteAggregateArgs>): Prisma.PrismaPromise<GetSiteAggregateType<T>>

    /**
     * Group by Site.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SiteGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends SiteGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: SiteGroupByArgs['orderBy'] }
        : { orderBy?: SiteGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, SiteGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSiteGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Site model
   */
  readonly fields: SiteFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Site.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__SiteClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    subnets<T extends Site$subnetsArgs<ExtArgs> = {}>(args?: Subset<T, Site$subnetsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$NetworkSubnetPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    devices<T extends Site$devicesArgs<ExtArgs> = {}>(args?: Subset<T, Site$devicesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$NetworkDevicePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    vlans<T extends Site$vlansArgs<ExtArgs> = {}>(args?: Subset<T, Site$vlansArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$VlanPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Site model
   */
  interface SiteFieldRefs {
    readonly id: FieldRef<"Site", 'String'>
    readonly name: FieldRef<"Site", 'String'>
    readonly address: FieldRef<"Site", 'String'>
    readonly notes: FieldRef<"Site", 'String'>
    readonly tags: FieldRef<"Site", 'String'>
    readonly createdAt: FieldRef<"Site", 'DateTime'>
    readonly updatedAt: FieldRef<"Site", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Site findUnique
   */
  export type SiteFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Site
     */
    select?: SiteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Site
     */
    omit?: SiteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SiteInclude<ExtArgs> | null
    /**
     * Filter, which Site to fetch.
     */
    where: SiteWhereUniqueInput
  }

  /**
   * Site findUniqueOrThrow
   */
  export type SiteFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Site
     */
    select?: SiteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Site
     */
    omit?: SiteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SiteInclude<ExtArgs> | null
    /**
     * Filter, which Site to fetch.
     */
    where: SiteWhereUniqueInput
  }

  /**
   * Site findFirst
   */
  export type SiteFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Site
     */
    select?: SiteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Site
     */
    omit?: SiteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SiteInclude<ExtArgs> | null
    /**
     * Filter, which Site to fetch.
     */
    where?: SiteWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Sites to fetch.
     */
    orderBy?: SiteOrderByWithRelationInput | SiteOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Sites.
     */
    cursor?: SiteWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Sites from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Sites.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Sites.
     */
    distinct?: SiteScalarFieldEnum | SiteScalarFieldEnum[]
  }

  /**
   * Site findFirstOrThrow
   */
  export type SiteFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Site
     */
    select?: SiteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Site
     */
    omit?: SiteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SiteInclude<ExtArgs> | null
    /**
     * Filter, which Site to fetch.
     */
    where?: SiteWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Sites to fetch.
     */
    orderBy?: SiteOrderByWithRelationInput | SiteOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Sites.
     */
    cursor?: SiteWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Sites from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Sites.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Sites.
     */
    distinct?: SiteScalarFieldEnum | SiteScalarFieldEnum[]
  }

  /**
   * Site findMany
   */
  export type SiteFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Site
     */
    select?: SiteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Site
     */
    omit?: SiteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SiteInclude<ExtArgs> | null
    /**
     * Filter, which Sites to fetch.
     */
    where?: SiteWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Sites to fetch.
     */
    orderBy?: SiteOrderByWithRelationInput | SiteOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Sites.
     */
    cursor?: SiteWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Sites from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Sites.
     */
    skip?: number
    distinct?: SiteScalarFieldEnum | SiteScalarFieldEnum[]
  }

  /**
   * Site create
   */
  export type SiteCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Site
     */
    select?: SiteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Site
     */
    omit?: SiteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SiteInclude<ExtArgs> | null
    /**
     * The data needed to create a Site.
     */
    data: XOR<SiteCreateInput, SiteUncheckedCreateInput>
  }

  /**
   * Site createMany
   */
  export type SiteCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Sites.
     */
    data: SiteCreateManyInput | SiteCreateManyInput[]
  }

  /**
   * Site createManyAndReturn
   */
  export type SiteCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Site
     */
    select?: SiteSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Site
     */
    omit?: SiteOmit<ExtArgs> | null
    /**
     * The data used to create many Sites.
     */
    data: SiteCreateManyInput | SiteCreateManyInput[]
  }

  /**
   * Site update
   */
  export type SiteUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Site
     */
    select?: SiteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Site
     */
    omit?: SiteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SiteInclude<ExtArgs> | null
    /**
     * The data needed to update a Site.
     */
    data: XOR<SiteUpdateInput, SiteUncheckedUpdateInput>
    /**
     * Choose, which Site to update.
     */
    where: SiteWhereUniqueInput
  }

  /**
   * Site updateMany
   */
  export type SiteUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Sites.
     */
    data: XOR<SiteUpdateManyMutationInput, SiteUncheckedUpdateManyInput>
    /**
     * Filter which Sites to update
     */
    where?: SiteWhereInput
    /**
     * Limit how many Sites to update.
     */
    limit?: number
  }

  /**
   * Site updateManyAndReturn
   */
  export type SiteUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Site
     */
    select?: SiteSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Site
     */
    omit?: SiteOmit<ExtArgs> | null
    /**
     * The data used to update Sites.
     */
    data: XOR<SiteUpdateManyMutationInput, SiteUncheckedUpdateManyInput>
    /**
     * Filter which Sites to update
     */
    where?: SiteWhereInput
    /**
     * Limit how many Sites to update.
     */
    limit?: number
  }

  /**
   * Site upsert
   */
  export type SiteUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Site
     */
    select?: SiteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Site
     */
    omit?: SiteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SiteInclude<ExtArgs> | null
    /**
     * The filter to search for the Site to update in case it exists.
     */
    where: SiteWhereUniqueInput
    /**
     * In case the Site found by the `where` argument doesn't exist, create a new Site with this data.
     */
    create: XOR<SiteCreateInput, SiteUncheckedCreateInput>
    /**
     * In case the Site was found with the provided `where` argument, update it with this data.
     */
    update: XOR<SiteUpdateInput, SiteUncheckedUpdateInput>
  }

  /**
   * Site delete
   */
  export type SiteDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Site
     */
    select?: SiteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Site
     */
    omit?: SiteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SiteInclude<ExtArgs> | null
    /**
     * Filter which Site to delete.
     */
    where: SiteWhereUniqueInput
  }

  /**
   * Site deleteMany
   */
  export type SiteDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Sites to delete
     */
    where?: SiteWhereInput
    /**
     * Limit how many Sites to delete.
     */
    limit?: number
  }

  /**
   * Site.subnets
   */
  export type Site$subnetsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NetworkSubnet
     */
    select?: NetworkSubnetSelect<ExtArgs> | null
    /**
     * Omit specific fields from the NetworkSubnet
     */
    omit?: NetworkSubnetOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NetworkSubnetInclude<ExtArgs> | null
    where?: NetworkSubnetWhereInput
    orderBy?: NetworkSubnetOrderByWithRelationInput | NetworkSubnetOrderByWithRelationInput[]
    cursor?: NetworkSubnetWhereUniqueInput
    take?: number
    skip?: number
    distinct?: NetworkSubnetScalarFieldEnum | NetworkSubnetScalarFieldEnum[]
  }

  /**
   * Site.devices
   */
  export type Site$devicesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NetworkDevice
     */
    select?: NetworkDeviceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the NetworkDevice
     */
    omit?: NetworkDeviceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NetworkDeviceInclude<ExtArgs> | null
    where?: NetworkDeviceWhereInput
    orderBy?: NetworkDeviceOrderByWithRelationInput | NetworkDeviceOrderByWithRelationInput[]
    cursor?: NetworkDeviceWhereUniqueInput
    take?: number
    skip?: number
    distinct?: NetworkDeviceScalarFieldEnum | NetworkDeviceScalarFieldEnum[]
  }

  /**
   * Site.vlans
   */
  export type Site$vlansArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Vlan
     */
    select?: VlanSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Vlan
     */
    omit?: VlanOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VlanInclude<ExtArgs> | null
    where?: VlanWhereInput
    orderBy?: VlanOrderByWithRelationInput | VlanOrderByWithRelationInput[]
    cursor?: VlanWhereUniqueInput
    take?: number
    skip?: number
    distinct?: VlanScalarFieldEnum | VlanScalarFieldEnum[]
  }

  /**
   * Site without action
   */
  export type SiteDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Site
     */
    select?: SiteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Site
     */
    omit?: SiteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SiteInclude<ExtArgs> | null
  }


  /**
   * Model Vlan
   */

  export type AggregateVlan = {
    _count: VlanCountAggregateOutputType | null
    _avg: VlanAvgAggregateOutputType | null
    _sum: VlanSumAggregateOutputType | null
    _min: VlanMinAggregateOutputType | null
    _max: VlanMaxAggregateOutputType | null
  }

  export type VlanAvgAggregateOutputType = {
    vid: number | null
  }

  export type VlanSumAggregateOutputType = {
    vid: number | null
  }

  export type VlanMinAggregateOutputType = {
    id: string | null
    name: string | null
    vid: number | null
    siteId: string | null
    description: string | null
    tags: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type VlanMaxAggregateOutputType = {
    id: string | null
    name: string | null
    vid: number | null
    siteId: string | null
    description: string | null
    tags: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type VlanCountAggregateOutputType = {
    id: number
    name: number
    vid: number
    siteId: number
    description: number
    tags: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type VlanAvgAggregateInputType = {
    vid?: true
  }

  export type VlanSumAggregateInputType = {
    vid?: true
  }

  export type VlanMinAggregateInputType = {
    id?: true
    name?: true
    vid?: true
    siteId?: true
    description?: true
    tags?: true
    createdAt?: true
    updatedAt?: true
  }

  export type VlanMaxAggregateInputType = {
    id?: true
    name?: true
    vid?: true
    siteId?: true
    description?: true
    tags?: true
    createdAt?: true
    updatedAt?: true
  }

  export type VlanCountAggregateInputType = {
    id?: true
    name?: true
    vid?: true
    siteId?: true
    description?: true
    tags?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type VlanAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Vlan to aggregate.
     */
    where?: VlanWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Vlans to fetch.
     */
    orderBy?: VlanOrderByWithRelationInput | VlanOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: VlanWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Vlans from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Vlans.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Vlans
    **/
    _count?: true | VlanCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: VlanAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: VlanSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: VlanMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: VlanMaxAggregateInputType
  }

  export type GetVlanAggregateType<T extends VlanAggregateArgs> = {
        [P in keyof T & keyof AggregateVlan]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateVlan[P]>
      : GetScalarType<T[P], AggregateVlan[P]>
  }




  export type VlanGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: VlanWhereInput
    orderBy?: VlanOrderByWithAggregationInput | VlanOrderByWithAggregationInput[]
    by: VlanScalarFieldEnum[] | VlanScalarFieldEnum
    having?: VlanScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: VlanCountAggregateInputType | true
    _avg?: VlanAvgAggregateInputType
    _sum?: VlanSumAggregateInputType
    _min?: VlanMinAggregateInputType
    _max?: VlanMaxAggregateInputType
  }

  export type VlanGroupByOutputType = {
    id: string
    name: string
    vid: number
    siteId: string | null
    description: string | null
    tags: string | null
    createdAt: Date
    updatedAt: Date
    _count: VlanCountAggregateOutputType | null
    _avg: VlanAvgAggregateOutputType | null
    _sum: VlanSumAggregateOutputType | null
    _min: VlanMinAggregateOutputType | null
    _max: VlanMaxAggregateOutputType | null
  }

  type GetVlanGroupByPayload<T extends VlanGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<VlanGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof VlanGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], VlanGroupByOutputType[P]>
            : GetScalarType<T[P], VlanGroupByOutputType[P]>
        }
      >
    >


  export type VlanSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    vid?: boolean
    siteId?: boolean
    description?: boolean
    tags?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    site?: boolean | Vlan$siteArgs<ExtArgs>
    subnets?: boolean | Vlan$subnetsArgs<ExtArgs>
    _count?: boolean | VlanCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["vlan"]>

  export type VlanSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    vid?: boolean
    siteId?: boolean
    description?: boolean
    tags?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    site?: boolean | Vlan$siteArgs<ExtArgs>
  }, ExtArgs["result"]["vlan"]>

  export type VlanSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    vid?: boolean
    siteId?: boolean
    description?: boolean
    tags?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    site?: boolean | Vlan$siteArgs<ExtArgs>
  }, ExtArgs["result"]["vlan"]>

  export type VlanSelectScalar = {
    id?: boolean
    name?: boolean
    vid?: boolean
    siteId?: boolean
    description?: boolean
    tags?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type VlanOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "vid" | "siteId" | "description" | "tags" | "createdAt" | "updatedAt", ExtArgs["result"]["vlan"]>
  export type VlanInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    site?: boolean | Vlan$siteArgs<ExtArgs>
    subnets?: boolean | Vlan$subnetsArgs<ExtArgs>
    _count?: boolean | VlanCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type VlanIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    site?: boolean | Vlan$siteArgs<ExtArgs>
  }
  export type VlanIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    site?: boolean | Vlan$siteArgs<ExtArgs>
  }

  export type $VlanPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Vlan"
    objects: {
      site: Prisma.$SitePayload<ExtArgs> | null
      subnets: Prisma.$NetworkSubnetPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      vid: number
      siteId: string | null
      description: string | null
      tags: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["vlan"]>
    composites: {}
  }

  type VlanGetPayload<S extends boolean | null | undefined | VlanDefaultArgs> = $Result.GetResult<Prisma.$VlanPayload, S>

  type VlanCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<VlanFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: VlanCountAggregateInputType | true
    }

  export interface VlanDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Vlan'], meta: { name: 'Vlan' } }
    /**
     * Find zero or one Vlan that matches the filter.
     * @param {VlanFindUniqueArgs} args - Arguments to find a Vlan
     * @example
     * // Get one Vlan
     * const vlan = await prisma.vlan.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends VlanFindUniqueArgs>(args: SelectSubset<T, VlanFindUniqueArgs<ExtArgs>>): Prisma__VlanClient<$Result.GetResult<Prisma.$VlanPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Vlan that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {VlanFindUniqueOrThrowArgs} args - Arguments to find a Vlan
     * @example
     * // Get one Vlan
     * const vlan = await prisma.vlan.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends VlanFindUniqueOrThrowArgs>(args: SelectSubset<T, VlanFindUniqueOrThrowArgs<ExtArgs>>): Prisma__VlanClient<$Result.GetResult<Prisma.$VlanPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Vlan that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VlanFindFirstArgs} args - Arguments to find a Vlan
     * @example
     * // Get one Vlan
     * const vlan = await prisma.vlan.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends VlanFindFirstArgs>(args?: SelectSubset<T, VlanFindFirstArgs<ExtArgs>>): Prisma__VlanClient<$Result.GetResult<Prisma.$VlanPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Vlan that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VlanFindFirstOrThrowArgs} args - Arguments to find a Vlan
     * @example
     * // Get one Vlan
     * const vlan = await prisma.vlan.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends VlanFindFirstOrThrowArgs>(args?: SelectSubset<T, VlanFindFirstOrThrowArgs<ExtArgs>>): Prisma__VlanClient<$Result.GetResult<Prisma.$VlanPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Vlans that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VlanFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Vlans
     * const vlans = await prisma.vlan.findMany()
     * 
     * // Get first 10 Vlans
     * const vlans = await prisma.vlan.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const vlanWithIdOnly = await prisma.vlan.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends VlanFindManyArgs>(args?: SelectSubset<T, VlanFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$VlanPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Vlan.
     * @param {VlanCreateArgs} args - Arguments to create a Vlan.
     * @example
     * // Create one Vlan
     * const Vlan = await prisma.vlan.create({
     *   data: {
     *     // ... data to create a Vlan
     *   }
     * })
     * 
     */
    create<T extends VlanCreateArgs>(args: SelectSubset<T, VlanCreateArgs<ExtArgs>>): Prisma__VlanClient<$Result.GetResult<Prisma.$VlanPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Vlans.
     * @param {VlanCreateManyArgs} args - Arguments to create many Vlans.
     * @example
     * // Create many Vlans
     * const vlan = await prisma.vlan.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends VlanCreateManyArgs>(args?: SelectSubset<T, VlanCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Vlans and returns the data saved in the database.
     * @param {VlanCreateManyAndReturnArgs} args - Arguments to create many Vlans.
     * @example
     * // Create many Vlans
     * const vlan = await prisma.vlan.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Vlans and only return the `id`
     * const vlanWithIdOnly = await prisma.vlan.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends VlanCreateManyAndReturnArgs>(args?: SelectSubset<T, VlanCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$VlanPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Vlan.
     * @param {VlanDeleteArgs} args - Arguments to delete one Vlan.
     * @example
     * // Delete one Vlan
     * const Vlan = await prisma.vlan.delete({
     *   where: {
     *     // ... filter to delete one Vlan
     *   }
     * })
     * 
     */
    delete<T extends VlanDeleteArgs>(args: SelectSubset<T, VlanDeleteArgs<ExtArgs>>): Prisma__VlanClient<$Result.GetResult<Prisma.$VlanPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Vlan.
     * @param {VlanUpdateArgs} args - Arguments to update one Vlan.
     * @example
     * // Update one Vlan
     * const vlan = await prisma.vlan.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends VlanUpdateArgs>(args: SelectSubset<T, VlanUpdateArgs<ExtArgs>>): Prisma__VlanClient<$Result.GetResult<Prisma.$VlanPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Vlans.
     * @param {VlanDeleteManyArgs} args - Arguments to filter Vlans to delete.
     * @example
     * // Delete a few Vlans
     * const { count } = await prisma.vlan.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends VlanDeleteManyArgs>(args?: SelectSubset<T, VlanDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Vlans.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VlanUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Vlans
     * const vlan = await prisma.vlan.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends VlanUpdateManyArgs>(args: SelectSubset<T, VlanUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Vlans and returns the data updated in the database.
     * @param {VlanUpdateManyAndReturnArgs} args - Arguments to update many Vlans.
     * @example
     * // Update many Vlans
     * const vlan = await prisma.vlan.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Vlans and only return the `id`
     * const vlanWithIdOnly = await prisma.vlan.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends VlanUpdateManyAndReturnArgs>(args: SelectSubset<T, VlanUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$VlanPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Vlan.
     * @param {VlanUpsertArgs} args - Arguments to update or create a Vlan.
     * @example
     * // Update or create a Vlan
     * const vlan = await prisma.vlan.upsert({
     *   create: {
     *     // ... data to create a Vlan
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Vlan we want to update
     *   }
     * })
     */
    upsert<T extends VlanUpsertArgs>(args: SelectSubset<T, VlanUpsertArgs<ExtArgs>>): Prisma__VlanClient<$Result.GetResult<Prisma.$VlanPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Vlans.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VlanCountArgs} args - Arguments to filter Vlans to count.
     * @example
     * // Count the number of Vlans
     * const count = await prisma.vlan.count({
     *   where: {
     *     // ... the filter for the Vlans we want to count
     *   }
     * })
    **/
    count<T extends VlanCountArgs>(
      args?: Subset<T, VlanCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], VlanCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Vlan.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VlanAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends VlanAggregateArgs>(args: Subset<T, VlanAggregateArgs>): Prisma.PrismaPromise<GetVlanAggregateType<T>>

    /**
     * Group by Vlan.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VlanGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends VlanGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: VlanGroupByArgs['orderBy'] }
        : { orderBy?: VlanGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, VlanGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetVlanGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Vlan model
   */
  readonly fields: VlanFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Vlan.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__VlanClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    site<T extends Vlan$siteArgs<ExtArgs> = {}>(args?: Subset<T, Vlan$siteArgs<ExtArgs>>): Prisma__SiteClient<$Result.GetResult<Prisma.$SitePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    subnets<T extends Vlan$subnetsArgs<ExtArgs> = {}>(args?: Subset<T, Vlan$subnetsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$NetworkSubnetPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Vlan model
   */
  interface VlanFieldRefs {
    readonly id: FieldRef<"Vlan", 'String'>
    readonly name: FieldRef<"Vlan", 'String'>
    readonly vid: FieldRef<"Vlan", 'Int'>
    readonly siteId: FieldRef<"Vlan", 'String'>
    readonly description: FieldRef<"Vlan", 'String'>
    readonly tags: FieldRef<"Vlan", 'String'>
    readonly createdAt: FieldRef<"Vlan", 'DateTime'>
    readonly updatedAt: FieldRef<"Vlan", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Vlan findUnique
   */
  export type VlanFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Vlan
     */
    select?: VlanSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Vlan
     */
    omit?: VlanOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VlanInclude<ExtArgs> | null
    /**
     * Filter, which Vlan to fetch.
     */
    where: VlanWhereUniqueInput
  }

  /**
   * Vlan findUniqueOrThrow
   */
  export type VlanFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Vlan
     */
    select?: VlanSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Vlan
     */
    omit?: VlanOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VlanInclude<ExtArgs> | null
    /**
     * Filter, which Vlan to fetch.
     */
    where: VlanWhereUniqueInput
  }

  /**
   * Vlan findFirst
   */
  export type VlanFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Vlan
     */
    select?: VlanSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Vlan
     */
    omit?: VlanOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VlanInclude<ExtArgs> | null
    /**
     * Filter, which Vlan to fetch.
     */
    where?: VlanWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Vlans to fetch.
     */
    orderBy?: VlanOrderByWithRelationInput | VlanOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Vlans.
     */
    cursor?: VlanWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Vlans from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Vlans.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Vlans.
     */
    distinct?: VlanScalarFieldEnum | VlanScalarFieldEnum[]
  }

  /**
   * Vlan findFirstOrThrow
   */
  export type VlanFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Vlan
     */
    select?: VlanSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Vlan
     */
    omit?: VlanOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VlanInclude<ExtArgs> | null
    /**
     * Filter, which Vlan to fetch.
     */
    where?: VlanWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Vlans to fetch.
     */
    orderBy?: VlanOrderByWithRelationInput | VlanOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Vlans.
     */
    cursor?: VlanWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Vlans from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Vlans.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Vlans.
     */
    distinct?: VlanScalarFieldEnum | VlanScalarFieldEnum[]
  }

  /**
   * Vlan findMany
   */
  export type VlanFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Vlan
     */
    select?: VlanSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Vlan
     */
    omit?: VlanOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VlanInclude<ExtArgs> | null
    /**
     * Filter, which Vlans to fetch.
     */
    where?: VlanWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Vlans to fetch.
     */
    orderBy?: VlanOrderByWithRelationInput | VlanOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Vlans.
     */
    cursor?: VlanWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Vlans from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Vlans.
     */
    skip?: number
    distinct?: VlanScalarFieldEnum | VlanScalarFieldEnum[]
  }

  /**
   * Vlan create
   */
  export type VlanCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Vlan
     */
    select?: VlanSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Vlan
     */
    omit?: VlanOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VlanInclude<ExtArgs> | null
    /**
     * The data needed to create a Vlan.
     */
    data: XOR<VlanCreateInput, VlanUncheckedCreateInput>
  }

  /**
   * Vlan createMany
   */
  export type VlanCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Vlans.
     */
    data: VlanCreateManyInput | VlanCreateManyInput[]
  }

  /**
   * Vlan createManyAndReturn
   */
  export type VlanCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Vlan
     */
    select?: VlanSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Vlan
     */
    omit?: VlanOmit<ExtArgs> | null
    /**
     * The data used to create many Vlans.
     */
    data: VlanCreateManyInput | VlanCreateManyInput[]
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VlanIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Vlan update
   */
  export type VlanUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Vlan
     */
    select?: VlanSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Vlan
     */
    omit?: VlanOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VlanInclude<ExtArgs> | null
    /**
     * The data needed to update a Vlan.
     */
    data: XOR<VlanUpdateInput, VlanUncheckedUpdateInput>
    /**
     * Choose, which Vlan to update.
     */
    where: VlanWhereUniqueInput
  }

  /**
   * Vlan updateMany
   */
  export type VlanUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Vlans.
     */
    data: XOR<VlanUpdateManyMutationInput, VlanUncheckedUpdateManyInput>
    /**
     * Filter which Vlans to update
     */
    where?: VlanWhereInput
    /**
     * Limit how many Vlans to update.
     */
    limit?: number
  }

  /**
   * Vlan updateManyAndReturn
   */
  export type VlanUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Vlan
     */
    select?: VlanSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Vlan
     */
    omit?: VlanOmit<ExtArgs> | null
    /**
     * The data used to update Vlans.
     */
    data: XOR<VlanUpdateManyMutationInput, VlanUncheckedUpdateManyInput>
    /**
     * Filter which Vlans to update
     */
    where?: VlanWhereInput
    /**
     * Limit how many Vlans to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VlanIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Vlan upsert
   */
  export type VlanUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Vlan
     */
    select?: VlanSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Vlan
     */
    omit?: VlanOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VlanInclude<ExtArgs> | null
    /**
     * The filter to search for the Vlan to update in case it exists.
     */
    where: VlanWhereUniqueInput
    /**
     * In case the Vlan found by the `where` argument doesn't exist, create a new Vlan with this data.
     */
    create: XOR<VlanCreateInput, VlanUncheckedCreateInput>
    /**
     * In case the Vlan was found with the provided `where` argument, update it with this data.
     */
    update: XOR<VlanUpdateInput, VlanUncheckedUpdateInput>
  }

  /**
   * Vlan delete
   */
  export type VlanDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Vlan
     */
    select?: VlanSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Vlan
     */
    omit?: VlanOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VlanInclude<ExtArgs> | null
    /**
     * Filter which Vlan to delete.
     */
    where: VlanWhereUniqueInput
  }

  /**
   * Vlan deleteMany
   */
  export type VlanDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Vlans to delete
     */
    where?: VlanWhereInput
    /**
     * Limit how many Vlans to delete.
     */
    limit?: number
  }

  /**
   * Vlan.site
   */
  export type Vlan$siteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Site
     */
    select?: SiteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Site
     */
    omit?: SiteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SiteInclude<ExtArgs> | null
    where?: SiteWhereInput
  }

  /**
   * Vlan.subnets
   */
  export type Vlan$subnetsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NetworkSubnet
     */
    select?: NetworkSubnetSelect<ExtArgs> | null
    /**
     * Omit specific fields from the NetworkSubnet
     */
    omit?: NetworkSubnetOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NetworkSubnetInclude<ExtArgs> | null
    where?: NetworkSubnetWhereInput
    orderBy?: NetworkSubnetOrderByWithRelationInput | NetworkSubnetOrderByWithRelationInput[]
    cursor?: NetworkSubnetWhereUniqueInput
    take?: number
    skip?: number
    distinct?: NetworkSubnetScalarFieldEnum | NetworkSubnetScalarFieldEnum[]
  }

  /**
   * Vlan without action
   */
  export type VlanDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Vlan
     */
    select?: VlanSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Vlan
     */
    omit?: VlanOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VlanInclude<ExtArgs> | null
  }


  /**
   * Model NetworkSubnet
   */

  export type AggregateNetworkSubnet = {
    _count: NetworkSubnetCountAggregateOutputType | null
    _min: NetworkSubnetMinAggregateOutputType | null
    _max: NetworkSubnetMaxAggregateOutputType | null
  }

  export type NetworkSubnetMinAggregateOutputType = {
    id: string | null
    cidr: string | null
    name: string | null
    description: string | null
    siteId: string | null
    vlanId: string | null
    parentId: string | null
    gatewayIpId: string | null
    tags: string | null
    notes: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type NetworkSubnetMaxAggregateOutputType = {
    id: string | null
    cidr: string | null
    name: string | null
    description: string | null
    siteId: string | null
    vlanId: string | null
    parentId: string | null
    gatewayIpId: string | null
    tags: string | null
    notes: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type NetworkSubnetCountAggregateOutputType = {
    id: number
    cidr: number
    name: number
    description: number
    siteId: number
    vlanId: number
    parentId: number
    gatewayIpId: number
    tags: number
    notes: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type NetworkSubnetMinAggregateInputType = {
    id?: true
    cidr?: true
    name?: true
    description?: true
    siteId?: true
    vlanId?: true
    parentId?: true
    gatewayIpId?: true
    tags?: true
    notes?: true
    createdAt?: true
    updatedAt?: true
  }

  export type NetworkSubnetMaxAggregateInputType = {
    id?: true
    cidr?: true
    name?: true
    description?: true
    siteId?: true
    vlanId?: true
    parentId?: true
    gatewayIpId?: true
    tags?: true
    notes?: true
    createdAt?: true
    updatedAt?: true
  }

  export type NetworkSubnetCountAggregateInputType = {
    id?: true
    cidr?: true
    name?: true
    description?: true
    siteId?: true
    vlanId?: true
    parentId?: true
    gatewayIpId?: true
    tags?: true
    notes?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type NetworkSubnetAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which NetworkSubnet to aggregate.
     */
    where?: NetworkSubnetWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of NetworkSubnets to fetch.
     */
    orderBy?: NetworkSubnetOrderByWithRelationInput | NetworkSubnetOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: NetworkSubnetWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` NetworkSubnets from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` NetworkSubnets.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned NetworkSubnets
    **/
    _count?: true | NetworkSubnetCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: NetworkSubnetMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: NetworkSubnetMaxAggregateInputType
  }

  export type GetNetworkSubnetAggregateType<T extends NetworkSubnetAggregateArgs> = {
        [P in keyof T & keyof AggregateNetworkSubnet]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateNetworkSubnet[P]>
      : GetScalarType<T[P], AggregateNetworkSubnet[P]>
  }




  export type NetworkSubnetGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: NetworkSubnetWhereInput
    orderBy?: NetworkSubnetOrderByWithAggregationInput | NetworkSubnetOrderByWithAggregationInput[]
    by: NetworkSubnetScalarFieldEnum[] | NetworkSubnetScalarFieldEnum
    having?: NetworkSubnetScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: NetworkSubnetCountAggregateInputType | true
    _min?: NetworkSubnetMinAggregateInputType
    _max?: NetworkSubnetMaxAggregateInputType
  }

  export type NetworkSubnetGroupByOutputType = {
    id: string
    cidr: string
    name: string | null
    description: string | null
    siteId: string | null
    vlanId: string | null
    parentId: string | null
    gatewayIpId: string | null
    tags: string | null
    notes: string | null
    createdAt: Date
    updatedAt: Date
    _count: NetworkSubnetCountAggregateOutputType | null
    _min: NetworkSubnetMinAggregateOutputType | null
    _max: NetworkSubnetMaxAggregateOutputType | null
  }

  type GetNetworkSubnetGroupByPayload<T extends NetworkSubnetGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<NetworkSubnetGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof NetworkSubnetGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], NetworkSubnetGroupByOutputType[P]>
            : GetScalarType<T[P], NetworkSubnetGroupByOutputType[P]>
        }
      >
    >


  export type NetworkSubnetSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    cidr?: boolean
    name?: boolean
    description?: boolean
    siteId?: boolean
    vlanId?: boolean
    parentId?: boolean
    gatewayIpId?: boolean
    tags?: boolean
    notes?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    site?: boolean | NetworkSubnet$siteArgs<ExtArgs>
    vlan?: boolean | NetworkSubnet$vlanArgs<ExtArgs>
    parent?: boolean | NetworkSubnet$parentArgs<ExtArgs>
    children?: boolean | NetworkSubnet$childrenArgs<ExtArgs>
    ips?: boolean | NetworkSubnet$ipsArgs<ExtArgs>
    _count?: boolean | NetworkSubnetCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["networkSubnet"]>

  export type NetworkSubnetSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    cidr?: boolean
    name?: boolean
    description?: boolean
    siteId?: boolean
    vlanId?: boolean
    parentId?: boolean
    gatewayIpId?: boolean
    tags?: boolean
    notes?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    site?: boolean | NetworkSubnet$siteArgs<ExtArgs>
    vlan?: boolean | NetworkSubnet$vlanArgs<ExtArgs>
    parent?: boolean | NetworkSubnet$parentArgs<ExtArgs>
  }, ExtArgs["result"]["networkSubnet"]>

  export type NetworkSubnetSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    cidr?: boolean
    name?: boolean
    description?: boolean
    siteId?: boolean
    vlanId?: boolean
    parentId?: boolean
    gatewayIpId?: boolean
    tags?: boolean
    notes?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    site?: boolean | NetworkSubnet$siteArgs<ExtArgs>
    vlan?: boolean | NetworkSubnet$vlanArgs<ExtArgs>
    parent?: boolean | NetworkSubnet$parentArgs<ExtArgs>
  }, ExtArgs["result"]["networkSubnet"]>

  export type NetworkSubnetSelectScalar = {
    id?: boolean
    cidr?: boolean
    name?: boolean
    description?: boolean
    siteId?: boolean
    vlanId?: boolean
    parentId?: boolean
    gatewayIpId?: boolean
    tags?: boolean
    notes?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type NetworkSubnetOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "cidr" | "name" | "description" | "siteId" | "vlanId" | "parentId" | "gatewayIpId" | "tags" | "notes" | "createdAt" | "updatedAt", ExtArgs["result"]["networkSubnet"]>
  export type NetworkSubnetInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    site?: boolean | NetworkSubnet$siteArgs<ExtArgs>
    vlan?: boolean | NetworkSubnet$vlanArgs<ExtArgs>
    parent?: boolean | NetworkSubnet$parentArgs<ExtArgs>
    children?: boolean | NetworkSubnet$childrenArgs<ExtArgs>
    ips?: boolean | NetworkSubnet$ipsArgs<ExtArgs>
    _count?: boolean | NetworkSubnetCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type NetworkSubnetIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    site?: boolean | NetworkSubnet$siteArgs<ExtArgs>
    vlan?: boolean | NetworkSubnet$vlanArgs<ExtArgs>
    parent?: boolean | NetworkSubnet$parentArgs<ExtArgs>
  }
  export type NetworkSubnetIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    site?: boolean | NetworkSubnet$siteArgs<ExtArgs>
    vlan?: boolean | NetworkSubnet$vlanArgs<ExtArgs>
    parent?: boolean | NetworkSubnet$parentArgs<ExtArgs>
  }

  export type $NetworkSubnetPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "NetworkSubnet"
    objects: {
      site: Prisma.$SitePayload<ExtArgs> | null
      vlan: Prisma.$VlanPayload<ExtArgs> | null
      parent: Prisma.$NetworkSubnetPayload<ExtArgs> | null
      children: Prisma.$NetworkSubnetPayload<ExtArgs>[]
      ips: Prisma.$NetworkIPPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      cidr: string
      name: string | null
      description: string | null
      siteId: string | null
      vlanId: string | null
      parentId: string | null
      gatewayIpId: string | null
      tags: string | null
      notes: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["networkSubnet"]>
    composites: {}
  }

  type NetworkSubnetGetPayload<S extends boolean | null | undefined | NetworkSubnetDefaultArgs> = $Result.GetResult<Prisma.$NetworkSubnetPayload, S>

  type NetworkSubnetCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<NetworkSubnetFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: NetworkSubnetCountAggregateInputType | true
    }

  export interface NetworkSubnetDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['NetworkSubnet'], meta: { name: 'NetworkSubnet' } }
    /**
     * Find zero or one NetworkSubnet that matches the filter.
     * @param {NetworkSubnetFindUniqueArgs} args - Arguments to find a NetworkSubnet
     * @example
     * // Get one NetworkSubnet
     * const networkSubnet = await prisma.networkSubnet.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends NetworkSubnetFindUniqueArgs>(args: SelectSubset<T, NetworkSubnetFindUniqueArgs<ExtArgs>>): Prisma__NetworkSubnetClient<$Result.GetResult<Prisma.$NetworkSubnetPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one NetworkSubnet that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {NetworkSubnetFindUniqueOrThrowArgs} args - Arguments to find a NetworkSubnet
     * @example
     * // Get one NetworkSubnet
     * const networkSubnet = await prisma.networkSubnet.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends NetworkSubnetFindUniqueOrThrowArgs>(args: SelectSubset<T, NetworkSubnetFindUniqueOrThrowArgs<ExtArgs>>): Prisma__NetworkSubnetClient<$Result.GetResult<Prisma.$NetworkSubnetPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first NetworkSubnet that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NetworkSubnetFindFirstArgs} args - Arguments to find a NetworkSubnet
     * @example
     * // Get one NetworkSubnet
     * const networkSubnet = await prisma.networkSubnet.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends NetworkSubnetFindFirstArgs>(args?: SelectSubset<T, NetworkSubnetFindFirstArgs<ExtArgs>>): Prisma__NetworkSubnetClient<$Result.GetResult<Prisma.$NetworkSubnetPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first NetworkSubnet that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NetworkSubnetFindFirstOrThrowArgs} args - Arguments to find a NetworkSubnet
     * @example
     * // Get one NetworkSubnet
     * const networkSubnet = await prisma.networkSubnet.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends NetworkSubnetFindFirstOrThrowArgs>(args?: SelectSubset<T, NetworkSubnetFindFirstOrThrowArgs<ExtArgs>>): Prisma__NetworkSubnetClient<$Result.GetResult<Prisma.$NetworkSubnetPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more NetworkSubnets that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NetworkSubnetFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all NetworkSubnets
     * const networkSubnets = await prisma.networkSubnet.findMany()
     * 
     * // Get first 10 NetworkSubnets
     * const networkSubnets = await prisma.networkSubnet.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const networkSubnetWithIdOnly = await prisma.networkSubnet.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends NetworkSubnetFindManyArgs>(args?: SelectSubset<T, NetworkSubnetFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$NetworkSubnetPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a NetworkSubnet.
     * @param {NetworkSubnetCreateArgs} args - Arguments to create a NetworkSubnet.
     * @example
     * // Create one NetworkSubnet
     * const NetworkSubnet = await prisma.networkSubnet.create({
     *   data: {
     *     // ... data to create a NetworkSubnet
     *   }
     * })
     * 
     */
    create<T extends NetworkSubnetCreateArgs>(args: SelectSubset<T, NetworkSubnetCreateArgs<ExtArgs>>): Prisma__NetworkSubnetClient<$Result.GetResult<Prisma.$NetworkSubnetPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many NetworkSubnets.
     * @param {NetworkSubnetCreateManyArgs} args - Arguments to create many NetworkSubnets.
     * @example
     * // Create many NetworkSubnets
     * const networkSubnet = await prisma.networkSubnet.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends NetworkSubnetCreateManyArgs>(args?: SelectSubset<T, NetworkSubnetCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many NetworkSubnets and returns the data saved in the database.
     * @param {NetworkSubnetCreateManyAndReturnArgs} args - Arguments to create many NetworkSubnets.
     * @example
     * // Create many NetworkSubnets
     * const networkSubnet = await prisma.networkSubnet.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many NetworkSubnets and only return the `id`
     * const networkSubnetWithIdOnly = await prisma.networkSubnet.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends NetworkSubnetCreateManyAndReturnArgs>(args?: SelectSubset<T, NetworkSubnetCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$NetworkSubnetPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a NetworkSubnet.
     * @param {NetworkSubnetDeleteArgs} args - Arguments to delete one NetworkSubnet.
     * @example
     * // Delete one NetworkSubnet
     * const NetworkSubnet = await prisma.networkSubnet.delete({
     *   where: {
     *     // ... filter to delete one NetworkSubnet
     *   }
     * })
     * 
     */
    delete<T extends NetworkSubnetDeleteArgs>(args: SelectSubset<T, NetworkSubnetDeleteArgs<ExtArgs>>): Prisma__NetworkSubnetClient<$Result.GetResult<Prisma.$NetworkSubnetPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one NetworkSubnet.
     * @param {NetworkSubnetUpdateArgs} args - Arguments to update one NetworkSubnet.
     * @example
     * // Update one NetworkSubnet
     * const networkSubnet = await prisma.networkSubnet.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends NetworkSubnetUpdateArgs>(args: SelectSubset<T, NetworkSubnetUpdateArgs<ExtArgs>>): Prisma__NetworkSubnetClient<$Result.GetResult<Prisma.$NetworkSubnetPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more NetworkSubnets.
     * @param {NetworkSubnetDeleteManyArgs} args - Arguments to filter NetworkSubnets to delete.
     * @example
     * // Delete a few NetworkSubnets
     * const { count } = await prisma.networkSubnet.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends NetworkSubnetDeleteManyArgs>(args?: SelectSubset<T, NetworkSubnetDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more NetworkSubnets.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NetworkSubnetUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many NetworkSubnets
     * const networkSubnet = await prisma.networkSubnet.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends NetworkSubnetUpdateManyArgs>(args: SelectSubset<T, NetworkSubnetUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more NetworkSubnets and returns the data updated in the database.
     * @param {NetworkSubnetUpdateManyAndReturnArgs} args - Arguments to update many NetworkSubnets.
     * @example
     * // Update many NetworkSubnets
     * const networkSubnet = await prisma.networkSubnet.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more NetworkSubnets and only return the `id`
     * const networkSubnetWithIdOnly = await prisma.networkSubnet.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends NetworkSubnetUpdateManyAndReturnArgs>(args: SelectSubset<T, NetworkSubnetUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$NetworkSubnetPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one NetworkSubnet.
     * @param {NetworkSubnetUpsertArgs} args - Arguments to update or create a NetworkSubnet.
     * @example
     * // Update or create a NetworkSubnet
     * const networkSubnet = await prisma.networkSubnet.upsert({
     *   create: {
     *     // ... data to create a NetworkSubnet
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the NetworkSubnet we want to update
     *   }
     * })
     */
    upsert<T extends NetworkSubnetUpsertArgs>(args: SelectSubset<T, NetworkSubnetUpsertArgs<ExtArgs>>): Prisma__NetworkSubnetClient<$Result.GetResult<Prisma.$NetworkSubnetPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of NetworkSubnets.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NetworkSubnetCountArgs} args - Arguments to filter NetworkSubnets to count.
     * @example
     * // Count the number of NetworkSubnets
     * const count = await prisma.networkSubnet.count({
     *   where: {
     *     // ... the filter for the NetworkSubnets we want to count
     *   }
     * })
    **/
    count<T extends NetworkSubnetCountArgs>(
      args?: Subset<T, NetworkSubnetCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], NetworkSubnetCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a NetworkSubnet.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NetworkSubnetAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends NetworkSubnetAggregateArgs>(args: Subset<T, NetworkSubnetAggregateArgs>): Prisma.PrismaPromise<GetNetworkSubnetAggregateType<T>>

    /**
     * Group by NetworkSubnet.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NetworkSubnetGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends NetworkSubnetGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: NetworkSubnetGroupByArgs['orderBy'] }
        : { orderBy?: NetworkSubnetGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, NetworkSubnetGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetNetworkSubnetGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the NetworkSubnet model
   */
  readonly fields: NetworkSubnetFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for NetworkSubnet.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__NetworkSubnetClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    site<T extends NetworkSubnet$siteArgs<ExtArgs> = {}>(args?: Subset<T, NetworkSubnet$siteArgs<ExtArgs>>): Prisma__SiteClient<$Result.GetResult<Prisma.$SitePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    vlan<T extends NetworkSubnet$vlanArgs<ExtArgs> = {}>(args?: Subset<T, NetworkSubnet$vlanArgs<ExtArgs>>): Prisma__VlanClient<$Result.GetResult<Prisma.$VlanPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    parent<T extends NetworkSubnet$parentArgs<ExtArgs> = {}>(args?: Subset<T, NetworkSubnet$parentArgs<ExtArgs>>): Prisma__NetworkSubnetClient<$Result.GetResult<Prisma.$NetworkSubnetPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    children<T extends NetworkSubnet$childrenArgs<ExtArgs> = {}>(args?: Subset<T, NetworkSubnet$childrenArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$NetworkSubnetPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    ips<T extends NetworkSubnet$ipsArgs<ExtArgs> = {}>(args?: Subset<T, NetworkSubnet$ipsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$NetworkIPPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the NetworkSubnet model
   */
  interface NetworkSubnetFieldRefs {
    readonly id: FieldRef<"NetworkSubnet", 'String'>
    readonly cidr: FieldRef<"NetworkSubnet", 'String'>
    readonly name: FieldRef<"NetworkSubnet", 'String'>
    readonly description: FieldRef<"NetworkSubnet", 'String'>
    readonly siteId: FieldRef<"NetworkSubnet", 'String'>
    readonly vlanId: FieldRef<"NetworkSubnet", 'String'>
    readonly parentId: FieldRef<"NetworkSubnet", 'String'>
    readonly gatewayIpId: FieldRef<"NetworkSubnet", 'String'>
    readonly tags: FieldRef<"NetworkSubnet", 'String'>
    readonly notes: FieldRef<"NetworkSubnet", 'String'>
    readonly createdAt: FieldRef<"NetworkSubnet", 'DateTime'>
    readonly updatedAt: FieldRef<"NetworkSubnet", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * NetworkSubnet findUnique
   */
  export type NetworkSubnetFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NetworkSubnet
     */
    select?: NetworkSubnetSelect<ExtArgs> | null
    /**
     * Omit specific fields from the NetworkSubnet
     */
    omit?: NetworkSubnetOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NetworkSubnetInclude<ExtArgs> | null
    /**
     * Filter, which NetworkSubnet to fetch.
     */
    where: NetworkSubnetWhereUniqueInput
  }

  /**
   * NetworkSubnet findUniqueOrThrow
   */
  export type NetworkSubnetFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NetworkSubnet
     */
    select?: NetworkSubnetSelect<ExtArgs> | null
    /**
     * Omit specific fields from the NetworkSubnet
     */
    omit?: NetworkSubnetOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NetworkSubnetInclude<ExtArgs> | null
    /**
     * Filter, which NetworkSubnet to fetch.
     */
    where: NetworkSubnetWhereUniqueInput
  }

  /**
   * NetworkSubnet findFirst
   */
  export type NetworkSubnetFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NetworkSubnet
     */
    select?: NetworkSubnetSelect<ExtArgs> | null
    /**
     * Omit specific fields from the NetworkSubnet
     */
    omit?: NetworkSubnetOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NetworkSubnetInclude<ExtArgs> | null
    /**
     * Filter, which NetworkSubnet to fetch.
     */
    where?: NetworkSubnetWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of NetworkSubnets to fetch.
     */
    orderBy?: NetworkSubnetOrderByWithRelationInput | NetworkSubnetOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for NetworkSubnets.
     */
    cursor?: NetworkSubnetWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` NetworkSubnets from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` NetworkSubnets.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of NetworkSubnets.
     */
    distinct?: NetworkSubnetScalarFieldEnum | NetworkSubnetScalarFieldEnum[]
  }

  /**
   * NetworkSubnet findFirstOrThrow
   */
  export type NetworkSubnetFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NetworkSubnet
     */
    select?: NetworkSubnetSelect<ExtArgs> | null
    /**
     * Omit specific fields from the NetworkSubnet
     */
    omit?: NetworkSubnetOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NetworkSubnetInclude<ExtArgs> | null
    /**
     * Filter, which NetworkSubnet to fetch.
     */
    where?: NetworkSubnetWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of NetworkSubnets to fetch.
     */
    orderBy?: NetworkSubnetOrderByWithRelationInput | NetworkSubnetOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for NetworkSubnets.
     */
    cursor?: NetworkSubnetWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` NetworkSubnets from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` NetworkSubnets.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of NetworkSubnets.
     */
    distinct?: NetworkSubnetScalarFieldEnum | NetworkSubnetScalarFieldEnum[]
  }

  /**
   * NetworkSubnet findMany
   */
  export type NetworkSubnetFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NetworkSubnet
     */
    select?: NetworkSubnetSelect<ExtArgs> | null
    /**
     * Omit specific fields from the NetworkSubnet
     */
    omit?: NetworkSubnetOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NetworkSubnetInclude<ExtArgs> | null
    /**
     * Filter, which NetworkSubnets to fetch.
     */
    where?: NetworkSubnetWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of NetworkSubnets to fetch.
     */
    orderBy?: NetworkSubnetOrderByWithRelationInput | NetworkSubnetOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing NetworkSubnets.
     */
    cursor?: NetworkSubnetWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` NetworkSubnets from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` NetworkSubnets.
     */
    skip?: number
    distinct?: NetworkSubnetScalarFieldEnum | NetworkSubnetScalarFieldEnum[]
  }

  /**
   * NetworkSubnet create
   */
  export type NetworkSubnetCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NetworkSubnet
     */
    select?: NetworkSubnetSelect<ExtArgs> | null
    /**
     * Omit specific fields from the NetworkSubnet
     */
    omit?: NetworkSubnetOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NetworkSubnetInclude<ExtArgs> | null
    /**
     * The data needed to create a NetworkSubnet.
     */
    data: XOR<NetworkSubnetCreateInput, NetworkSubnetUncheckedCreateInput>
  }

  /**
   * NetworkSubnet createMany
   */
  export type NetworkSubnetCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many NetworkSubnets.
     */
    data: NetworkSubnetCreateManyInput | NetworkSubnetCreateManyInput[]
  }

  /**
   * NetworkSubnet createManyAndReturn
   */
  export type NetworkSubnetCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NetworkSubnet
     */
    select?: NetworkSubnetSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the NetworkSubnet
     */
    omit?: NetworkSubnetOmit<ExtArgs> | null
    /**
     * The data used to create many NetworkSubnets.
     */
    data: NetworkSubnetCreateManyInput | NetworkSubnetCreateManyInput[]
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NetworkSubnetIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * NetworkSubnet update
   */
  export type NetworkSubnetUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NetworkSubnet
     */
    select?: NetworkSubnetSelect<ExtArgs> | null
    /**
     * Omit specific fields from the NetworkSubnet
     */
    omit?: NetworkSubnetOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NetworkSubnetInclude<ExtArgs> | null
    /**
     * The data needed to update a NetworkSubnet.
     */
    data: XOR<NetworkSubnetUpdateInput, NetworkSubnetUncheckedUpdateInput>
    /**
     * Choose, which NetworkSubnet to update.
     */
    where: NetworkSubnetWhereUniqueInput
  }

  /**
   * NetworkSubnet updateMany
   */
  export type NetworkSubnetUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update NetworkSubnets.
     */
    data: XOR<NetworkSubnetUpdateManyMutationInput, NetworkSubnetUncheckedUpdateManyInput>
    /**
     * Filter which NetworkSubnets to update
     */
    where?: NetworkSubnetWhereInput
    /**
     * Limit how many NetworkSubnets to update.
     */
    limit?: number
  }

  /**
   * NetworkSubnet updateManyAndReturn
   */
  export type NetworkSubnetUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NetworkSubnet
     */
    select?: NetworkSubnetSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the NetworkSubnet
     */
    omit?: NetworkSubnetOmit<ExtArgs> | null
    /**
     * The data used to update NetworkSubnets.
     */
    data: XOR<NetworkSubnetUpdateManyMutationInput, NetworkSubnetUncheckedUpdateManyInput>
    /**
     * Filter which NetworkSubnets to update
     */
    where?: NetworkSubnetWhereInput
    /**
     * Limit how many NetworkSubnets to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NetworkSubnetIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * NetworkSubnet upsert
   */
  export type NetworkSubnetUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NetworkSubnet
     */
    select?: NetworkSubnetSelect<ExtArgs> | null
    /**
     * Omit specific fields from the NetworkSubnet
     */
    omit?: NetworkSubnetOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NetworkSubnetInclude<ExtArgs> | null
    /**
     * The filter to search for the NetworkSubnet to update in case it exists.
     */
    where: NetworkSubnetWhereUniqueInput
    /**
     * In case the NetworkSubnet found by the `where` argument doesn't exist, create a new NetworkSubnet with this data.
     */
    create: XOR<NetworkSubnetCreateInput, NetworkSubnetUncheckedCreateInput>
    /**
     * In case the NetworkSubnet was found with the provided `where` argument, update it with this data.
     */
    update: XOR<NetworkSubnetUpdateInput, NetworkSubnetUncheckedUpdateInput>
  }

  /**
   * NetworkSubnet delete
   */
  export type NetworkSubnetDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NetworkSubnet
     */
    select?: NetworkSubnetSelect<ExtArgs> | null
    /**
     * Omit specific fields from the NetworkSubnet
     */
    omit?: NetworkSubnetOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NetworkSubnetInclude<ExtArgs> | null
    /**
     * Filter which NetworkSubnet to delete.
     */
    where: NetworkSubnetWhereUniqueInput
  }

  /**
   * NetworkSubnet deleteMany
   */
  export type NetworkSubnetDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which NetworkSubnets to delete
     */
    where?: NetworkSubnetWhereInput
    /**
     * Limit how many NetworkSubnets to delete.
     */
    limit?: number
  }

  /**
   * NetworkSubnet.site
   */
  export type NetworkSubnet$siteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Site
     */
    select?: SiteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Site
     */
    omit?: SiteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SiteInclude<ExtArgs> | null
    where?: SiteWhereInput
  }

  /**
   * NetworkSubnet.vlan
   */
  export type NetworkSubnet$vlanArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Vlan
     */
    select?: VlanSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Vlan
     */
    omit?: VlanOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VlanInclude<ExtArgs> | null
    where?: VlanWhereInput
  }

  /**
   * NetworkSubnet.parent
   */
  export type NetworkSubnet$parentArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NetworkSubnet
     */
    select?: NetworkSubnetSelect<ExtArgs> | null
    /**
     * Omit specific fields from the NetworkSubnet
     */
    omit?: NetworkSubnetOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NetworkSubnetInclude<ExtArgs> | null
    where?: NetworkSubnetWhereInput
  }

  /**
   * NetworkSubnet.children
   */
  export type NetworkSubnet$childrenArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NetworkSubnet
     */
    select?: NetworkSubnetSelect<ExtArgs> | null
    /**
     * Omit specific fields from the NetworkSubnet
     */
    omit?: NetworkSubnetOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NetworkSubnetInclude<ExtArgs> | null
    where?: NetworkSubnetWhereInput
    orderBy?: NetworkSubnetOrderByWithRelationInput | NetworkSubnetOrderByWithRelationInput[]
    cursor?: NetworkSubnetWhereUniqueInput
    take?: number
    skip?: number
    distinct?: NetworkSubnetScalarFieldEnum | NetworkSubnetScalarFieldEnum[]
  }

  /**
   * NetworkSubnet.ips
   */
  export type NetworkSubnet$ipsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NetworkIP
     */
    select?: NetworkIPSelect<ExtArgs> | null
    /**
     * Omit specific fields from the NetworkIP
     */
    omit?: NetworkIPOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NetworkIPInclude<ExtArgs> | null
    where?: NetworkIPWhereInput
    orderBy?: NetworkIPOrderByWithRelationInput | NetworkIPOrderByWithRelationInput[]
    cursor?: NetworkIPWhereUniqueInput
    take?: number
    skip?: number
    distinct?: NetworkIPScalarFieldEnum | NetworkIPScalarFieldEnum[]
  }

  /**
   * NetworkSubnet without action
   */
  export type NetworkSubnetDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NetworkSubnet
     */
    select?: NetworkSubnetSelect<ExtArgs> | null
    /**
     * Omit specific fields from the NetworkSubnet
     */
    omit?: NetworkSubnetOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NetworkSubnetInclude<ExtArgs> | null
  }


  /**
   * Model NetworkIP
   */

  export type AggregateNetworkIP = {
    _count: NetworkIPCountAggregateOutputType | null
    _min: NetworkIPMinAggregateOutputType | null
    _max: NetworkIPMaxAggregateOutputType | null
  }

  export type NetworkIPMinAggregateOutputType = {
    id: string | null
    address: string | null
    subnetId: string | null
    status: $Enums.IPStatus | null
    deviceId: string | null
    interface: string | null
    fqdn: string | null
    purpose: string | null
    mac: string | null
    tags: string | null
    notes: string | null
    lastSeen: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type NetworkIPMaxAggregateOutputType = {
    id: string | null
    address: string | null
    subnetId: string | null
    status: $Enums.IPStatus | null
    deviceId: string | null
    interface: string | null
    fqdn: string | null
    purpose: string | null
    mac: string | null
    tags: string | null
    notes: string | null
    lastSeen: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type NetworkIPCountAggregateOutputType = {
    id: number
    address: number
    subnetId: number
    status: number
    deviceId: number
    interface: number
    fqdn: number
    purpose: number
    mac: number
    tags: number
    notes: number
    lastSeen: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type NetworkIPMinAggregateInputType = {
    id?: true
    address?: true
    subnetId?: true
    status?: true
    deviceId?: true
    interface?: true
    fqdn?: true
    purpose?: true
    mac?: true
    tags?: true
    notes?: true
    lastSeen?: true
    createdAt?: true
    updatedAt?: true
  }

  export type NetworkIPMaxAggregateInputType = {
    id?: true
    address?: true
    subnetId?: true
    status?: true
    deviceId?: true
    interface?: true
    fqdn?: true
    purpose?: true
    mac?: true
    tags?: true
    notes?: true
    lastSeen?: true
    createdAt?: true
    updatedAt?: true
  }

  export type NetworkIPCountAggregateInputType = {
    id?: true
    address?: true
    subnetId?: true
    status?: true
    deviceId?: true
    interface?: true
    fqdn?: true
    purpose?: true
    mac?: true
    tags?: true
    notes?: true
    lastSeen?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type NetworkIPAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which NetworkIP to aggregate.
     */
    where?: NetworkIPWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of NetworkIPS to fetch.
     */
    orderBy?: NetworkIPOrderByWithRelationInput | NetworkIPOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: NetworkIPWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` NetworkIPS from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` NetworkIPS.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned NetworkIPS
    **/
    _count?: true | NetworkIPCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: NetworkIPMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: NetworkIPMaxAggregateInputType
  }

  export type GetNetworkIPAggregateType<T extends NetworkIPAggregateArgs> = {
        [P in keyof T & keyof AggregateNetworkIP]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateNetworkIP[P]>
      : GetScalarType<T[P], AggregateNetworkIP[P]>
  }




  export type NetworkIPGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: NetworkIPWhereInput
    orderBy?: NetworkIPOrderByWithAggregationInput | NetworkIPOrderByWithAggregationInput[]
    by: NetworkIPScalarFieldEnum[] | NetworkIPScalarFieldEnum
    having?: NetworkIPScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: NetworkIPCountAggregateInputType | true
    _min?: NetworkIPMinAggregateInputType
    _max?: NetworkIPMaxAggregateInputType
  }

  export type NetworkIPGroupByOutputType = {
    id: string
    address: string
    subnetId: string
    status: $Enums.IPStatus
    deviceId: string | null
    interface: string | null
    fqdn: string | null
    purpose: string | null
    mac: string | null
    tags: string | null
    notes: string | null
    lastSeen: Date | null
    createdAt: Date
    updatedAt: Date
    _count: NetworkIPCountAggregateOutputType | null
    _min: NetworkIPMinAggregateOutputType | null
    _max: NetworkIPMaxAggregateOutputType | null
  }

  type GetNetworkIPGroupByPayload<T extends NetworkIPGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<NetworkIPGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof NetworkIPGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], NetworkIPGroupByOutputType[P]>
            : GetScalarType<T[P], NetworkIPGroupByOutputType[P]>
        }
      >
    >


  export type NetworkIPSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    address?: boolean
    subnetId?: boolean
    status?: boolean
    deviceId?: boolean
    interface?: boolean
    fqdn?: boolean
    purpose?: boolean
    mac?: boolean
    tags?: boolean
    notes?: boolean
    lastSeen?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    subnet?: boolean | NetworkSubnetDefaultArgs<ExtArgs>
    device?: boolean | NetworkIP$deviceArgs<ExtArgs>
  }, ExtArgs["result"]["networkIP"]>

  export type NetworkIPSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    address?: boolean
    subnetId?: boolean
    status?: boolean
    deviceId?: boolean
    interface?: boolean
    fqdn?: boolean
    purpose?: boolean
    mac?: boolean
    tags?: boolean
    notes?: boolean
    lastSeen?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    subnet?: boolean | NetworkSubnetDefaultArgs<ExtArgs>
    device?: boolean | NetworkIP$deviceArgs<ExtArgs>
  }, ExtArgs["result"]["networkIP"]>

  export type NetworkIPSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    address?: boolean
    subnetId?: boolean
    status?: boolean
    deviceId?: boolean
    interface?: boolean
    fqdn?: boolean
    purpose?: boolean
    mac?: boolean
    tags?: boolean
    notes?: boolean
    lastSeen?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    subnet?: boolean | NetworkSubnetDefaultArgs<ExtArgs>
    device?: boolean | NetworkIP$deviceArgs<ExtArgs>
  }, ExtArgs["result"]["networkIP"]>

  export type NetworkIPSelectScalar = {
    id?: boolean
    address?: boolean
    subnetId?: boolean
    status?: boolean
    deviceId?: boolean
    interface?: boolean
    fqdn?: boolean
    purpose?: boolean
    mac?: boolean
    tags?: boolean
    notes?: boolean
    lastSeen?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type NetworkIPOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "address" | "subnetId" | "status" | "deviceId" | "interface" | "fqdn" | "purpose" | "mac" | "tags" | "notes" | "lastSeen" | "createdAt" | "updatedAt", ExtArgs["result"]["networkIP"]>
  export type NetworkIPInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    subnet?: boolean | NetworkSubnetDefaultArgs<ExtArgs>
    device?: boolean | NetworkIP$deviceArgs<ExtArgs>
  }
  export type NetworkIPIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    subnet?: boolean | NetworkSubnetDefaultArgs<ExtArgs>
    device?: boolean | NetworkIP$deviceArgs<ExtArgs>
  }
  export type NetworkIPIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    subnet?: boolean | NetworkSubnetDefaultArgs<ExtArgs>
    device?: boolean | NetworkIP$deviceArgs<ExtArgs>
  }

  export type $NetworkIPPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "NetworkIP"
    objects: {
      subnet: Prisma.$NetworkSubnetPayload<ExtArgs>
      device: Prisma.$NetworkDevicePayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      address: string
      subnetId: string
      status: $Enums.IPStatus
      deviceId: string | null
      interface: string | null
      fqdn: string | null
      purpose: string | null
      mac: string | null
      tags: string | null
      notes: string | null
      lastSeen: Date | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["networkIP"]>
    composites: {}
  }

  type NetworkIPGetPayload<S extends boolean | null | undefined | NetworkIPDefaultArgs> = $Result.GetResult<Prisma.$NetworkIPPayload, S>

  type NetworkIPCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<NetworkIPFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: NetworkIPCountAggregateInputType | true
    }

  export interface NetworkIPDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['NetworkIP'], meta: { name: 'NetworkIP' } }
    /**
     * Find zero or one NetworkIP that matches the filter.
     * @param {NetworkIPFindUniqueArgs} args - Arguments to find a NetworkIP
     * @example
     * // Get one NetworkIP
     * const networkIP = await prisma.networkIP.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends NetworkIPFindUniqueArgs>(args: SelectSubset<T, NetworkIPFindUniqueArgs<ExtArgs>>): Prisma__NetworkIPClient<$Result.GetResult<Prisma.$NetworkIPPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one NetworkIP that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {NetworkIPFindUniqueOrThrowArgs} args - Arguments to find a NetworkIP
     * @example
     * // Get one NetworkIP
     * const networkIP = await prisma.networkIP.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends NetworkIPFindUniqueOrThrowArgs>(args: SelectSubset<T, NetworkIPFindUniqueOrThrowArgs<ExtArgs>>): Prisma__NetworkIPClient<$Result.GetResult<Prisma.$NetworkIPPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first NetworkIP that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NetworkIPFindFirstArgs} args - Arguments to find a NetworkIP
     * @example
     * // Get one NetworkIP
     * const networkIP = await prisma.networkIP.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends NetworkIPFindFirstArgs>(args?: SelectSubset<T, NetworkIPFindFirstArgs<ExtArgs>>): Prisma__NetworkIPClient<$Result.GetResult<Prisma.$NetworkIPPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first NetworkIP that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NetworkIPFindFirstOrThrowArgs} args - Arguments to find a NetworkIP
     * @example
     * // Get one NetworkIP
     * const networkIP = await prisma.networkIP.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends NetworkIPFindFirstOrThrowArgs>(args?: SelectSubset<T, NetworkIPFindFirstOrThrowArgs<ExtArgs>>): Prisma__NetworkIPClient<$Result.GetResult<Prisma.$NetworkIPPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more NetworkIPS that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NetworkIPFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all NetworkIPS
     * const networkIPS = await prisma.networkIP.findMany()
     * 
     * // Get first 10 NetworkIPS
     * const networkIPS = await prisma.networkIP.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const networkIPWithIdOnly = await prisma.networkIP.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends NetworkIPFindManyArgs>(args?: SelectSubset<T, NetworkIPFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$NetworkIPPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a NetworkIP.
     * @param {NetworkIPCreateArgs} args - Arguments to create a NetworkIP.
     * @example
     * // Create one NetworkIP
     * const NetworkIP = await prisma.networkIP.create({
     *   data: {
     *     // ... data to create a NetworkIP
     *   }
     * })
     * 
     */
    create<T extends NetworkIPCreateArgs>(args: SelectSubset<T, NetworkIPCreateArgs<ExtArgs>>): Prisma__NetworkIPClient<$Result.GetResult<Prisma.$NetworkIPPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many NetworkIPS.
     * @param {NetworkIPCreateManyArgs} args - Arguments to create many NetworkIPS.
     * @example
     * // Create many NetworkIPS
     * const networkIP = await prisma.networkIP.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends NetworkIPCreateManyArgs>(args?: SelectSubset<T, NetworkIPCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many NetworkIPS and returns the data saved in the database.
     * @param {NetworkIPCreateManyAndReturnArgs} args - Arguments to create many NetworkIPS.
     * @example
     * // Create many NetworkIPS
     * const networkIP = await prisma.networkIP.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many NetworkIPS and only return the `id`
     * const networkIPWithIdOnly = await prisma.networkIP.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends NetworkIPCreateManyAndReturnArgs>(args?: SelectSubset<T, NetworkIPCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$NetworkIPPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a NetworkIP.
     * @param {NetworkIPDeleteArgs} args - Arguments to delete one NetworkIP.
     * @example
     * // Delete one NetworkIP
     * const NetworkIP = await prisma.networkIP.delete({
     *   where: {
     *     // ... filter to delete one NetworkIP
     *   }
     * })
     * 
     */
    delete<T extends NetworkIPDeleteArgs>(args: SelectSubset<T, NetworkIPDeleteArgs<ExtArgs>>): Prisma__NetworkIPClient<$Result.GetResult<Prisma.$NetworkIPPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one NetworkIP.
     * @param {NetworkIPUpdateArgs} args - Arguments to update one NetworkIP.
     * @example
     * // Update one NetworkIP
     * const networkIP = await prisma.networkIP.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends NetworkIPUpdateArgs>(args: SelectSubset<T, NetworkIPUpdateArgs<ExtArgs>>): Prisma__NetworkIPClient<$Result.GetResult<Prisma.$NetworkIPPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more NetworkIPS.
     * @param {NetworkIPDeleteManyArgs} args - Arguments to filter NetworkIPS to delete.
     * @example
     * // Delete a few NetworkIPS
     * const { count } = await prisma.networkIP.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends NetworkIPDeleteManyArgs>(args?: SelectSubset<T, NetworkIPDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more NetworkIPS.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NetworkIPUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many NetworkIPS
     * const networkIP = await prisma.networkIP.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends NetworkIPUpdateManyArgs>(args: SelectSubset<T, NetworkIPUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more NetworkIPS and returns the data updated in the database.
     * @param {NetworkIPUpdateManyAndReturnArgs} args - Arguments to update many NetworkIPS.
     * @example
     * // Update many NetworkIPS
     * const networkIP = await prisma.networkIP.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more NetworkIPS and only return the `id`
     * const networkIPWithIdOnly = await prisma.networkIP.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends NetworkIPUpdateManyAndReturnArgs>(args: SelectSubset<T, NetworkIPUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$NetworkIPPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one NetworkIP.
     * @param {NetworkIPUpsertArgs} args - Arguments to update or create a NetworkIP.
     * @example
     * // Update or create a NetworkIP
     * const networkIP = await prisma.networkIP.upsert({
     *   create: {
     *     // ... data to create a NetworkIP
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the NetworkIP we want to update
     *   }
     * })
     */
    upsert<T extends NetworkIPUpsertArgs>(args: SelectSubset<T, NetworkIPUpsertArgs<ExtArgs>>): Prisma__NetworkIPClient<$Result.GetResult<Prisma.$NetworkIPPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of NetworkIPS.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NetworkIPCountArgs} args - Arguments to filter NetworkIPS to count.
     * @example
     * // Count the number of NetworkIPS
     * const count = await prisma.networkIP.count({
     *   where: {
     *     // ... the filter for the NetworkIPS we want to count
     *   }
     * })
    **/
    count<T extends NetworkIPCountArgs>(
      args?: Subset<T, NetworkIPCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], NetworkIPCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a NetworkIP.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NetworkIPAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends NetworkIPAggregateArgs>(args: Subset<T, NetworkIPAggregateArgs>): Prisma.PrismaPromise<GetNetworkIPAggregateType<T>>

    /**
     * Group by NetworkIP.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NetworkIPGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends NetworkIPGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: NetworkIPGroupByArgs['orderBy'] }
        : { orderBy?: NetworkIPGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, NetworkIPGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetNetworkIPGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the NetworkIP model
   */
  readonly fields: NetworkIPFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for NetworkIP.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__NetworkIPClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    subnet<T extends NetworkSubnetDefaultArgs<ExtArgs> = {}>(args?: Subset<T, NetworkSubnetDefaultArgs<ExtArgs>>): Prisma__NetworkSubnetClient<$Result.GetResult<Prisma.$NetworkSubnetPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    device<T extends NetworkIP$deviceArgs<ExtArgs> = {}>(args?: Subset<T, NetworkIP$deviceArgs<ExtArgs>>): Prisma__NetworkDeviceClient<$Result.GetResult<Prisma.$NetworkDevicePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the NetworkIP model
   */
  interface NetworkIPFieldRefs {
    readonly id: FieldRef<"NetworkIP", 'String'>
    readonly address: FieldRef<"NetworkIP", 'String'>
    readonly subnetId: FieldRef<"NetworkIP", 'String'>
    readonly status: FieldRef<"NetworkIP", 'IPStatus'>
    readonly deviceId: FieldRef<"NetworkIP", 'String'>
    readonly interface: FieldRef<"NetworkIP", 'String'>
    readonly fqdn: FieldRef<"NetworkIP", 'String'>
    readonly purpose: FieldRef<"NetworkIP", 'String'>
    readonly mac: FieldRef<"NetworkIP", 'String'>
    readonly tags: FieldRef<"NetworkIP", 'String'>
    readonly notes: FieldRef<"NetworkIP", 'String'>
    readonly lastSeen: FieldRef<"NetworkIP", 'DateTime'>
    readonly createdAt: FieldRef<"NetworkIP", 'DateTime'>
    readonly updatedAt: FieldRef<"NetworkIP", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * NetworkIP findUnique
   */
  export type NetworkIPFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NetworkIP
     */
    select?: NetworkIPSelect<ExtArgs> | null
    /**
     * Omit specific fields from the NetworkIP
     */
    omit?: NetworkIPOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NetworkIPInclude<ExtArgs> | null
    /**
     * Filter, which NetworkIP to fetch.
     */
    where: NetworkIPWhereUniqueInput
  }

  /**
   * NetworkIP findUniqueOrThrow
   */
  export type NetworkIPFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NetworkIP
     */
    select?: NetworkIPSelect<ExtArgs> | null
    /**
     * Omit specific fields from the NetworkIP
     */
    omit?: NetworkIPOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NetworkIPInclude<ExtArgs> | null
    /**
     * Filter, which NetworkIP to fetch.
     */
    where: NetworkIPWhereUniqueInput
  }

  /**
   * NetworkIP findFirst
   */
  export type NetworkIPFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NetworkIP
     */
    select?: NetworkIPSelect<ExtArgs> | null
    /**
     * Omit specific fields from the NetworkIP
     */
    omit?: NetworkIPOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NetworkIPInclude<ExtArgs> | null
    /**
     * Filter, which NetworkIP to fetch.
     */
    where?: NetworkIPWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of NetworkIPS to fetch.
     */
    orderBy?: NetworkIPOrderByWithRelationInput | NetworkIPOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for NetworkIPS.
     */
    cursor?: NetworkIPWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` NetworkIPS from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` NetworkIPS.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of NetworkIPS.
     */
    distinct?: NetworkIPScalarFieldEnum | NetworkIPScalarFieldEnum[]
  }

  /**
   * NetworkIP findFirstOrThrow
   */
  export type NetworkIPFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NetworkIP
     */
    select?: NetworkIPSelect<ExtArgs> | null
    /**
     * Omit specific fields from the NetworkIP
     */
    omit?: NetworkIPOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NetworkIPInclude<ExtArgs> | null
    /**
     * Filter, which NetworkIP to fetch.
     */
    where?: NetworkIPWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of NetworkIPS to fetch.
     */
    orderBy?: NetworkIPOrderByWithRelationInput | NetworkIPOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for NetworkIPS.
     */
    cursor?: NetworkIPWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` NetworkIPS from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` NetworkIPS.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of NetworkIPS.
     */
    distinct?: NetworkIPScalarFieldEnum | NetworkIPScalarFieldEnum[]
  }

  /**
   * NetworkIP findMany
   */
  export type NetworkIPFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NetworkIP
     */
    select?: NetworkIPSelect<ExtArgs> | null
    /**
     * Omit specific fields from the NetworkIP
     */
    omit?: NetworkIPOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NetworkIPInclude<ExtArgs> | null
    /**
     * Filter, which NetworkIPS to fetch.
     */
    where?: NetworkIPWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of NetworkIPS to fetch.
     */
    orderBy?: NetworkIPOrderByWithRelationInput | NetworkIPOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing NetworkIPS.
     */
    cursor?: NetworkIPWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` NetworkIPS from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` NetworkIPS.
     */
    skip?: number
    distinct?: NetworkIPScalarFieldEnum | NetworkIPScalarFieldEnum[]
  }

  /**
   * NetworkIP create
   */
  export type NetworkIPCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NetworkIP
     */
    select?: NetworkIPSelect<ExtArgs> | null
    /**
     * Omit specific fields from the NetworkIP
     */
    omit?: NetworkIPOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NetworkIPInclude<ExtArgs> | null
    /**
     * The data needed to create a NetworkIP.
     */
    data: XOR<NetworkIPCreateInput, NetworkIPUncheckedCreateInput>
  }

  /**
   * NetworkIP createMany
   */
  export type NetworkIPCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many NetworkIPS.
     */
    data: NetworkIPCreateManyInput | NetworkIPCreateManyInput[]
  }

  /**
   * NetworkIP createManyAndReturn
   */
  export type NetworkIPCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NetworkIP
     */
    select?: NetworkIPSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the NetworkIP
     */
    omit?: NetworkIPOmit<ExtArgs> | null
    /**
     * The data used to create many NetworkIPS.
     */
    data: NetworkIPCreateManyInput | NetworkIPCreateManyInput[]
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NetworkIPIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * NetworkIP update
   */
  export type NetworkIPUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NetworkIP
     */
    select?: NetworkIPSelect<ExtArgs> | null
    /**
     * Omit specific fields from the NetworkIP
     */
    omit?: NetworkIPOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NetworkIPInclude<ExtArgs> | null
    /**
     * The data needed to update a NetworkIP.
     */
    data: XOR<NetworkIPUpdateInput, NetworkIPUncheckedUpdateInput>
    /**
     * Choose, which NetworkIP to update.
     */
    where: NetworkIPWhereUniqueInput
  }

  /**
   * NetworkIP updateMany
   */
  export type NetworkIPUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update NetworkIPS.
     */
    data: XOR<NetworkIPUpdateManyMutationInput, NetworkIPUncheckedUpdateManyInput>
    /**
     * Filter which NetworkIPS to update
     */
    where?: NetworkIPWhereInput
    /**
     * Limit how many NetworkIPS to update.
     */
    limit?: number
  }

  /**
   * NetworkIP updateManyAndReturn
   */
  export type NetworkIPUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NetworkIP
     */
    select?: NetworkIPSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the NetworkIP
     */
    omit?: NetworkIPOmit<ExtArgs> | null
    /**
     * The data used to update NetworkIPS.
     */
    data: XOR<NetworkIPUpdateManyMutationInput, NetworkIPUncheckedUpdateManyInput>
    /**
     * Filter which NetworkIPS to update
     */
    where?: NetworkIPWhereInput
    /**
     * Limit how many NetworkIPS to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NetworkIPIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * NetworkIP upsert
   */
  export type NetworkIPUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NetworkIP
     */
    select?: NetworkIPSelect<ExtArgs> | null
    /**
     * Omit specific fields from the NetworkIP
     */
    omit?: NetworkIPOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NetworkIPInclude<ExtArgs> | null
    /**
     * The filter to search for the NetworkIP to update in case it exists.
     */
    where: NetworkIPWhereUniqueInput
    /**
     * In case the NetworkIP found by the `where` argument doesn't exist, create a new NetworkIP with this data.
     */
    create: XOR<NetworkIPCreateInput, NetworkIPUncheckedCreateInput>
    /**
     * In case the NetworkIP was found with the provided `where` argument, update it with this data.
     */
    update: XOR<NetworkIPUpdateInput, NetworkIPUncheckedUpdateInput>
  }

  /**
   * NetworkIP delete
   */
  export type NetworkIPDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NetworkIP
     */
    select?: NetworkIPSelect<ExtArgs> | null
    /**
     * Omit specific fields from the NetworkIP
     */
    omit?: NetworkIPOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NetworkIPInclude<ExtArgs> | null
    /**
     * Filter which NetworkIP to delete.
     */
    where: NetworkIPWhereUniqueInput
  }

  /**
   * NetworkIP deleteMany
   */
  export type NetworkIPDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which NetworkIPS to delete
     */
    where?: NetworkIPWhereInput
    /**
     * Limit how many NetworkIPS to delete.
     */
    limit?: number
  }

  /**
   * NetworkIP.device
   */
  export type NetworkIP$deviceArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NetworkDevice
     */
    select?: NetworkDeviceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the NetworkDevice
     */
    omit?: NetworkDeviceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NetworkDeviceInclude<ExtArgs> | null
    where?: NetworkDeviceWhereInput
  }

  /**
   * NetworkIP without action
   */
  export type NetworkIPDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NetworkIP
     */
    select?: NetworkIPSelect<ExtArgs> | null
    /**
     * Omit specific fields from the NetworkIP
     */
    omit?: NetworkIPOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NetworkIPInclude<ExtArgs> | null
  }


  /**
   * Model NetworkDevice
   */

  export type AggregateNetworkDevice = {
    _count: NetworkDeviceCountAggregateOutputType | null
    _min: NetworkDeviceMinAggregateOutputType | null
    _max: NetworkDeviceMaxAggregateOutputType | null
  }

  export type NetworkDeviceMinAggregateOutputType = {
    id: string | null
    name: string | null
    type: $Enums.DeviceType | null
    siteId: string | null
    mgmtIp: string | null
    vendor: string | null
    model: string | null
    serial: string | null
    osVersion: string | null
    tags: string | null
    notes: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type NetworkDeviceMaxAggregateOutputType = {
    id: string | null
    name: string | null
    type: $Enums.DeviceType | null
    siteId: string | null
    mgmtIp: string | null
    vendor: string | null
    model: string | null
    serial: string | null
    osVersion: string | null
    tags: string | null
    notes: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type NetworkDeviceCountAggregateOutputType = {
    id: number
    name: number
    type: number
    siteId: number
    mgmtIp: number
    vendor: number
    model: number
    serial: number
    osVersion: number
    tags: number
    notes: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type NetworkDeviceMinAggregateInputType = {
    id?: true
    name?: true
    type?: true
    siteId?: true
    mgmtIp?: true
    vendor?: true
    model?: true
    serial?: true
    osVersion?: true
    tags?: true
    notes?: true
    createdAt?: true
    updatedAt?: true
  }

  export type NetworkDeviceMaxAggregateInputType = {
    id?: true
    name?: true
    type?: true
    siteId?: true
    mgmtIp?: true
    vendor?: true
    model?: true
    serial?: true
    osVersion?: true
    tags?: true
    notes?: true
    createdAt?: true
    updatedAt?: true
  }

  export type NetworkDeviceCountAggregateInputType = {
    id?: true
    name?: true
    type?: true
    siteId?: true
    mgmtIp?: true
    vendor?: true
    model?: true
    serial?: true
    osVersion?: true
    tags?: true
    notes?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type NetworkDeviceAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which NetworkDevice to aggregate.
     */
    where?: NetworkDeviceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of NetworkDevices to fetch.
     */
    orderBy?: NetworkDeviceOrderByWithRelationInput | NetworkDeviceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: NetworkDeviceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` NetworkDevices from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` NetworkDevices.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned NetworkDevices
    **/
    _count?: true | NetworkDeviceCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: NetworkDeviceMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: NetworkDeviceMaxAggregateInputType
  }

  export type GetNetworkDeviceAggregateType<T extends NetworkDeviceAggregateArgs> = {
        [P in keyof T & keyof AggregateNetworkDevice]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateNetworkDevice[P]>
      : GetScalarType<T[P], AggregateNetworkDevice[P]>
  }




  export type NetworkDeviceGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: NetworkDeviceWhereInput
    orderBy?: NetworkDeviceOrderByWithAggregationInput | NetworkDeviceOrderByWithAggregationInput[]
    by: NetworkDeviceScalarFieldEnum[] | NetworkDeviceScalarFieldEnum
    having?: NetworkDeviceScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: NetworkDeviceCountAggregateInputType | true
    _min?: NetworkDeviceMinAggregateInputType
    _max?: NetworkDeviceMaxAggregateInputType
  }

  export type NetworkDeviceGroupByOutputType = {
    id: string
    name: string
    type: $Enums.DeviceType
    siteId: string | null
    mgmtIp: string | null
    vendor: string | null
    model: string | null
    serial: string | null
    osVersion: string | null
    tags: string | null
    notes: string | null
    createdAt: Date
    updatedAt: Date
    _count: NetworkDeviceCountAggregateOutputType | null
    _min: NetworkDeviceMinAggregateOutputType | null
    _max: NetworkDeviceMaxAggregateOutputType | null
  }

  type GetNetworkDeviceGroupByPayload<T extends NetworkDeviceGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<NetworkDeviceGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof NetworkDeviceGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], NetworkDeviceGroupByOutputType[P]>
            : GetScalarType<T[P], NetworkDeviceGroupByOutputType[P]>
        }
      >
    >


  export type NetworkDeviceSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    type?: boolean
    siteId?: boolean
    mgmtIp?: boolean
    vendor?: boolean
    model?: boolean
    serial?: boolean
    osVersion?: boolean
    tags?: boolean
    notes?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    site?: boolean | NetworkDevice$siteArgs<ExtArgs>
    services?: boolean | NetworkDevice$servicesArgs<ExtArgs>
    ips?: boolean | NetworkDevice$ipsArgs<ExtArgs>
    _count?: boolean | NetworkDeviceCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["networkDevice"]>

  export type NetworkDeviceSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    type?: boolean
    siteId?: boolean
    mgmtIp?: boolean
    vendor?: boolean
    model?: boolean
    serial?: boolean
    osVersion?: boolean
    tags?: boolean
    notes?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    site?: boolean | NetworkDevice$siteArgs<ExtArgs>
  }, ExtArgs["result"]["networkDevice"]>

  export type NetworkDeviceSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    type?: boolean
    siteId?: boolean
    mgmtIp?: boolean
    vendor?: boolean
    model?: boolean
    serial?: boolean
    osVersion?: boolean
    tags?: boolean
    notes?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    site?: boolean | NetworkDevice$siteArgs<ExtArgs>
  }, ExtArgs["result"]["networkDevice"]>

  export type NetworkDeviceSelectScalar = {
    id?: boolean
    name?: boolean
    type?: boolean
    siteId?: boolean
    mgmtIp?: boolean
    vendor?: boolean
    model?: boolean
    serial?: boolean
    osVersion?: boolean
    tags?: boolean
    notes?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type NetworkDeviceOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "type" | "siteId" | "mgmtIp" | "vendor" | "model" | "serial" | "osVersion" | "tags" | "notes" | "createdAt" | "updatedAt", ExtArgs["result"]["networkDevice"]>
  export type NetworkDeviceInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    site?: boolean | NetworkDevice$siteArgs<ExtArgs>
    services?: boolean | NetworkDevice$servicesArgs<ExtArgs>
    ips?: boolean | NetworkDevice$ipsArgs<ExtArgs>
    _count?: boolean | NetworkDeviceCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type NetworkDeviceIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    site?: boolean | NetworkDevice$siteArgs<ExtArgs>
  }
  export type NetworkDeviceIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    site?: boolean | NetworkDevice$siteArgs<ExtArgs>
  }

  export type $NetworkDevicePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "NetworkDevice"
    objects: {
      site: Prisma.$SitePayload<ExtArgs> | null
      services: Prisma.$NetworkServicePayload<ExtArgs>[]
      ips: Prisma.$NetworkIPPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      type: $Enums.DeviceType
      siteId: string | null
      mgmtIp: string | null
      vendor: string | null
      model: string | null
      serial: string | null
      osVersion: string | null
      tags: string | null
      notes: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["networkDevice"]>
    composites: {}
  }

  type NetworkDeviceGetPayload<S extends boolean | null | undefined | NetworkDeviceDefaultArgs> = $Result.GetResult<Prisma.$NetworkDevicePayload, S>

  type NetworkDeviceCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<NetworkDeviceFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: NetworkDeviceCountAggregateInputType | true
    }

  export interface NetworkDeviceDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['NetworkDevice'], meta: { name: 'NetworkDevice' } }
    /**
     * Find zero or one NetworkDevice that matches the filter.
     * @param {NetworkDeviceFindUniqueArgs} args - Arguments to find a NetworkDevice
     * @example
     * // Get one NetworkDevice
     * const networkDevice = await prisma.networkDevice.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends NetworkDeviceFindUniqueArgs>(args: SelectSubset<T, NetworkDeviceFindUniqueArgs<ExtArgs>>): Prisma__NetworkDeviceClient<$Result.GetResult<Prisma.$NetworkDevicePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one NetworkDevice that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {NetworkDeviceFindUniqueOrThrowArgs} args - Arguments to find a NetworkDevice
     * @example
     * // Get one NetworkDevice
     * const networkDevice = await prisma.networkDevice.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends NetworkDeviceFindUniqueOrThrowArgs>(args: SelectSubset<T, NetworkDeviceFindUniqueOrThrowArgs<ExtArgs>>): Prisma__NetworkDeviceClient<$Result.GetResult<Prisma.$NetworkDevicePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first NetworkDevice that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NetworkDeviceFindFirstArgs} args - Arguments to find a NetworkDevice
     * @example
     * // Get one NetworkDevice
     * const networkDevice = await prisma.networkDevice.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends NetworkDeviceFindFirstArgs>(args?: SelectSubset<T, NetworkDeviceFindFirstArgs<ExtArgs>>): Prisma__NetworkDeviceClient<$Result.GetResult<Prisma.$NetworkDevicePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first NetworkDevice that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NetworkDeviceFindFirstOrThrowArgs} args - Arguments to find a NetworkDevice
     * @example
     * // Get one NetworkDevice
     * const networkDevice = await prisma.networkDevice.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends NetworkDeviceFindFirstOrThrowArgs>(args?: SelectSubset<T, NetworkDeviceFindFirstOrThrowArgs<ExtArgs>>): Prisma__NetworkDeviceClient<$Result.GetResult<Prisma.$NetworkDevicePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more NetworkDevices that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NetworkDeviceFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all NetworkDevices
     * const networkDevices = await prisma.networkDevice.findMany()
     * 
     * // Get first 10 NetworkDevices
     * const networkDevices = await prisma.networkDevice.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const networkDeviceWithIdOnly = await prisma.networkDevice.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends NetworkDeviceFindManyArgs>(args?: SelectSubset<T, NetworkDeviceFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$NetworkDevicePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a NetworkDevice.
     * @param {NetworkDeviceCreateArgs} args - Arguments to create a NetworkDevice.
     * @example
     * // Create one NetworkDevice
     * const NetworkDevice = await prisma.networkDevice.create({
     *   data: {
     *     // ... data to create a NetworkDevice
     *   }
     * })
     * 
     */
    create<T extends NetworkDeviceCreateArgs>(args: SelectSubset<T, NetworkDeviceCreateArgs<ExtArgs>>): Prisma__NetworkDeviceClient<$Result.GetResult<Prisma.$NetworkDevicePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many NetworkDevices.
     * @param {NetworkDeviceCreateManyArgs} args - Arguments to create many NetworkDevices.
     * @example
     * // Create many NetworkDevices
     * const networkDevice = await prisma.networkDevice.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends NetworkDeviceCreateManyArgs>(args?: SelectSubset<T, NetworkDeviceCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many NetworkDevices and returns the data saved in the database.
     * @param {NetworkDeviceCreateManyAndReturnArgs} args - Arguments to create many NetworkDevices.
     * @example
     * // Create many NetworkDevices
     * const networkDevice = await prisma.networkDevice.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many NetworkDevices and only return the `id`
     * const networkDeviceWithIdOnly = await prisma.networkDevice.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends NetworkDeviceCreateManyAndReturnArgs>(args?: SelectSubset<T, NetworkDeviceCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$NetworkDevicePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a NetworkDevice.
     * @param {NetworkDeviceDeleteArgs} args - Arguments to delete one NetworkDevice.
     * @example
     * // Delete one NetworkDevice
     * const NetworkDevice = await prisma.networkDevice.delete({
     *   where: {
     *     // ... filter to delete one NetworkDevice
     *   }
     * })
     * 
     */
    delete<T extends NetworkDeviceDeleteArgs>(args: SelectSubset<T, NetworkDeviceDeleteArgs<ExtArgs>>): Prisma__NetworkDeviceClient<$Result.GetResult<Prisma.$NetworkDevicePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one NetworkDevice.
     * @param {NetworkDeviceUpdateArgs} args - Arguments to update one NetworkDevice.
     * @example
     * // Update one NetworkDevice
     * const networkDevice = await prisma.networkDevice.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends NetworkDeviceUpdateArgs>(args: SelectSubset<T, NetworkDeviceUpdateArgs<ExtArgs>>): Prisma__NetworkDeviceClient<$Result.GetResult<Prisma.$NetworkDevicePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more NetworkDevices.
     * @param {NetworkDeviceDeleteManyArgs} args - Arguments to filter NetworkDevices to delete.
     * @example
     * // Delete a few NetworkDevices
     * const { count } = await prisma.networkDevice.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends NetworkDeviceDeleteManyArgs>(args?: SelectSubset<T, NetworkDeviceDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more NetworkDevices.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NetworkDeviceUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many NetworkDevices
     * const networkDevice = await prisma.networkDevice.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends NetworkDeviceUpdateManyArgs>(args: SelectSubset<T, NetworkDeviceUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more NetworkDevices and returns the data updated in the database.
     * @param {NetworkDeviceUpdateManyAndReturnArgs} args - Arguments to update many NetworkDevices.
     * @example
     * // Update many NetworkDevices
     * const networkDevice = await prisma.networkDevice.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more NetworkDevices and only return the `id`
     * const networkDeviceWithIdOnly = await prisma.networkDevice.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends NetworkDeviceUpdateManyAndReturnArgs>(args: SelectSubset<T, NetworkDeviceUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$NetworkDevicePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one NetworkDevice.
     * @param {NetworkDeviceUpsertArgs} args - Arguments to update or create a NetworkDevice.
     * @example
     * // Update or create a NetworkDevice
     * const networkDevice = await prisma.networkDevice.upsert({
     *   create: {
     *     // ... data to create a NetworkDevice
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the NetworkDevice we want to update
     *   }
     * })
     */
    upsert<T extends NetworkDeviceUpsertArgs>(args: SelectSubset<T, NetworkDeviceUpsertArgs<ExtArgs>>): Prisma__NetworkDeviceClient<$Result.GetResult<Prisma.$NetworkDevicePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of NetworkDevices.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NetworkDeviceCountArgs} args - Arguments to filter NetworkDevices to count.
     * @example
     * // Count the number of NetworkDevices
     * const count = await prisma.networkDevice.count({
     *   where: {
     *     // ... the filter for the NetworkDevices we want to count
     *   }
     * })
    **/
    count<T extends NetworkDeviceCountArgs>(
      args?: Subset<T, NetworkDeviceCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], NetworkDeviceCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a NetworkDevice.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NetworkDeviceAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends NetworkDeviceAggregateArgs>(args: Subset<T, NetworkDeviceAggregateArgs>): Prisma.PrismaPromise<GetNetworkDeviceAggregateType<T>>

    /**
     * Group by NetworkDevice.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NetworkDeviceGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends NetworkDeviceGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: NetworkDeviceGroupByArgs['orderBy'] }
        : { orderBy?: NetworkDeviceGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, NetworkDeviceGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetNetworkDeviceGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the NetworkDevice model
   */
  readonly fields: NetworkDeviceFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for NetworkDevice.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__NetworkDeviceClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    site<T extends NetworkDevice$siteArgs<ExtArgs> = {}>(args?: Subset<T, NetworkDevice$siteArgs<ExtArgs>>): Prisma__SiteClient<$Result.GetResult<Prisma.$SitePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    services<T extends NetworkDevice$servicesArgs<ExtArgs> = {}>(args?: Subset<T, NetworkDevice$servicesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$NetworkServicePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    ips<T extends NetworkDevice$ipsArgs<ExtArgs> = {}>(args?: Subset<T, NetworkDevice$ipsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$NetworkIPPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the NetworkDevice model
   */
  interface NetworkDeviceFieldRefs {
    readonly id: FieldRef<"NetworkDevice", 'String'>
    readonly name: FieldRef<"NetworkDevice", 'String'>
    readonly type: FieldRef<"NetworkDevice", 'DeviceType'>
    readonly siteId: FieldRef<"NetworkDevice", 'String'>
    readonly mgmtIp: FieldRef<"NetworkDevice", 'String'>
    readonly vendor: FieldRef<"NetworkDevice", 'String'>
    readonly model: FieldRef<"NetworkDevice", 'String'>
    readonly serial: FieldRef<"NetworkDevice", 'String'>
    readonly osVersion: FieldRef<"NetworkDevice", 'String'>
    readonly tags: FieldRef<"NetworkDevice", 'String'>
    readonly notes: FieldRef<"NetworkDevice", 'String'>
    readonly createdAt: FieldRef<"NetworkDevice", 'DateTime'>
    readonly updatedAt: FieldRef<"NetworkDevice", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * NetworkDevice findUnique
   */
  export type NetworkDeviceFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NetworkDevice
     */
    select?: NetworkDeviceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the NetworkDevice
     */
    omit?: NetworkDeviceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NetworkDeviceInclude<ExtArgs> | null
    /**
     * Filter, which NetworkDevice to fetch.
     */
    where: NetworkDeviceWhereUniqueInput
  }

  /**
   * NetworkDevice findUniqueOrThrow
   */
  export type NetworkDeviceFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NetworkDevice
     */
    select?: NetworkDeviceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the NetworkDevice
     */
    omit?: NetworkDeviceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NetworkDeviceInclude<ExtArgs> | null
    /**
     * Filter, which NetworkDevice to fetch.
     */
    where: NetworkDeviceWhereUniqueInput
  }

  /**
   * NetworkDevice findFirst
   */
  export type NetworkDeviceFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NetworkDevice
     */
    select?: NetworkDeviceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the NetworkDevice
     */
    omit?: NetworkDeviceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NetworkDeviceInclude<ExtArgs> | null
    /**
     * Filter, which NetworkDevice to fetch.
     */
    where?: NetworkDeviceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of NetworkDevices to fetch.
     */
    orderBy?: NetworkDeviceOrderByWithRelationInput | NetworkDeviceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for NetworkDevices.
     */
    cursor?: NetworkDeviceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` NetworkDevices from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` NetworkDevices.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of NetworkDevices.
     */
    distinct?: NetworkDeviceScalarFieldEnum | NetworkDeviceScalarFieldEnum[]
  }

  /**
   * NetworkDevice findFirstOrThrow
   */
  export type NetworkDeviceFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NetworkDevice
     */
    select?: NetworkDeviceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the NetworkDevice
     */
    omit?: NetworkDeviceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NetworkDeviceInclude<ExtArgs> | null
    /**
     * Filter, which NetworkDevice to fetch.
     */
    where?: NetworkDeviceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of NetworkDevices to fetch.
     */
    orderBy?: NetworkDeviceOrderByWithRelationInput | NetworkDeviceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for NetworkDevices.
     */
    cursor?: NetworkDeviceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` NetworkDevices from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` NetworkDevices.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of NetworkDevices.
     */
    distinct?: NetworkDeviceScalarFieldEnum | NetworkDeviceScalarFieldEnum[]
  }

  /**
   * NetworkDevice findMany
   */
  export type NetworkDeviceFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NetworkDevice
     */
    select?: NetworkDeviceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the NetworkDevice
     */
    omit?: NetworkDeviceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NetworkDeviceInclude<ExtArgs> | null
    /**
     * Filter, which NetworkDevices to fetch.
     */
    where?: NetworkDeviceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of NetworkDevices to fetch.
     */
    orderBy?: NetworkDeviceOrderByWithRelationInput | NetworkDeviceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing NetworkDevices.
     */
    cursor?: NetworkDeviceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` NetworkDevices from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` NetworkDevices.
     */
    skip?: number
    distinct?: NetworkDeviceScalarFieldEnum | NetworkDeviceScalarFieldEnum[]
  }

  /**
   * NetworkDevice create
   */
  export type NetworkDeviceCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NetworkDevice
     */
    select?: NetworkDeviceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the NetworkDevice
     */
    omit?: NetworkDeviceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NetworkDeviceInclude<ExtArgs> | null
    /**
     * The data needed to create a NetworkDevice.
     */
    data: XOR<NetworkDeviceCreateInput, NetworkDeviceUncheckedCreateInput>
  }

  /**
   * NetworkDevice createMany
   */
  export type NetworkDeviceCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many NetworkDevices.
     */
    data: NetworkDeviceCreateManyInput | NetworkDeviceCreateManyInput[]
  }

  /**
   * NetworkDevice createManyAndReturn
   */
  export type NetworkDeviceCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NetworkDevice
     */
    select?: NetworkDeviceSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the NetworkDevice
     */
    omit?: NetworkDeviceOmit<ExtArgs> | null
    /**
     * The data used to create many NetworkDevices.
     */
    data: NetworkDeviceCreateManyInput | NetworkDeviceCreateManyInput[]
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NetworkDeviceIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * NetworkDevice update
   */
  export type NetworkDeviceUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NetworkDevice
     */
    select?: NetworkDeviceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the NetworkDevice
     */
    omit?: NetworkDeviceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NetworkDeviceInclude<ExtArgs> | null
    /**
     * The data needed to update a NetworkDevice.
     */
    data: XOR<NetworkDeviceUpdateInput, NetworkDeviceUncheckedUpdateInput>
    /**
     * Choose, which NetworkDevice to update.
     */
    where: NetworkDeviceWhereUniqueInput
  }

  /**
   * NetworkDevice updateMany
   */
  export type NetworkDeviceUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update NetworkDevices.
     */
    data: XOR<NetworkDeviceUpdateManyMutationInput, NetworkDeviceUncheckedUpdateManyInput>
    /**
     * Filter which NetworkDevices to update
     */
    where?: NetworkDeviceWhereInput
    /**
     * Limit how many NetworkDevices to update.
     */
    limit?: number
  }

  /**
   * NetworkDevice updateManyAndReturn
   */
  export type NetworkDeviceUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NetworkDevice
     */
    select?: NetworkDeviceSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the NetworkDevice
     */
    omit?: NetworkDeviceOmit<ExtArgs> | null
    /**
     * The data used to update NetworkDevices.
     */
    data: XOR<NetworkDeviceUpdateManyMutationInput, NetworkDeviceUncheckedUpdateManyInput>
    /**
     * Filter which NetworkDevices to update
     */
    where?: NetworkDeviceWhereInput
    /**
     * Limit how many NetworkDevices to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NetworkDeviceIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * NetworkDevice upsert
   */
  export type NetworkDeviceUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NetworkDevice
     */
    select?: NetworkDeviceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the NetworkDevice
     */
    omit?: NetworkDeviceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NetworkDeviceInclude<ExtArgs> | null
    /**
     * The filter to search for the NetworkDevice to update in case it exists.
     */
    where: NetworkDeviceWhereUniqueInput
    /**
     * In case the NetworkDevice found by the `where` argument doesn't exist, create a new NetworkDevice with this data.
     */
    create: XOR<NetworkDeviceCreateInput, NetworkDeviceUncheckedCreateInput>
    /**
     * In case the NetworkDevice was found with the provided `where` argument, update it with this data.
     */
    update: XOR<NetworkDeviceUpdateInput, NetworkDeviceUncheckedUpdateInput>
  }

  /**
   * NetworkDevice delete
   */
  export type NetworkDeviceDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NetworkDevice
     */
    select?: NetworkDeviceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the NetworkDevice
     */
    omit?: NetworkDeviceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NetworkDeviceInclude<ExtArgs> | null
    /**
     * Filter which NetworkDevice to delete.
     */
    where: NetworkDeviceWhereUniqueInput
  }

  /**
   * NetworkDevice deleteMany
   */
  export type NetworkDeviceDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which NetworkDevices to delete
     */
    where?: NetworkDeviceWhereInput
    /**
     * Limit how many NetworkDevices to delete.
     */
    limit?: number
  }

  /**
   * NetworkDevice.site
   */
  export type NetworkDevice$siteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Site
     */
    select?: SiteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Site
     */
    omit?: SiteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SiteInclude<ExtArgs> | null
    where?: SiteWhereInput
  }

  /**
   * NetworkDevice.services
   */
  export type NetworkDevice$servicesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NetworkService
     */
    select?: NetworkServiceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the NetworkService
     */
    omit?: NetworkServiceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NetworkServiceInclude<ExtArgs> | null
    where?: NetworkServiceWhereInput
    orderBy?: NetworkServiceOrderByWithRelationInput | NetworkServiceOrderByWithRelationInput[]
    cursor?: NetworkServiceWhereUniqueInput
    take?: number
    skip?: number
    distinct?: NetworkServiceScalarFieldEnum | NetworkServiceScalarFieldEnum[]
  }

  /**
   * NetworkDevice.ips
   */
  export type NetworkDevice$ipsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NetworkIP
     */
    select?: NetworkIPSelect<ExtArgs> | null
    /**
     * Omit specific fields from the NetworkIP
     */
    omit?: NetworkIPOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NetworkIPInclude<ExtArgs> | null
    where?: NetworkIPWhereInput
    orderBy?: NetworkIPOrderByWithRelationInput | NetworkIPOrderByWithRelationInput[]
    cursor?: NetworkIPWhereUniqueInput
    take?: number
    skip?: number
    distinct?: NetworkIPScalarFieldEnum | NetworkIPScalarFieldEnum[]
  }

  /**
   * NetworkDevice without action
   */
  export type NetworkDeviceDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NetworkDevice
     */
    select?: NetworkDeviceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the NetworkDevice
     */
    omit?: NetworkDeviceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NetworkDeviceInclude<ExtArgs> | null
  }


  /**
   * Model NetworkService
   */

  export type AggregateNetworkService = {
    _count: NetworkServiceCountAggregateOutputType | null
    _avg: NetworkServiceAvgAggregateOutputType | null
    _sum: NetworkServiceSumAggregateOutputType | null
    _min: NetworkServiceMinAggregateOutputType | null
    _max: NetworkServiceMaxAggregateOutputType | null
  }

  export type NetworkServiceAvgAggregateOutputType = {
    port: number | null
    externalPort: number | null
  }

  export type NetworkServiceSumAggregateOutputType = {
    port: number | null
    externalPort: number | null
  }

  export type NetworkServiceMinAggregateOutputType = {
    id: string | null
    deviceId: string | null
    name: string | null
    protocol: $Enums.Protocol | null
    port: number | null
    externalPort: number | null
    targetIp: string | null
    targetFqdn: string | null
    enabled: boolean | null
    description: string | null
    tags: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type NetworkServiceMaxAggregateOutputType = {
    id: string | null
    deviceId: string | null
    name: string | null
    protocol: $Enums.Protocol | null
    port: number | null
    externalPort: number | null
    targetIp: string | null
    targetFqdn: string | null
    enabled: boolean | null
    description: string | null
    tags: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type NetworkServiceCountAggregateOutputType = {
    id: number
    deviceId: number
    name: number
    protocol: number
    port: number
    externalPort: number
    targetIp: number
    targetFqdn: number
    enabled: number
    description: number
    tags: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type NetworkServiceAvgAggregateInputType = {
    port?: true
    externalPort?: true
  }

  export type NetworkServiceSumAggregateInputType = {
    port?: true
    externalPort?: true
  }

  export type NetworkServiceMinAggregateInputType = {
    id?: true
    deviceId?: true
    name?: true
    protocol?: true
    port?: true
    externalPort?: true
    targetIp?: true
    targetFqdn?: true
    enabled?: true
    description?: true
    tags?: true
    createdAt?: true
    updatedAt?: true
  }

  export type NetworkServiceMaxAggregateInputType = {
    id?: true
    deviceId?: true
    name?: true
    protocol?: true
    port?: true
    externalPort?: true
    targetIp?: true
    targetFqdn?: true
    enabled?: true
    description?: true
    tags?: true
    createdAt?: true
    updatedAt?: true
  }

  export type NetworkServiceCountAggregateInputType = {
    id?: true
    deviceId?: true
    name?: true
    protocol?: true
    port?: true
    externalPort?: true
    targetIp?: true
    targetFqdn?: true
    enabled?: true
    description?: true
    tags?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type NetworkServiceAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which NetworkService to aggregate.
     */
    where?: NetworkServiceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of NetworkServices to fetch.
     */
    orderBy?: NetworkServiceOrderByWithRelationInput | NetworkServiceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: NetworkServiceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` NetworkServices from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` NetworkServices.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned NetworkServices
    **/
    _count?: true | NetworkServiceCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: NetworkServiceAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: NetworkServiceSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: NetworkServiceMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: NetworkServiceMaxAggregateInputType
  }

  export type GetNetworkServiceAggregateType<T extends NetworkServiceAggregateArgs> = {
        [P in keyof T & keyof AggregateNetworkService]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateNetworkService[P]>
      : GetScalarType<T[P], AggregateNetworkService[P]>
  }




  export type NetworkServiceGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: NetworkServiceWhereInput
    orderBy?: NetworkServiceOrderByWithAggregationInput | NetworkServiceOrderByWithAggregationInput[]
    by: NetworkServiceScalarFieldEnum[] | NetworkServiceScalarFieldEnum
    having?: NetworkServiceScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: NetworkServiceCountAggregateInputType | true
    _avg?: NetworkServiceAvgAggregateInputType
    _sum?: NetworkServiceSumAggregateInputType
    _min?: NetworkServiceMinAggregateInputType
    _max?: NetworkServiceMaxAggregateInputType
  }

  export type NetworkServiceGroupByOutputType = {
    id: string
    deviceId: string
    name: string
    protocol: $Enums.Protocol
    port: number
    externalPort: number | null
    targetIp: string | null
    targetFqdn: string | null
    enabled: boolean
    description: string | null
    tags: string | null
    createdAt: Date
    updatedAt: Date
    _count: NetworkServiceCountAggregateOutputType | null
    _avg: NetworkServiceAvgAggregateOutputType | null
    _sum: NetworkServiceSumAggregateOutputType | null
    _min: NetworkServiceMinAggregateOutputType | null
    _max: NetworkServiceMaxAggregateOutputType | null
  }

  type GetNetworkServiceGroupByPayload<T extends NetworkServiceGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<NetworkServiceGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof NetworkServiceGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], NetworkServiceGroupByOutputType[P]>
            : GetScalarType<T[P], NetworkServiceGroupByOutputType[P]>
        }
      >
    >


  export type NetworkServiceSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    deviceId?: boolean
    name?: boolean
    protocol?: boolean
    port?: boolean
    externalPort?: boolean
    targetIp?: boolean
    targetFqdn?: boolean
    enabled?: boolean
    description?: boolean
    tags?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    device?: boolean | NetworkDeviceDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["networkService"]>

  export type NetworkServiceSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    deviceId?: boolean
    name?: boolean
    protocol?: boolean
    port?: boolean
    externalPort?: boolean
    targetIp?: boolean
    targetFqdn?: boolean
    enabled?: boolean
    description?: boolean
    tags?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    device?: boolean | NetworkDeviceDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["networkService"]>

  export type NetworkServiceSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    deviceId?: boolean
    name?: boolean
    protocol?: boolean
    port?: boolean
    externalPort?: boolean
    targetIp?: boolean
    targetFqdn?: boolean
    enabled?: boolean
    description?: boolean
    tags?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    device?: boolean | NetworkDeviceDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["networkService"]>

  export type NetworkServiceSelectScalar = {
    id?: boolean
    deviceId?: boolean
    name?: boolean
    protocol?: boolean
    port?: boolean
    externalPort?: boolean
    targetIp?: boolean
    targetFqdn?: boolean
    enabled?: boolean
    description?: boolean
    tags?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type NetworkServiceOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "deviceId" | "name" | "protocol" | "port" | "externalPort" | "targetIp" | "targetFqdn" | "enabled" | "description" | "tags" | "createdAt" | "updatedAt", ExtArgs["result"]["networkService"]>
  export type NetworkServiceInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    device?: boolean | NetworkDeviceDefaultArgs<ExtArgs>
  }
  export type NetworkServiceIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    device?: boolean | NetworkDeviceDefaultArgs<ExtArgs>
  }
  export type NetworkServiceIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    device?: boolean | NetworkDeviceDefaultArgs<ExtArgs>
  }

  export type $NetworkServicePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "NetworkService"
    objects: {
      device: Prisma.$NetworkDevicePayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      deviceId: string
      name: string
      protocol: $Enums.Protocol
      port: number
      externalPort: number | null
      targetIp: string | null
      targetFqdn: string | null
      enabled: boolean
      description: string | null
      tags: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["networkService"]>
    composites: {}
  }

  type NetworkServiceGetPayload<S extends boolean | null | undefined | NetworkServiceDefaultArgs> = $Result.GetResult<Prisma.$NetworkServicePayload, S>

  type NetworkServiceCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<NetworkServiceFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: NetworkServiceCountAggregateInputType | true
    }

  export interface NetworkServiceDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['NetworkService'], meta: { name: 'NetworkService' } }
    /**
     * Find zero or one NetworkService that matches the filter.
     * @param {NetworkServiceFindUniqueArgs} args - Arguments to find a NetworkService
     * @example
     * // Get one NetworkService
     * const networkService = await prisma.networkService.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends NetworkServiceFindUniqueArgs>(args: SelectSubset<T, NetworkServiceFindUniqueArgs<ExtArgs>>): Prisma__NetworkServiceClient<$Result.GetResult<Prisma.$NetworkServicePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one NetworkService that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {NetworkServiceFindUniqueOrThrowArgs} args - Arguments to find a NetworkService
     * @example
     * // Get one NetworkService
     * const networkService = await prisma.networkService.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends NetworkServiceFindUniqueOrThrowArgs>(args: SelectSubset<T, NetworkServiceFindUniqueOrThrowArgs<ExtArgs>>): Prisma__NetworkServiceClient<$Result.GetResult<Prisma.$NetworkServicePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first NetworkService that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NetworkServiceFindFirstArgs} args - Arguments to find a NetworkService
     * @example
     * // Get one NetworkService
     * const networkService = await prisma.networkService.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends NetworkServiceFindFirstArgs>(args?: SelectSubset<T, NetworkServiceFindFirstArgs<ExtArgs>>): Prisma__NetworkServiceClient<$Result.GetResult<Prisma.$NetworkServicePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first NetworkService that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NetworkServiceFindFirstOrThrowArgs} args - Arguments to find a NetworkService
     * @example
     * // Get one NetworkService
     * const networkService = await prisma.networkService.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends NetworkServiceFindFirstOrThrowArgs>(args?: SelectSubset<T, NetworkServiceFindFirstOrThrowArgs<ExtArgs>>): Prisma__NetworkServiceClient<$Result.GetResult<Prisma.$NetworkServicePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more NetworkServices that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NetworkServiceFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all NetworkServices
     * const networkServices = await prisma.networkService.findMany()
     * 
     * // Get first 10 NetworkServices
     * const networkServices = await prisma.networkService.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const networkServiceWithIdOnly = await prisma.networkService.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends NetworkServiceFindManyArgs>(args?: SelectSubset<T, NetworkServiceFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$NetworkServicePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a NetworkService.
     * @param {NetworkServiceCreateArgs} args - Arguments to create a NetworkService.
     * @example
     * // Create one NetworkService
     * const NetworkService = await prisma.networkService.create({
     *   data: {
     *     // ... data to create a NetworkService
     *   }
     * })
     * 
     */
    create<T extends NetworkServiceCreateArgs>(args: SelectSubset<T, NetworkServiceCreateArgs<ExtArgs>>): Prisma__NetworkServiceClient<$Result.GetResult<Prisma.$NetworkServicePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many NetworkServices.
     * @param {NetworkServiceCreateManyArgs} args - Arguments to create many NetworkServices.
     * @example
     * // Create many NetworkServices
     * const networkService = await prisma.networkService.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends NetworkServiceCreateManyArgs>(args?: SelectSubset<T, NetworkServiceCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many NetworkServices and returns the data saved in the database.
     * @param {NetworkServiceCreateManyAndReturnArgs} args - Arguments to create many NetworkServices.
     * @example
     * // Create many NetworkServices
     * const networkService = await prisma.networkService.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many NetworkServices and only return the `id`
     * const networkServiceWithIdOnly = await prisma.networkService.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends NetworkServiceCreateManyAndReturnArgs>(args?: SelectSubset<T, NetworkServiceCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$NetworkServicePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a NetworkService.
     * @param {NetworkServiceDeleteArgs} args - Arguments to delete one NetworkService.
     * @example
     * // Delete one NetworkService
     * const NetworkService = await prisma.networkService.delete({
     *   where: {
     *     // ... filter to delete one NetworkService
     *   }
     * })
     * 
     */
    delete<T extends NetworkServiceDeleteArgs>(args: SelectSubset<T, NetworkServiceDeleteArgs<ExtArgs>>): Prisma__NetworkServiceClient<$Result.GetResult<Prisma.$NetworkServicePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one NetworkService.
     * @param {NetworkServiceUpdateArgs} args - Arguments to update one NetworkService.
     * @example
     * // Update one NetworkService
     * const networkService = await prisma.networkService.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends NetworkServiceUpdateArgs>(args: SelectSubset<T, NetworkServiceUpdateArgs<ExtArgs>>): Prisma__NetworkServiceClient<$Result.GetResult<Prisma.$NetworkServicePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more NetworkServices.
     * @param {NetworkServiceDeleteManyArgs} args - Arguments to filter NetworkServices to delete.
     * @example
     * // Delete a few NetworkServices
     * const { count } = await prisma.networkService.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends NetworkServiceDeleteManyArgs>(args?: SelectSubset<T, NetworkServiceDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more NetworkServices.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NetworkServiceUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many NetworkServices
     * const networkService = await prisma.networkService.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends NetworkServiceUpdateManyArgs>(args: SelectSubset<T, NetworkServiceUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more NetworkServices and returns the data updated in the database.
     * @param {NetworkServiceUpdateManyAndReturnArgs} args - Arguments to update many NetworkServices.
     * @example
     * // Update many NetworkServices
     * const networkService = await prisma.networkService.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more NetworkServices and only return the `id`
     * const networkServiceWithIdOnly = await prisma.networkService.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends NetworkServiceUpdateManyAndReturnArgs>(args: SelectSubset<T, NetworkServiceUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$NetworkServicePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one NetworkService.
     * @param {NetworkServiceUpsertArgs} args - Arguments to update or create a NetworkService.
     * @example
     * // Update or create a NetworkService
     * const networkService = await prisma.networkService.upsert({
     *   create: {
     *     // ... data to create a NetworkService
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the NetworkService we want to update
     *   }
     * })
     */
    upsert<T extends NetworkServiceUpsertArgs>(args: SelectSubset<T, NetworkServiceUpsertArgs<ExtArgs>>): Prisma__NetworkServiceClient<$Result.GetResult<Prisma.$NetworkServicePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of NetworkServices.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NetworkServiceCountArgs} args - Arguments to filter NetworkServices to count.
     * @example
     * // Count the number of NetworkServices
     * const count = await prisma.networkService.count({
     *   where: {
     *     // ... the filter for the NetworkServices we want to count
     *   }
     * })
    **/
    count<T extends NetworkServiceCountArgs>(
      args?: Subset<T, NetworkServiceCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], NetworkServiceCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a NetworkService.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NetworkServiceAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends NetworkServiceAggregateArgs>(args: Subset<T, NetworkServiceAggregateArgs>): Prisma.PrismaPromise<GetNetworkServiceAggregateType<T>>

    /**
     * Group by NetworkService.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NetworkServiceGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends NetworkServiceGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: NetworkServiceGroupByArgs['orderBy'] }
        : { orderBy?: NetworkServiceGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, NetworkServiceGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetNetworkServiceGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the NetworkService model
   */
  readonly fields: NetworkServiceFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for NetworkService.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__NetworkServiceClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    device<T extends NetworkDeviceDefaultArgs<ExtArgs> = {}>(args?: Subset<T, NetworkDeviceDefaultArgs<ExtArgs>>): Prisma__NetworkDeviceClient<$Result.GetResult<Prisma.$NetworkDevicePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the NetworkService model
   */
  interface NetworkServiceFieldRefs {
    readonly id: FieldRef<"NetworkService", 'String'>
    readonly deviceId: FieldRef<"NetworkService", 'String'>
    readonly name: FieldRef<"NetworkService", 'String'>
    readonly protocol: FieldRef<"NetworkService", 'Protocol'>
    readonly port: FieldRef<"NetworkService", 'Int'>
    readonly externalPort: FieldRef<"NetworkService", 'Int'>
    readonly targetIp: FieldRef<"NetworkService", 'String'>
    readonly targetFqdn: FieldRef<"NetworkService", 'String'>
    readonly enabled: FieldRef<"NetworkService", 'Boolean'>
    readonly description: FieldRef<"NetworkService", 'String'>
    readonly tags: FieldRef<"NetworkService", 'String'>
    readonly createdAt: FieldRef<"NetworkService", 'DateTime'>
    readonly updatedAt: FieldRef<"NetworkService", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * NetworkService findUnique
   */
  export type NetworkServiceFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NetworkService
     */
    select?: NetworkServiceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the NetworkService
     */
    omit?: NetworkServiceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NetworkServiceInclude<ExtArgs> | null
    /**
     * Filter, which NetworkService to fetch.
     */
    where: NetworkServiceWhereUniqueInput
  }

  /**
   * NetworkService findUniqueOrThrow
   */
  export type NetworkServiceFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NetworkService
     */
    select?: NetworkServiceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the NetworkService
     */
    omit?: NetworkServiceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NetworkServiceInclude<ExtArgs> | null
    /**
     * Filter, which NetworkService to fetch.
     */
    where: NetworkServiceWhereUniqueInput
  }

  /**
   * NetworkService findFirst
   */
  export type NetworkServiceFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NetworkService
     */
    select?: NetworkServiceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the NetworkService
     */
    omit?: NetworkServiceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NetworkServiceInclude<ExtArgs> | null
    /**
     * Filter, which NetworkService to fetch.
     */
    where?: NetworkServiceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of NetworkServices to fetch.
     */
    orderBy?: NetworkServiceOrderByWithRelationInput | NetworkServiceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for NetworkServices.
     */
    cursor?: NetworkServiceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` NetworkServices from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` NetworkServices.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of NetworkServices.
     */
    distinct?: NetworkServiceScalarFieldEnum | NetworkServiceScalarFieldEnum[]
  }

  /**
   * NetworkService findFirstOrThrow
   */
  export type NetworkServiceFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NetworkService
     */
    select?: NetworkServiceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the NetworkService
     */
    omit?: NetworkServiceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NetworkServiceInclude<ExtArgs> | null
    /**
     * Filter, which NetworkService to fetch.
     */
    where?: NetworkServiceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of NetworkServices to fetch.
     */
    orderBy?: NetworkServiceOrderByWithRelationInput | NetworkServiceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for NetworkServices.
     */
    cursor?: NetworkServiceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` NetworkServices from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` NetworkServices.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of NetworkServices.
     */
    distinct?: NetworkServiceScalarFieldEnum | NetworkServiceScalarFieldEnum[]
  }

  /**
   * NetworkService findMany
   */
  export type NetworkServiceFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NetworkService
     */
    select?: NetworkServiceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the NetworkService
     */
    omit?: NetworkServiceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NetworkServiceInclude<ExtArgs> | null
    /**
     * Filter, which NetworkServices to fetch.
     */
    where?: NetworkServiceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of NetworkServices to fetch.
     */
    orderBy?: NetworkServiceOrderByWithRelationInput | NetworkServiceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing NetworkServices.
     */
    cursor?: NetworkServiceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` NetworkServices from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` NetworkServices.
     */
    skip?: number
    distinct?: NetworkServiceScalarFieldEnum | NetworkServiceScalarFieldEnum[]
  }

  /**
   * NetworkService create
   */
  export type NetworkServiceCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NetworkService
     */
    select?: NetworkServiceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the NetworkService
     */
    omit?: NetworkServiceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NetworkServiceInclude<ExtArgs> | null
    /**
     * The data needed to create a NetworkService.
     */
    data: XOR<NetworkServiceCreateInput, NetworkServiceUncheckedCreateInput>
  }

  /**
   * NetworkService createMany
   */
  export type NetworkServiceCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many NetworkServices.
     */
    data: NetworkServiceCreateManyInput | NetworkServiceCreateManyInput[]
  }

  /**
   * NetworkService createManyAndReturn
   */
  export type NetworkServiceCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NetworkService
     */
    select?: NetworkServiceSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the NetworkService
     */
    omit?: NetworkServiceOmit<ExtArgs> | null
    /**
     * The data used to create many NetworkServices.
     */
    data: NetworkServiceCreateManyInput | NetworkServiceCreateManyInput[]
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NetworkServiceIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * NetworkService update
   */
  export type NetworkServiceUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NetworkService
     */
    select?: NetworkServiceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the NetworkService
     */
    omit?: NetworkServiceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NetworkServiceInclude<ExtArgs> | null
    /**
     * The data needed to update a NetworkService.
     */
    data: XOR<NetworkServiceUpdateInput, NetworkServiceUncheckedUpdateInput>
    /**
     * Choose, which NetworkService to update.
     */
    where: NetworkServiceWhereUniqueInput
  }

  /**
   * NetworkService updateMany
   */
  export type NetworkServiceUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update NetworkServices.
     */
    data: XOR<NetworkServiceUpdateManyMutationInput, NetworkServiceUncheckedUpdateManyInput>
    /**
     * Filter which NetworkServices to update
     */
    where?: NetworkServiceWhereInput
    /**
     * Limit how many NetworkServices to update.
     */
    limit?: number
  }

  /**
   * NetworkService updateManyAndReturn
   */
  export type NetworkServiceUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NetworkService
     */
    select?: NetworkServiceSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the NetworkService
     */
    omit?: NetworkServiceOmit<ExtArgs> | null
    /**
     * The data used to update NetworkServices.
     */
    data: XOR<NetworkServiceUpdateManyMutationInput, NetworkServiceUncheckedUpdateManyInput>
    /**
     * Filter which NetworkServices to update
     */
    where?: NetworkServiceWhereInput
    /**
     * Limit how many NetworkServices to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NetworkServiceIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * NetworkService upsert
   */
  export type NetworkServiceUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NetworkService
     */
    select?: NetworkServiceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the NetworkService
     */
    omit?: NetworkServiceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NetworkServiceInclude<ExtArgs> | null
    /**
     * The filter to search for the NetworkService to update in case it exists.
     */
    where: NetworkServiceWhereUniqueInput
    /**
     * In case the NetworkService found by the `where` argument doesn't exist, create a new NetworkService with this data.
     */
    create: XOR<NetworkServiceCreateInput, NetworkServiceUncheckedCreateInput>
    /**
     * In case the NetworkService was found with the provided `where` argument, update it with this data.
     */
    update: XOR<NetworkServiceUpdateInput, NetworkServiceUncheckedUpdateInput>
  }

  /**
   * NetworkService delete
   */
  export type NetworkServiceDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NetworkService
     */
    select?: NetworkServiceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the NetworkService
     */
    omit?: NetworkServiceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NetworkServiceInclude<ExtArgs> | null
    /**
     * Filter which NetworkService to delete.
     */
    where: NetworkServiceWhereUniqueInput
  }

  /**
   * NetworkService deleteMany
   */
  export type NetworkServiceDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which NetworkServices to delete
     */
    where?: NetworkServiceWhereInput
    /**
     * Limit how many NetworkServices to delete.
     */
    limit?: number
  }

  /**
   * NetworkService without action
   */
  export type NetworkServiceDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NetworkService
     */
    select?: NetworkServiceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the NetworkService
     */
    omit?: NetworkServiceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NetworkServiceInclude<ExtArgs> | null
  }


  /**
   * Enums
   */

  export const TransactionIsolationLevel: {
    Serializable: 'Serializable'
  };

  export type TransactionIsolationLevel = (typeof TransactionIsolationLevel)[keyof typeof TransactionIsolationLevel]


  export const UserScalarFieldEnum: {
    id: 'id',
    name: 'name',
    email: 'email',
    password: 'password',
    role: 'role',
    phone: 'phone',
    address: 'address',
    city: 'city',
    state: 'state',
    zipCode: 'zipCode',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type UserScalarFieldEnum = (typeof UserScalarFieldEnum)[keyof typeof UserScalarFieldEnum]


  export const SubscriptionScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    planName: 'planName',
    price: 'price',
    status: 'status',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type SubscriptionScalarFieldEnum = (typeof SubscriptionScalarFieldEnum)[keyof typeof SubscriptionScalarFieldEnum]


  export const InvoiceScalarFieldEnum: {
    id: 'id',
    subscriptionId: 'subscriptionId',
    amount: 'amount',
    status: 'status',
    dueDate: 'dueDate',
    paidAt: 'paidAt',
    createdAt: 'createdAt'
  };

  export type InvoiceScalarFieldEnum = (typeof InvoiceScalarFieldEnum)[keyof typeof InvoiceScalarFieldEnum]


  export const MikrotikDeviceScalarFieldEnum: {
    id: 'id',
    name: 'name',
    ip: 'ip',
    mac: 'mac',
    username: 'username',
    password: 'password',
    port: 'port',
    status: 'status',
    model: 'model',
    version: 'version',
    uptime: 'uptime',
    cpu: 'cpu',
    memory: 'memory',
    interfaces: 'interfaces',
    lastSeen: 'lastSeen',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type MikrotikDeviceScalarFieldEnum = (typeof MikrotikDeviceScalarFieldEnum)[keyof typeof MikrotikDeviceScalarFieldEnum]


  export const DomainScalarFieldEnum: {
    id: 'id',
    name: 'name',
    cloudflareId: 'cloudflareId',
    status: 'status',
    nameservers: 'nameservers',
    created: 'created',
    expires: 'expires',
    sslStatus: 'sslStatus',
    dnsRecords: 'dnsRecords',
    raw: 'raw',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type DomainScalarFieldEnum = (typeof DomainScalarFieldEnum)[keyof typeof DomainScalarFieldEnum]


  export const ProxmoxServerScalarFieldEnum: {
    id: 'id',
    name: 'name',
    baseUrl: 'baseUrl',
    user: 'user',
    tokenId: 'tokenId',
    tokenSecret: 'tokenSecret',
    insecure: 'insecure',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type ProxmoxServerScalarFieldEnum = (typeof ProxmoxServerScalarFieldEnum)[keyof typeof ProxmoxServerScalarFieldEnum]


  export const ProxmoxNodeScalarFieldEnum: {
    id: 'id',
    name: 'name',
    status: 'status',
    maxcpu: 'maxcpu',
    maxmem: 'maxmem',
    cpu: 'cpu',
    mem: 'mem',
    uptime: 'uptime',
    raw: 'raw',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    serverId: 'serverId'
  };

  export type ProxmoxNodeScalarFieldEnum = (typeof ProxmoxNodeScalarFieldEnum)[keyof typeof ProxmoxNodeScalarFieldEnum]


  export const ProxmoxVMScalarFieldEnum: {
    id: 'id',
    vmid: 'vmid',
    nodeName: 'nodeName',
    serverId: 'serverId',
    name: 'name',
    type: 'type',
    status: 'status',
    maxcpu: 'maxcpu',
    maxmem: 'maxmem',
    cpu: 'cpu',
    mem: 'mem',
    tags: 'tags',
    sshHost: 'sshHost',
    sshPort: 'sshPort',
    sshUser: 'sshUser',
    raw: 'raw',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type ProxmoxVMScalarFieldEnum = (typeof ProxmoxVMScalarFieldEnum)[keyof typeof ProxmoxVMScalarFieldEnum]


  export const ProxmoxMetricScalarFieldEnum: {
    id: 'id',
    vmId: 'vmId',
    vmNumericId: 'vmNumericId',
    nodeName: 'nodeName',
    serverId: 'serverId',
    cpu: 'cpu',
    mem: 'mem',
    disk: 'disk',
    netin: 'netin',
    netout: 'netout',
    ts: 'ts'
  };

  export type ProxmoxMetricScalarFieldEnum = (typeof ProxmoxMetricScalarFieldEnum)[keyof typeof ProxmoxMetricScalarFieldEnum]


  export const SiteScalarFieldEnum: {
    id: 'id',
    name: 'name',
    address: 'address',
    notes: 'notes',
    tags: 'tags',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type SiteScalarFieldEnum = (typeof SiteScalarFieldEnum)[keyof typeof SiteScalarFieldEnum]


  export const VlanScalarFieldEnum: {
    id: 'id',
    name: 'name',
    vid: 'vid',
    siteId: 'siteId',
    description: 'description',
    tags: 'tags',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type VlanScalarFieldEnum = (typeof VlanScalarFieldEnum)[keyof typeof VlanScalarFieldEnum]


  export const NetworkSubnetScalarFieldEnum: {
    id: 'id',
    cidr: 'cidr',
    name: 'name',
    description: 'description',
    siteId: 'siteId',
    vlanId: 'vlanId',
    parentId: 'parentId',
    gatewayIpId: 'gatewayIpId',
    tags: 'tags',
    notes: 'notes',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type NetworkSubnetScalarFieldEnum = (typeof NetworkSubnetScalarFieldEnum)[keyof typeof NetworkSubnetScalarFieldEnum]


  export const NetworkIPScalarFieldEnum: {
    id: 'id',
    address: 'address',
    subnetId: 'subnetId',
    status: 'status',
    deviceId: 'deviceId',
    interface: 'interface',
    fqdn: 'fqdn',
    purpose: 'purpose',
    mac: 'mac',
    tags: 'tags',
    notes: 'notes',
    lastSeen: 'lastSeen',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type NetworkIPScalarFieldEnum = (typeof NetworkIPScalarFieldEnum)[keyof typeof NetworkIPScalarFieldEnum]


  export const NetworkDeviceScalarFieldEnum: {
    id: 'id',
    name: 'name',
    type: 'type',
    siteId: 'siteId',
    mgmtIp: 'mgmtIp',
    vendor: 'vendor',
    model: 'model',
    serial: 'serial',
    osVersion: 'osVersion',
    tags: 'tags',
    notes: 'notes',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type NetworkDeviceScalarFieldEnum = (typeof NetworkDeviceScalarFieldEnum)[keyof typeof NetworkDeviceScalarFieldEnum]


  export const NetworkServiceScalarFieldEnum: {
    id: 'id',
    deviceId: 'deviceId',
    name: 'name',
    protocol: 'protocol',
    port: 'port',
    externalPort: 'externalPort',
    targetIp: 'targetIp',
    targetFqdn: 'targetFqdn',
    enabled: 'enabled',
    description: 'description',
    tags: 'tags',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type NetworkServiceScalarFieldEnum = (typeof NetworkServiceScalarFieldEnum)[keyof typeof NetworkServiceScalarFieldEnum]


  export const SortOrder: {
    asc: 'asc',
    desc: 'desc'
  };

  export type SortOrder = (typeof SortOrder)[keyof typeof SortOrder]


  export const NullsOrder: {
    first: 'first',
    last: 'last'
  };

  export type NullsOrder = (typeof NullsOrder)[keyof typeof NullsOrder]


  /**
   * Field references
   */


  /**
   * Reference to a field of type 'String'
   */
  export type StringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String'>
    


  /**
   * Reference to a field of type 'DateTime'
   */
  export type DateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime'>
    


  /**
   * Reference to a field of type 'Float'
   */
  export type FloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float'>
    


  /**
   * Reference to a field of type 'Int'
   */
  export type IntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int'>
    


  /**
   * Reference to a field of type 'Boolean'
   */
  export type BooleanFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Boolean'>
    


  /**
   * Reference to a field of type 'BigInt'
   */
  export type BigIntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'BigInt'>
    


  /**
   * Reference to a field of type 'IPStatus'
   */
  export type EnumIPStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'IPStatus'>
    


  /**
   * Reference to a field of type 'DeviceType'
   */
  export type EnumDeviceTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DeviceType'>
    


  /**
   * Reference to a field of type 'Protocol'
   */
  export type EnumProtocolFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Protocol'>
    
  /**
   * Deep Input Types
   */


  export type UserWhereInput = {
    AND?: UserWhereInput | UserWhereInput[]
    OR?: UserWhereInput[]
    NOT?: UserWhereInput | UserWhereInput[]
    id?: StringFilter<"User"> | string
    name?: StringFilter<"User"> | string
    email?: StringFilter<"User"> | string
    password?: StringFilter<"User"> | string
    role?: StringFilter<"User"> | string
    phone?: StringNullableFilter<"User"> | string | null
    address?: StringNullableFilter<"User"> | string | null
    city?: StringNullableFilter<"User"> | string | null
    state?: StringNullableFilter<"User"> | string | null
    zipCode?: StringNullableFilter<"User"> | string | null
    createdAt?: DateTimeFilter<"User"> | Date | string
    updatedAt?: DateTimeFilter<"User"> | Date | string
    subscriptions?: SubscriptionListRelationFilter
  }

  export type UserOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    email?: SortOrder
    password?: SortOrder
    role?: SortOrder
    phone?: SortOrderInput | SortOrder
    address?: SortOrderInput | SortOrder
    city?: SortOrderInput | SortOrder
    state?: SortOrderInput | SortOrder
    zipCode?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    subscriptions?: SubscriptionOrderByRelationAggregateInput
  }

  export type UserWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    email?: string
    AND?: UserWhereInput | UserWhereInput[]
    OR?: UserWhereInput[]
    NOT?: UserWhereInput | UserWhereInput[]
    name?: StringFilter<"User"> | string
    password?: StringFilter<"User"> | string
    role?: StringFilter<"User"> | string
    phone?: StringNullableFilter<"User"> | string | null
    address?: StringNullableFilter<"User"> | string | null
    city?: StringNullableFilter<"User"> | string | null
    state?: StringNullableFilter<"User"> | string | null
    zipCode?: StringNullableFilter<"User"> | string | null
    createdAt?: DateTimeFilter<"User"> | Date | string
    updatedAt?: DateTimeFilter<"User"> | Date | string
    subscriptions?: SubscriptionListRelationFilter
  }, "id" | "email">

  export type UserOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    email?: SortOrder
    password?: SortOrder
    role?: SortOrder
    phone?: SortOrderInput | SortOrder
    address?: SortOrderInput | SortOrder
    city?: SortOrderInput | SortOrder
    state?: SortOrderInput | SortOrder
    zipCode?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: UserCountOrderByAggregateInput
    _max?: UserMaxOrderByAggregateInput
    _min?: UserMinOrderByAggregateInput
  }

  export type UserScalarWhereWithAggregatesInput = {
    AND?: UserScalarWhereWithAggregatesInput | UserScalarWhereWithAggregatesInput[]
    OR?: UserScalarWhereWithAggregatesInput[]
    NOT?: UserScalarWhereWithAggregatesInput | UserScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"User"> | string
    name?: StringWithAggregatesFilter<"User"> | string
    email?: StringWithAggregatesFilter<"User"> | string
    password?: StringWithAggregatesFilter<"User"> | string
    role?: StringWithAggregatesFilter<"User"> | string
    phone?: StringNullableWithAggregatesFilter<"User"> | string | null
    address?: StringNullableWithAggregatesFilter<"User"> | string | null
    city?: StringNullableWithAggregatesFilter<"User"> | string | null
    state?: StringNullableWithAggregatesFilter<"User"> | string | null
    zipCode?: StringNullableWithAggregatesFilter<"User"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"User"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"User"> | Date | string
  }

  export type SubscriptionWhereInput = {
    AND?: SubscriptionWhereInput | SubscriptionWhereInput[]
    OR?: SubscriptionWhereInput[]
    NOT?: SubscriptionWhereInput | SubscriptionWhereInput[]
    id?: StringFilter<"Subscription"> | string
    userId?: StringFilter<"Subscription"> | string
    planName?: StringFilter<"Subscription"> | string
    price?: FloatFilter<"Subscription"> | number
    status?: StringFilter<"Subscription"> | string
    createdAt?: DateTimeFilter<"Subscription"> | Date | string
    updatedAt?: DateTimeFilter<"Subscription"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
    invoices?: InvoiceListRelationFilter
  }

  export type SubscriptionOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    planName?: SortOrder
    price?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    user?: UserOrderByWithRelationInput
    invoices?: InvoiceOrderByRelationAggregateInput
  }

  export type SubscriptionWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: SubscriptionWhereInput | SubscriptionWhereInput[]
    OR?: SubscriptionWhereInput[]
    NOT?: SubscriptionWhereInput | SubscriptionWhereInput[]
    userId?: StringFilter<"Subscription"> | string
    planName?: StringFilter<"Subscription"> | string
    price?: FloatFilter<"Subscription"> | number
    status?: StringFilter<"Subscription"> | string
    createdAt?: DateTimeFilter<"Subscription"> | Date | string
    updatedAt?: DateTimeFilter<"Subscription"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
    invoices?: InvoiceListRelationFilter
  }, "id">

  export type SubscriptionOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    planName?: SortOrder
    price?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: SubscriptionCountOrderByAggregateInput
    _avg?: SubscriptionAvgOrderByAggregateInput
    _max?: SubscriptionMaxOrderByAggregateInput
    _min?: SubscriptionMinOrderByAggregateInput
    _sum?: SubscriptionSumOrderByAggregateInput
  }

  export type SubscriptionScalarWhereWithAggregatesInput = {
    AND?: SubscriptionScalarWhereWithAggregatesInput | SubscriptionScalarWhereWithAggregatesInput[]
    OR?: SubscriptionScalarWhereWithAggregatesInput[]
    NOT?: SubscriptionScalarWhereWithAggregatesInput | SubscriptionScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Subscription"> | string
    userId?: StringWithAggregatesFilter<"Subscription"> | string
    planName?: StringWithAggregatesFilter<"Subscription"> | string
    price?: FloatWithAggregatesFilter<"Subscription"> | number
    status?: StringWithAggregatesFilter<"Subscription"> | string
    createdAt?: DateTimeWithAggregatesFilter<"Subscription"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Subscription"> | Date | string
  }

  export type InvoiceWhereInput = {
    AND?: InvoiceWhereInput | InvoiceWhereInput[]
    OR?: InvoiceWhereInput[]
    NOT?: InvoiceWhereInput | InvoiceWhereInput[]
    id?: StringFilter<"Invoice"> | string
    subscriptionId?: StringFilter<"Invoice"> | string
    amount?: FloatFilter<"Invoice"> | number
    status?: StringFilter<"Invoice"> | string
    dueDate?: DateTimeFilter<"Invoice"> | Date | string
    paidAt?: DateTimeNullableFilter<"Invoice"> | Date | string | null
    createdAt?: DateTimeFilter<"Invoice"> | Date | string
    subscription?: XOR<SubscriptionScalarRelationFilter, SubscriptionWhereInput>
  }

  export type InvoiceOrderByWithRelationInput = {
    id?: SortOrder
    subscriptionId?: SortOrder
    amount?: SortOrder
    status?: SortOrder
    dueDate?: SortOrder
    paidAt?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    subscription?: SubscriptionOrderByWithRelationInput
  }

  export type InvoiceWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: InvoiceWhereInput | InvoiceWhereInput[]
    OR?: InvoiceWhereInput[]
    NOT?: InvoiceWhereInput | InvoiceWhereInput[]
    subscriptionId?: StringFilter<"Invoice"> | string
    amount?: FloatFilter<"Invoice"> | number
    status?: StringFilter<"Invoice"> | string
    dueDate?: DateTimeFilter<"Invoice"> | Date | string
    paidAt?: DateTimeNullableFilter<"Invoice"> | Date | string | null
    createdAt?: DateTimeFilter<"Invoice"> | Date | string
    subscription?: XOR<SubscriptionScalarRelationFilter, SubscriptionWhereInput>
  }, "id">

  export type InvoiceOrderByWithAggregationInput = {
    id?: SortOrder
    subscriptionId?: SortOrder
    amount?: SortOrder
    status?: SortOrder
    dueDate?: SortOrder
    paidAt?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    _count?: InvoiceCountOrderByAggregateInput
    _avg?: InvoiceAvgOrderByAggregateInput
    _max?: InvoiceMaxOrderByAggregateInput
    _min?: InvoiceMinOrderByAggregateInput
    _sum?: InvoiceSumOrderByAggregateInput
  }

  export type InvoiceScalarWhereWithAggregatesInput = {
    AND?: InvoiceScalarWhereWithAggregatesInput | InvoiceScalarWhereWithAggregatesInput[]
    OR?: InvoiceScalarWhereWithAggregatesInput[]
    NOT?: InvoiceScalarWhereWithAggregatesInput | InvoiceScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Invoice"> | string
    subscriptionId?: StringWithAggregatesFilter<"Invoice"> | string
    amount?: FloatWithAggregatesFilter<"Invoice"> | number
    status?: StringWithAggregatesFilter<"Invoice"> | string
    dueDate?: DateTimeWithAggregatesFilter<"Invoice"> | Date | string
    paidAt?: DateTimeNullableWithAggregatesFilter<"Invoice"> | Date | string | null
    createdAt?: DateTimeWithAggregatesFilter<"Invoice"> | Date | string
  }

  export type MikrotikDeviceWhereInput = {
    AND?: MikrotikDeviceWhereInput | MikrotikDeviceWhereInput[]
    OR?: MikrotikDeviceWhereInput[]
    NOT?: MikrotikDeviceWhereInput | MikrotikDeviceWhereInput[]
    id?: StringFilter<"MikrotikDevice"> | string
    name?: StringFilter<"MikrotikDevice"> | string
    ip?: StringFilter<"MikrotikDevice"> | string
    mac?: StringNullableFilter<"MikrotikDevice"> | string | null
    username?: StringFilter<"MikrotikDevice"> | string
    password?: StringFilter<"MikrotikDevice"> | string
    port?: IntFilter<"MikrotikDevice"> | number
    status?: StringFilter<"MikrotikDevice"> | string
    model?: StringNullableFilter<"MikrotikDevice"> | string | null
    version?: StringNullableFilter<"MikrotikDevice"> | string | null
    uptime?: StringNullableFilter<"MikrotikDevice"> | string | null
    cpu?: FloatNullableFilter<"MikrotikDevice"> | number | null
    memory?: FloatNullableFilter<"MikrotikDevice"> | number | null
    interfaces?: IntNullableFilter<"MikrotikDevice"> | number | null
    lastSeen?: DateTimeNullableFilter<"MikrotikDevice"> | Date | string | null
    createdAt?: DateTimeFilter<"MikrotikDevice"> | Date | string
    updatedAt?: DateTimeFilter<"MikrotikDevice"> | Date | string
  }

  export type MikrotikDeviceOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    ip?: SortOrder
    mac?: SortOrderInput | SortOrder
    username?: SortOrder
    password?: SortOrder
    port?: SortOrder
    status?: SortOrder
    model?: SortOrderInput | SortOrder
    version?: SortOrderInput | SortOrder
    uptime?: SortOrderInput | SortOrder
    cpu?: SortOrderInput | SortOrder
    memory?: SortOrderInput | SortOrder
    interfaces?: SortOrderInput | SortOrder
    lastSeen?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type MikrotikDeviceWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: MikrotikDeviceWhereInput | MikrotikDeviceWhereInput[]
    OR?: MikrotikDeviceWhereInput[]
    NOT?: MikrotikDeviceWhereInput | MikrotikDeviceWhereInput[]
    name?: StringFilter<"MikrotikDevice"> | string
    ip?: StringFilter<"MikrotikDevice"> | string
    mac?: StringNullableFilter<"MikrotikDevice"> | string | null
    username?: StringFilter<"MikrotikDevice"> | string
    password?: StringFilter<"MikrotikDevice"> | string
    port?: IntFilter<"MikrotikDevice"> | number
    status?: StringFilter<"MikrotikDevice"> | string
    model?: StringNullableFilter<"MikrotikDevice"> | string | null
    version?: StringNullableFilter<"MikrotikDevice"> | string | null
    uptime?: StringNullableFilter<"MikrotikDevice"> | string | null
    cpu?: FloatNullableFilter<"MikrotikDevice"> | number | null
    memory?: FloatNullableFilter<"MikrotikDevice"> | number | null
    interfaces?: IntNullableFilter<"MikrotikDevice"> | number | null
    lastSeen?: DateTimeNullableFilter<"MikrotikDevice"> | Date | string | null
    createdAt?: DateTimeFilter<"MikrotikDevice"> | Date | string
    updatedAt?: DateTimeFilter<"MikrotikDevice"> | Date | string
  }, "id">

  export type MikrotikDeviceOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    ip?: SortOrder
    mac?: SortOrderInput | SortOrder
    username?: SortOrder
    password?: SortOrder
    port?: SortOrder
    status?: SortOrder
    model?: SortOrderInput | SortOrder
    version?: SortOrderInput | SortOrder
    uptime?: SortOrderInput | SortOrder
    cpu?: SortOrderInput | SortOrder
    memory?: SortOrderInput | SortOrder
    interfaces?: SortOrderInput | SortOrder
    lastSeen?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: MikrotikDeviceCountOrderByAggregateInput
    _avg?: MikrotikDeviceAvgOrderByAggregateInput
    _max?: MikrotikDeviceMaxOrderByAggregateInput
    _min?: MikrotikDeviceMinOrderByAggregateInput
    _sum?: MikrotikDeviceSumOrderByAggregateInput
  }

  export type MikrotikDeviceScalarWhereWithAggregatesInput = {
    AND?: MikrotikDeviceScalarWhereWithAggregatesInput | MikrotikDeviceScalarWhereWithAggregatesInput[]
    OR?: MikrotikDeviceScalarWhereWithAggregatesInput[]
    NOT?: MikrotikDeviceScalarWhereWithAggregatesInput | MikrotikDeviceScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"MikrotikDevice"> | string
    name?: StringWithAggregatesFilter<"MikrotikDevice"> | string
    ip?: StringWithAggregatesFilter<"MikrotikDevice"> | string
    mac?: StringNullableWithAggregatesFilter<"MikrotikDevice"> | string | null
    username?: StringWithAggregatesFilter<"MikrotikDevice"> | string
    password?: StringWithAggregatesFilter<"MikrotikDevice"> | string
    port?: IntWithAggregatesFilter<"MikrotikDevice"> | number
    status?: StringWithAggregatesFilter<"MikrotikDevice"> | string
    model?: StringNullableWithAggregatesFilter<"MikrotikDevice"> | string | null
    version?: StringNullableWithAggregatesFilter<"MikrotikDevice"> | string | null
    uptime?: StringNullableWithAggregatesFilter<"MikrotikDevice"> | string | null
    cpu?: FloatNullableWithAggregatesFilter<"MikrotikDevice"> | number | null
    memory?: FloatNullableWithAggregatesFilter<"MikrotikDevice"> | number | null
    interfaces?: IntNullableWithAggregatesFilter<"MikrotikDevice"> | number | null
    lastSeen?: DateTimeNullableWithAggregatesFilter<"MikrotikDevice"> | Date | string | null
    createdAt?: DateTimeWithAggregatesFilter<"MikrotikDevice"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"MikrotikDevice"> | Date | string
  }

  export type DomainWhereInput = {
    AND?: DomainWhereInput | DomainWhereInput[]
    OR?: DomainWhereInput[]
    NOT?: DomainWhereInput | DomainWhereInput[]
    id?: StringFilter<"Domain"> | string
    name?: StringFilter<"Domain"> | string
    cloudflareId?: StringNullableFilter<"Domain"> | string | null
    status?: StringFilter<"Domain"> | string
    nameservers?: StringNullableFilter<"Domain"> | string | null
    created?: DateTimeNullableFilter<"Domain"> | Date | string | null
    expires?: DateTimeNullableFilter<"Domain"> | Date | string | null
    sslStatus?: StringNullableFilter<"Domain"> | string | null
    dnsRecords?: IntFilter<"Domain"> | number
    raw?: StringNullableFilter<"Domain"> | string | null
    createdAt?: DateTimeFilter<"Domain"> | Date | string
    updatedAt?: DateTimeFilter<"Domain"> | Date | string
  }

  export type DomainOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    cloudflareId?: SortOrderInput | SortOrder
    status?: SortOrder
    nameservers?: SortOrderInput | SortOrder
    created?: SortOrderInput | SortOrder
    expires?: SortOrderInput | SortOrder
    sslStatus?: SortOrderInput | SortOrder
    dnsRecords?: SortOrder
    raw?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type DomainWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    name?: string
    AND?: DomainWhereInput | DomainWhereInput[]
    OR?: DomainWhereInput[]
    NOT?: DomainWhereInput | DomainWhereInput[]
    cloudflareId?: StringNullableFilter<"Domain"> | string | null
    status?: StringFilter<"Domain"> | string
    nameservers?: StringNullableFilter<"Domain"> | string | null
    created?: DateTimeNullableFilter<"Domain"> | Date | string | null
    expires?: DateTimeNullableFilter<"Domain"> | Date | string | null
    sslStatus?: StringNullableFilter<"Domain"> | string | null
    dnsRecords?: IntFilter<"Domain"> | number
    raw?: StringNullableFilter<"Domain"> | string | null
    createdAt?: DateTimeFilter<"Domain"> | Date | string
    updatedAt?: DateTimeFilter<"Domain"> | Date | string
  }, "id" | "name">

  export type DomainOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    cloudflareId?: SortOrderInput | SortOrder
    status?: SortOrder
    nameservers?: SortOrderInput | SortOrder
    created?: SortOrderInput | SortOrder
    expires?: SortOrderInput | SortOrder
    sslStatus?: SortOrderInput | SortOrder
    dnsRecords?: SortOrder
    raw?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: DomainCountOrderByAggregateInput
    _avg?: DomainAvgOrderByAggregateInput
    _max?: DomainMaxOrderByAggregateInput
    _min?: DomainMinOrderByAggregateInput
    _sum?: DomainSumOrderByAggregateInput
  }

  export type DomainScalarWhereWithAggregatesInput = {
    AND?: DomainScalarWhereWithAggregatesInput | DomainScalarWhereWithAggregatesInput[]
    OR?: DomainScalarWhereWithAggregatesInput[]
    NOT?: DomainScalarWhereWithAggregatesInput | DomainScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Domain"> | string
    name?: StringWithAggregatesFilter<"Domain"> | string
    cloudflareId?: StringNullableWithAggregatesFilter<"Domain"> | string | null
    status?: StringWithAggregatesFilter<"Domain"> | string
    nameservers?: StringNullableWithAggregatesFilter<"Domain"> | string | null
    created?: DateTimeNullableWithAggregatesFilter<"Domain"> | Date | string | null
    expires?: DateTimeNullableWithAggregatesFilter<"Domain"> | Date | string | null
    sslStatus?: StringNullableWithAggregatesFilter<"Domain"> | string | null
    dnsRecords?: IntWithAggregatesFilter<"Domain"> | number
    raw?: StringNullableWithAggregatesFilter<"Domain"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"Domain"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Domain"> | Date | string
  }

  export type ProxmoxServerWhereInput = {
    AND?: ProxmoxServerWhereInput | ProxmoxServerWhereInput[]
    OR?: ProxmoxServerWhereInput[]
    NOT?: ProxmoxServerWhereInput | ProxmoxServerWhereInput[]
    id?: StringFilter<"ProxmoxServer"> | string
    name?: StringFilter<"ProxmoxServer"> | string
    baseUrl?: StringFilter<"ProxmoxServer"> | string
    user?: StringFilter<"ProxmoxServer"> | string
    tokenId?: StringFilter<"ProxmoxServer"> | string
    tokenSecret?: StringFilter<"ProxmoxServer"> | string
    insecure?: BoolFilter<"ProxmoxServer"> | boolean
    createdAt?: DateTimeFilter<"ProxmoxServer"> | Date | string
    updatedAt?: DateTimeFilter<"ProxmoxServer"> | Date | string
    nodes?: ProxmoxNodeListRelationFilter
    vms?: ProxmoxVMListRelationFilter
  }

  export type ProxmoxServerOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    baseUrl?: SortOrder
    user?: SortOrder
    tokenId?: SortOrder
    tokenSecret?: SortOrder
    insecure?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    nodes?: ProxmoxNodeOrderByRelationAggregateInput
    vms?: ProxmoxVMOrderByRelationAggregateInput
  }

  export type ProxmoxServerWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    name?: string
    AND?: ProxmoxServerWhereInput | ProxmoxServerWhereInput[]
    OR?: ProxmoxServerWhereInput[]
    NOT?: ProxmoxServerWhereInput | ProxmoxServerWhereInput[]
    baseUrl?: StringFilter<"ProxmoxServer"> | string
    user?: StringFilter<"ProxmoxServer"> | string
    tokenId?: StringFilter<"ProxmoxServer"> | string
    tokenSecret?: StringFilter<"ProxmoxServer"> | string
    insecure?: BoolFilter<"ProxmoxServer"> | boolean
    createdAt?: DateTimeFilter<"ProxmoxServer"> | Date | string
    updatedAt?: DateTimeFilter<"ProxmoxServer"> | Date | string
    nodes?: ProxmoxNodeListRelationFilter
    vms?: ProxmoxVMListRelationFilter
  }, "id" | "name">

  export type ProxmoxServerOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    baseUrl?: SortOrder
    user?: SortOrder
    tokenId?: SortOrder
    tokenSecret?: SortOrder
    insecure?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: ProxmoxServerCountOrderByAggregateInput
    _max?: ProxmoxServerMaxOrderByAggregateInput
    _min?: ProxmoxServerMinOrderByAggregateInput
  }

  export type ProxmoxServerScalarWhereWithAggregatesInput = {
    AND?: ProxmoxServerScalarWhereWithAggregatesInput | ProxmoxServerScalarWhereWithAggregatesInput[]
    OR?: ProxmoxServerScalarWhereWithAggregatesInput[]
    NOT?: ProxmoxServerScalarWhereWithAggregatesInput | ProxmoxServerScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"ProxmoxServer"> | string
    name?: StringWithAggregatesFilter<"ProxmoxServer"> | string
    baseUrl?: StringWithAggregatesFilter<"ProxmoxServer"> | string
    user?: StringWithAggregatesFilter<"ProxmoxServer"> | string
    tokenId?: StringWithAggregatesFilter<"ProxmoxServer"> | string
    tokenSecret?: StringWithAggregatesFilter<"ProxmoxServer"> | string
    insecure?: BoolWithAggregatesFilter<"ProxmoxServer"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"ProxmoxServer"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"ProxmoxServer"> | Date | string
  }

  export type ProxmoxNodeWhereInput = {
    AND?: ProxmoxNodeWhereInput | ProxmoxNodeWhereInput[]
    OR?: ProxmoxNodeWhereInput[]
    NOT?: ProxmoxNodeWhereInput | ProxmoxNodeWhereInput[]
    id?: StringFilter<"ProxmoxNode"> | string
    name?: StringFilter<"ProxmoxNode"> | string
    status?: StringNullableFilter<"ProxmoxNode"> | string | null
    maxcpu?: IntNullableFilter<"ProxmoxNode"> | number | null
    maxmem?: BigIntNullableFilter<"ProxmoxNode"> | bigint | number | null
    cpu?: FloatNullableFilter<"ProxmoxNode"> | number | null
    mem?: BigIntNullableFilter<"ProxmoxNode"> | bigint | number | null
    uptime?: IntNullableFilter<"ProxmoxNode"> | number | null
    raw?: StringNullableFilter<"ProxmoxNode"> | string | null
    createdAt?: DateTimeFilter<"ProxmoxNode"> | Date | string
    updatedAt?: DateTimeFilter<"ProxmoxNode"> | Date | string
    serverId?: StringNullableFilter<"ProxmoxNode"> | string | null
    vms?: ProxmoxVMListRelationFilter
    server?: XOR<ProxmoxServerNullableScalarRelationFilter, ProxmoxServerWhereInput> | null
  }

  export type ProxmoxNodeOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    status?: SortOrderInput | SortOrder
    maxcpu?: SortOrderInput | SortOrder
    maxmem?: SortOrderInput | SortOrder
    cpu?: SortOrderInput | SortOrder
    mem?: SortOrderInput | SortOrder
    uptime?: SortOrderInput | SortOrder
    raw?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    serverId?: SortOrderInput | SortOrder
    vms?: ProxmoxVMOrderByRelationAggregateInput
    server?: ProxmoxServerOrderByWithRelationInput
  }

  export type ProxmoxNodeWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    name?: string
    name_serverId?: ProxmoxNodeNameServerIdCompoundUniqueInput
    AND?: ProxmoxNodeWhereInput | ProxmoxNodeWhereInput[]
    OR?: ProxmoxNodeWhereInput[]
    NOT?: ProxmoxNodeWhereInput | ProxmoxNodeWhereInput[]
    status?: StringNullableFilter<"ProxmoxNode"> | string | null
    maxcpu?: IntNullableFilter<"ProxmoxNode"> | number | null
    maxmem?: BigIntNullableFilter<"ProxmoxNode"> | bigint | number | null
    cpu?: FloatNullableFilter<"ProxmoxNode"> | number | null
    mem?: BigIntNullableFilter<"ProxmoxNode"> | bigint | number | null
    uptime?: IntNullableFilter<"ProxmoxNode"> | number | null
    raw?: StringNullableFilter<"ProxmoxNode"> | string | null
    createdAt?: DateTimeFilter<"ProxmoxNode"> | Date | string
    updatedAt?: DateTimeFilter<"ProxmoxNode"> | Date | string
    serverId?: StringNullableFilter<"ProxmoxNode"> | string | null
    vms?: ProxmoxVMListRelationFilter
    server?: XOR<ProxmoxServerNullableScalarRelationFilter, ProxmoxServerWhereInput> | null
  }, "id" | "name" | "name_serverId">

  export type ProxmoxNodeOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    status?: SortOrderInput | SortOrder
    maxcpu?: SortOrderInput | SortOrder
    maxmem?: SortOrderInput | SortOrder
    cpu?: SortOrderInput | SortOrder
    mem?: SortOrderInput | SortOrder
    uptime?: SortOrderInput | SortOrder
    raw?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    serverId?: SortOrderInput | SortOrder
    _count?: ProxmoxNodeCountOrderByAggregateInput
    _avg?: ProxmoxNodeAvgOrderByAggregateInput
    _max?: ProxmoxNodeMaxOrderByAggregateInput
    _min?: ProxmoxNodeMinOrderByAggregateInput
    _sum?: ProxmoxNodeSumOrderByAggregateInput
  }

  export type ProxmoxNodeScalarWhereWithAggregatesInput = {
    AND?: ProxmoxNodeScalarWhereWithAggregatesInput | ProxmoxNodeScalarWhereWithAggregatesInput[]
    OR?: ProxmoxNodeScalarWhereWithAggregatesInput[]
    NOT?: ProxmoxNodeScalarWhereWithAggregatesInput | ProxmoxNodeScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"ProxmoxNode"> | string
    name?: StringWithAggregatesFilter<"ProxmoxNode"> | string
    status?: StringNullableWithAggregatesFilter<"ProxmoxNode"> | string | null
    maxcpu?: IntNullableWithAggregatesFilter<"ProxmoxNode"> | number | null
    maxmem?: BigIntNullableWithAggregatesFilter<"ProxmoxNode"> | bigint | number | null
    cpu?: FloatNullableWithAggregatesFilter<"ProxmoxNode"> | number | null
    mem?: BigIntNullableWithAggregatesFilter<"ProxmoxNode"> | bigint | number | null
    uptime?: IntNullableWithAggregatesFilter<"ProxmoxNode"> | number | null
    raw?: StringNullableWithAggregatesFilter<"ProxmoxNode"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"ProxmoxNode"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"ProxmoxNode"> | Date | string
    serverId?: StringNullableWithAggregatesFilter<"ProxmoxNode"> | string | null
  }

  export type ProxmoxVMWhereInput = {
    AND?: ProxmoxVMWhereInput | ProxmoxVMWhereInput[]
    OR?: ProxmoxVMWhereInput[]
    NOT?: ProxmoxVMWhereInput | ProxmoxVMWhereInput[]
    id?: StringFilter<"ProxmoxVM"> | string
    vmid?: IntFilter<"ProxmoxVM"> | number
    nodeName?: StringFilter<"ProxmoxVM"> | string
    serverId?: StringNullableFilter<"ProxmoxVM"> | string | null
    name?: StringNullableFilter<"ProxmoxVM"> | string | null
    type?: StringNullableFilter<"ProxmoxVM"> | string | null
    status?: StringNullableFilter<"ProxmoxVM"> | string | null
    maxcpu?: IntNullableFilter<"ProxmoxVM"> | number | null
    maxmem?: BigIntNullableFilter<"ProxmoxVM"> | bigint | number | null
    cpu?: FloatNullableFilter<"ProxmoxVM"> | number | null
    mem?: BigIntNullableFilter<"ProxmoxVM"> | bigint | number | null
    tags?: StringNullableFilter<"ProxmoxVM"> | string | null
    sshHost?: StringNullableFilter<"ProxmoxVM"> | string | null
    sshPort?: IntNullableFilter<"ProxmoxVM"> | number | null
    sshUser?: StringNullableFilter<"ProxmoxVM"> | string | null
    raw?: StringNullableFilter<"ProxmoxVM"> | string | null
    createdAt?: DateTimeFilter<"ProxmoxVM"> | Date | string
    updatedAt?: DateTimeFilter<"ProxmoxVM"> | Date | string
    node?: XOR<ProxmoxNodeNullableScalarRelationFilter, ProxmoxNodeWhereInput> | null
    metrics?: ProxmoxMetricListRelationFilter
    server?: XOR<ProxmoxServerNullableScalarRelationFilter, ProxmoxServerWhereInput> | null
  }

  export type ProxmoxVMOrderByWithRelationInput = {
    id?: SortOrder
    vmid?: SortOrder
    nodeName?: SortOrder
    serverId?: SortOrderInput | SortOrder
    name?: SortOrderInput | SortOrder
    type?: SortOrderInput | SortOrder
    status?: SortOrderInput | SortOrder
    maxcpu?: SortOrderInput | SortOrder
    maxmem?: SortOrderInput | SortOrder
    cpu?: SortOrderInput | SortOrder
    mem?: SortOrderInput | SortOrder
    tags?: SortOrderInput | SortOrder
    sshHost?: SortOrderInput | SortOrder
    sshPort?: SortOrderInput | SortOrder
    sshUser?: SortOrderInput | SortOrder
    raw?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    node?: ProxmoxNodeOrderByWithRelationInput
    metrics?: ProxmoxMetricOrderByRelationAggregateInput
    server?: ProxmoxServerOrderByWithRelationInput
  }

  export type ProxmoxVMWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    vmid_nodeName_serverId?: ProxmoxVMVmidNodeNameServerIdCompoundUniqueInput
    AND?: ProxmoxVMWhereInput | ProxmoxVMWhereInput[]
    OR?: ProxmoxVMWhereInput[]
    NOT?: ProxmoxVMWhereInput | ProxmoxVMWhereInput[]
    vmid?: IntFilter<"ProxmoxVM"> | number
    nodeName?: StringFilter<"ProxmoxVM"> | string
    serverId?: StringNullableFilter<"ProxmoxVM"> | string | null
    name?: StringNullableFilter<"ProxmoxVM"> | string | null
    type?: StringNullableFilter<"ProxmoxVM"> | string | null
    status?: StringNullableFilter<"ProxmoxVM"> | string | null
    maxcpu?: IntNullableFilter<"ProxmoxVM"> | number | null
    maxmem?: BigIntNullableFilter<"ProxmoxVM"> | bigint | number | null
    cpu?: FloatNullableFilter<"ProxmoxVM"> | number | null
    mem?: BigIntNullableFilter<"ProxmoxVM"> | bigint | number | null
    tags?: StringNullableFilter<"ProxmoxVM"> | string | null
    sshHost?: StringNullableFilter<"ProxmoxVM"> | string | null
    sshPort?: IntNullableFilter<"ProxmoxVM"> | number | null
    sshUser?: StringNullableFilter<"ProxmoxVM"> | string | null
    raw?: StringNullableFilter<"ProxmoxVM"> | string | null
    createdAt?: DateTimeFilter<"ProxmoxVM"> | Date | string
    updatedAt?: DateTimeFilter<"ProxmoxVM"> | Date | string
    node?: XOR<ProxmoxNodeNullableScalarRelationFilter, ProxmoxNodeWhereInput> | null
    metrics?: ProxmoxMetricListRelationFilter
    server?: XOR<ProxmoxServerNullableScalarRelationFilter, ProxmoxServerWhereInput> | null
  }, "id" | "vmid_nodeName_serverId">

  export type ProxmoxVMOrderByWithAggregationInput = {
    id?: SortOrder
    vmid?: SortOrder
    nodeName?: SortOrder
    serverId?: SortOrderInput | SortOrder
    name?: SortOrderInput | SortOrder
    type?: SortOrderInput | SortOrder
    status?: SortOrderInput | SortOrder
    maxcpu?: SortOrderInput | SortOrder
    maxmem?: SortOrderInput | SortOrder
    cpu?: SortOrderInput | SortOrder
    mem?: SortOrderInput | SortOrder
    tags?: SortOrderInput | SortOrder
    sshHost?: SortOrderInput | SortOrder
    sshPort?: SortOrderInput | SortOrder
    sshUser?: SortOrderInput | SortOrder
    raw?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: ProxmoxVMCountOrderByAggregateInput
    _avg?: ProxmoxVMAvgOrderByAggregateInput
    _max?: ProxmoxVMMaxOrderByAggregateInput
    _min?: ProxmoxVMMinOrderByAggregateInput
    _sum?: ProxmoxVMSumOrderByAggregateInput
  }

  export type ProxmoxVMScalarWhereWithAggregatesInput = {
    AND?: ProxmoxVMScalarWhereWithAggregatesInput | ProxmoxVMScalarWhereWithAggregatesInput[]
    OR?: ProxmoxVMScalarWhereWithAggregatesInput[]
    NOT?: ProxmoxVMScalarWhereWithAggregatesInput | ProxmoxVMScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"ProxmoxVM"> | string
    vmid?: IntWithAggregatesFilter<"ProxmoxVM"> | number
    nodeName?: StringWithAggregatesFilter<"ProxmoxVM"> | string
    serverId?: StringNullableWithAggregatesFilter<"ProxmoxVM"> | string | null
    name?: StringNullableWithAggregatesFilter<"ProxmoxVM"> | string | null
    type?: StringNullableWithAggregatesFilter<"ProxmoxVM"> | string | null
    status?: StringNullableWithAggregatesFilter<"ProxmoxVM"> | string | null
    maxcpu?: IntNullableWithAggregatesFilter<"ProxmoxVM"> | number | null
    maxmem?: BigIntNullableWithAggregatesFilter<"ProxmoxVM"> | bigint | number | null
    cpu?: FloatNullableWithAggregatesFilter<"ProxmoxVM"> | number | null
    mem?: BigIntNullableWithAggregatesFilter<"ProxmoxVM"> | bigint | number | null
    tags?: StringNullableWithAggregatesFilter<"ProxmoxVM"> | string | null
    sshHost?: StringNullableWithAggregatesFilter<"ProxmoxVM"> | string | null
    sshPort?: IntNullableWithAggregatesFilter<"ProxmoxVM"> | number | null
    sshUser?: StringNullableWithAggregatesFilter<"ProxmoxVM"> | string | null
    raw?: StringNullableWithAggregatesFilter<"ProxmoxVM"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"ProxmoxVM"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"ProxmoxVM"> | Date | string
  }

  export type ProxmoxMetricWhereInput = {
    AND?: ProxmoxMetricWhereInput | ProxmoxMetricWhereInput[]
    OR?: ProxmoxMetricWhereInput[]
    NOT?: ProxmoxMetricWhereInput | ProxmoxMetricWhereInput[]
    id?: StringFilter<"ProxmoxMetric"> | string
    vmId?: StringNullableFilter<"ProxmoxMetric"> | string | null
    vmNumericId?: IntNullableFilter<"ProxmoxMetric"> | number | null
    nodeName?: StringNullableFilter<"ProxmoxMetric"> | string | null
    serverId?: StringNullableFilter<"ProxmoxMetric"> | string | null
    cpu?: FloatNullableFilter<"ProxmoxMetric"> | number | null
    mem?: BigIntNullableFilter<"ProxmoxMetric"> | bigint | number | null
    disk?: FloatNullableFilter<"ProxmoxMetric"> | number | null
    netin?: BigIntNullableFilter<"ProxmoxMetric"> | bigint | number | null
    netout?: BigIntNullableFilter<"ProxmoxMetric"> | bigint | number | null
    ts?: DateTimeFilter<"ProxmoxMetric"> | Date | string
    vm?: XOR<ProxmoxVMNullableScalarRelationFilter, ProxmoxVMWhereInput> | null
  }

  export type ProxmoxMetricOrderByWithRelationInput = {
    id?: SortOrder
    vmId?: SortOrderInput | SortOrder
    vmNumericId?: SortOrderInput | SortOrder
    nodeName?: SortOrderInput | SortOrder
    serverId?: SortOrderInput | SortOrder
    cpu?: SortOrderInput | SortOrder
    mem?: SortOrderInput | SortOrder
    disk?: SortOrderInput | SortOrder
    netin?: SortOrderInput | SortOrder
    netout?: SortOrderInput | SortOrder
    ts?: SortOrder
    vm?: ProxmoxVMOrderByWithRelationInput
  }

  export type ProxmoxMetricWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: ProxmoxMetricWhereInput | ProxmoxMetricWhereInput[]
    OR?: ProxmoxMetricWhereInput[]
    NOT?: ProxmoxMetricWhereInput | ProxmoxMetricWhereInput[]
    vmId?: StringNullableFilter<"ProxmoxMetric"> | string | null
    vmNumericId?: IntNullableFilter<"ProxmoxMetric"> | number | null
    nodeName?: StringNullableFilter<"ProxmoxMetric"> | string | null
    serverId?: StringNullableFilter<"ProxmoxMetric"> | string | null
    cpu?: FloatNullableFilter<"ProxmoxMetric"> | number | null
    mem?: BigIntNullableFilter<"ProxmoxMetric"> | bigint | number | null
    disk?: FloatNullableFilter<"ProxmoxMetric"> | number | null
    netin?: BigIntNullableFilter<"ProxmoxMetric"> | bigint | number | null
    netout?: BigIntNullableFilter<"ProxmoxMetric"> | bigint | number | null
    ts?: DateTimeFilter<"ProxmoxMetric"> | Date | string
    vm?: XOR<ProxmoxVMNullableScalarRelationFilter, ProxmoxVMWhereInput> | null
  }, "id">

  export type ProxmoxMetricOrderByWithAggregationInput = {
    id?: SortOrder
    vmId?: SortOrderInput | SortOrder
    vmNumericId?: SortOrderInput | SortOrder
    nodeName?: SortOrderInput | SortOrder
    serverId?: SortOrderInput | SortOrder
    cpu?: SortOrderInput | SortOrder
    mem?: SortOrderInput | SortOrder
    disk?: SortOrderInput | SortOrder
    netin?: SortOrderInput | SortOrder
    netout?: SortOrderInput | SortOrder
    ts?: SortOrder
    _count?: ProxmoxMetricCountOrderByAggregateInput
    _avg?: ProxmoxMetricAvgOrderByAggregateInput
    _max?: ProxmoxMetricMaxOrderByAggregateInput
    _min?: ProxmoxMetricMinOrderByAggregateInput
    _sum?: ProxmoxMetricSumOrderByAggregateInput
  }

  export type ProxmoxMetricScalarWhereWithAggregatesInput = {
    AND?: ProxmoxMetricScalarWhereWithAggregatesInput | ProxmoxMetricScalarWhereWithAggregatesInput[]
    OR?: ProxmoxMetricScalarWhereWithAggregatesInput[]
    NOT?: ProxmoxMetricScalarWhereWithAggregatesInput | ProxmoxMetricScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"ProxmoxMetric"> | string
    vmId?: StringNullableWithAggregatesFilter<"ProxmoxMetric"> | string | null
    vmNumericId?: IntNullableWithAggregatesFilter<"ProxmoxMetric"> | number | null
    nodeName?: StringNullableWithAggregatesFilter<"ProxmoxMetric"> | string | null
    serverId?: StringNullableWithAggregatesFilter<"ProxmoxMetric"> | string | null
    cpu?: FloatNullableWithAggregatesFilter<"ProxmoxMetric"> | number | null
    mem?: BigIntNullableWithAggregatesFilter<"ProxmoxMetric"> | bigint | number | null
    disk?: FloatNullableWithAggregatesFilter<"ProxmoxMetric"> | number | null
    netin?: BigIntNullableWithAggregatesFilter<"ProxmoxMetric"> | bigint | number | null
    netout?: BigIntNullableWithAggregatesFilter<"ProxmoxMetric"> | bigint | number | null
    ts?: DateTimeWithAggregatesFilter<"ProxmoxMetric"> | Date | string
  }

  export type SiteWhereInput = {
    AND?: SiteWhereInput | SiteWhereInput[]
    OR?: SiteWhereInput[]
    NOT?: SiteWhereInput | SiteWhereInput[]
    id?: StringFilter<"Site"> | string
    name?: StringFilter<"Site"> | string
    address?: StringNullableFilter<"Site"> | string | null
    notes?: StringNullableFilter<"Site"> | string | null
    tags?: StringNullableFilter<"Site"> | string | null
    createdAt?: DateTimeFilter<"Site"> | Date | string
    updatedAt?: DateTimeFilter<"Site"> | Date | string
    subnets?: NetworkSubnetListRelationFilter
    devices?: NetworkDeviceListRelationFilter
    vlans?: VlanListRelationFilter
  }

  export type SiteOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    address?: SortOrderInput | SortOrder
    notes?: SortOrderInput | SortOrder
    tags?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    subnets?: NetworkSubnetOrderByRelationAggregateInput
    devices?: NetworkDeviceOrderByRelationAggregateInput
    vlans?: VlanOrderByRelationAggregateInput
  }

  export type SiteWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    name?: string
    AND?: SiteWhereInput | SiteWhereInput[]
    OR?: SiteWhereInput[]
    NOT?: SiteWhereInput | SiteWhereInput[]
    address?: StringNullableFilter<"Site"> | string | null
    notes?: StringNullableFilter<"Site"> | string | null
    tags?: StringNullableFilter<"Site"> | string | null
    createdAt?: DateTimeFilter<"Site"> | Date | string
    updatedAt?: DateTimeFilter<"Site"> | Date | string
    subnets?: NetworkSubnetListRelationFilter
    devices?: NetworkDeviceListRelationFilter
    vlans?: VlanListRelationFilter
  }, "id" | "name">

  export type SiteOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    address?: SortOrderInput | SortOrder
    notes?: SortOrderInput | SortOrder
    tags?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: SiteCountOrderByAggregateInput
    _max?: SiteMaxOrderByAggregateInput
    _min?: SiteMinOrderByAggregateInput
  }

  export type SiteScalarWhereWithAggregatesInput = {
    AND?: SiteScalarWhereWithAggregatesInput | SiteScalarWhereWithAggregatesInput[]
    OR?: SiteScalarWhereWithAggregatesInput[]
    NOT?: SiteScalarWhereWithAggregatesInput | SiteScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Site"> | string
    name?: StringWithAggregatesFilter<"Site"> | string
    address?: StringNullableWithAggregatesFilter<"Site"> | string | null
    notes?: StringNullableWithAggregatesFilter<"Site"> | string | null
    tags?: StringNullableWithAggregatesFilter<"Site"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"Site"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Site"> | Date | string
  }

  export type VlanWhereInput = {
    AND?: VlanWhereInput | VlanWhereInput[]
    OR?: VlanWhereInput[]
    NOT?: VlanWhereInput | VlanWhereInput[]
    id?: StringFilter<"Vlan"> | string
    name?: StringFilter<"Vlan"> | string
    vid?: IntFilter<"Vlan"> | number
    siteId?: StringNullableFilter<"Vlan"> | string | null
    description?: StringNullableFilter<"Vlan"> | string | null
    tags?: StringNullableFilter<"Vlan"> | string | null
    createdAt?: DateTimeFilter<"Vlan"> | Date | string
    updatedAt?: DateTimeFilter<"Vlan"> | Date | string
    site?: XOR<SiteNullableScalarRelationFilter, SiteWhereInput> | null
    subnets?: NetworkSubnetListRelationFilter
  }

  export type VlanOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    vid?: SortOrder
    siteId?: SortOrderInput | SortOrder
    description?: SortOrderInput | SortOrder
    tags?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    site?: SiteOrderByWithRelationInput
    subnets?: NetworkSubnetOrderByRelationAggregateInput
  }

  export type VlanWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    vid_siteId?: VlanVidSiteIdCompoundUniqueInput
    AND?: VlanWhereInput | VlanWhereInput[]
    OR?: VlanWhereInput[]
    NOT?: VlanWhereInput | VlanWhereInput[]
    name?: StringFilter<"Vlan"> | string
    vid?: IntFilter<"Vlan"> | number
    siteId?: StringNullableFilter<"Vlan"> | string | null
    description?: StringNullableFilter<"Vlan"> | string | null
    tags?: StringNullableFilter<"Vlan"> | string | null
    createdAt?: DateTimeFilter<"Vlan"> | Date | string
    updatedAt?: DateTimeFilter<"Vlan"> | Date | string
    site?: XOR<SiteNullableScalarRelationFilter, SiteWhereInput> | null
    subnets?: NetworkSubnetListRelationFilter
  }, "id" | "vid_siteId">

  export type VlanOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    vid?: SortOrder
    siteId?: SortOrderInput | SortOrder
    description?: SortOrderInput | SortOrder
    tags?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: VlanCountOrderByAggregateInput
    _avg?: VlanAvgOrderByAggregateInput
    _max?: VlanMaxOrderByAggregateInput
    _min?: VlanMinOrderByAggregateInput
    _sum?: VlanSumOrderByAggregateInput
  }

  export type VlanScalarWhereWithAggregatesInput = {
    AND?: VlanScalarWhereWithAggregatesInput | VlanScalarWhereWithAggregatesInput[]
    OR?: VlanScalarWhereWithAggregatesInput[]
    NOT?: VlanScalarWhereWithAggregatesInput | VlanScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Vlan"> | string
    name?: StringWithAggregatesFilter<"Vlan"> | string
    vid?: IntWithAggregatesFilter<"Vlan"> | number
    siteId?: StringNullableWithAggregatesFilter<"Vlan"> | string | null
    description?: StringNullableWithAggregatesFilter<"Vlan"> | string | null
    tags?: StringNullableWithAggregatesFilter<"Vlan"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"Vlan"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Vlan"> | Date | string
  }

  export type NetworkSubnetWhereInput = {
    AND?: NetworkSubnetWhereInput | NetworkSubnetWhereInput[]
    OR?: NetworkSubnetWhereInput[]
    NOT?: NetworkSubnetWhereInput | NetworkSubnetWhereInput[]
    id?: StringFilter<"NetworkSubnet"> | string
    cidr?: StringFilter<"NetworkSubnet"> | string
    name?: StringNullableFilter<"NetworkSubnet"> | string | null
    description?: StringNullableFilter<"NetworkSubnet"> | string | null
    siteId?: StringNullableFilter<"NetworkSubnet"> | string | null
    vlanId?: StringNullableFilter<"NetworkSubnet"> | string | null
    parentId?: StringNullableFilter<"NetworkSubnet"> | string | null
    gatewayIpId?: StringNullableFilter<"NetworkSubnet"> | string | null
    tags?: StringNullableFilter<"NetworkSubnet"> | string | null
    notes?: StringNullableFilter<"NetworkSubnet"> | string | null
    createdAt?: DateTimeFilter<"NetworkSubnet"> | Date | string
    updatedAt?: DateTimeFilter<"NetworkSubnet"> | Date | string
    site?: XOR<SiteNullableScalarRelationFilter, SiteWhereInput> | null
    vlan?: XOR<VlanNullableScalarRelationFilter, VlanWhereInput> | null
    parent?: XOR<NetworkSubnetNullableScalarRelationFilter, NetworkSubnetWhereInput> | null
    children?: NetworkSubnetListRelationFilter
    ips?: NetworkIPListRelationFilter
  }

  export type NetworkSubnetOrderByWithRelationInput = {
    id?: SortOrder
    cidr?: SortOrder
    name?: SortOrderInput | SortOrder
    description?: SortOrderInput | SortOrder
    siteId?: SortOrderInput | SortOrder
    vlanId?: SortOrderInput | SortOrder
    parentId?: SortOrderInput | SortOrder
    gatewayIpId?: SortOrderInput | SortOrder
    tags?: SortOrderInput | SortOrder
    notes?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    site?: SiteOrderByWithRelationInput
    vlan?: VlanOrderByWithRelationInput
    parent?: NetworkSubnetOrderByWithRelationInput
    children?: NetworkSubnetOrderByRelationAggregateInput
    ips?: NetworkIPOrderByRelationAggregateInput
  }

  export type NetworkSubnetWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: NetworkSubnetWhereInput | NetworkSubnetWhereInput[]
    OR?: NetworkSubnetWhereInput[]
    NOT?: NetworkSubnetWhereInput | NetworkSubnetWhereInput[]
    cidr?: StringFilter<"NetworkSubnet"> | string
    name?: StringNullableFilter<"NetworkSubnet"> | string | null
    description?: StringNullableFilter<"NetworkSubnet"> | string | null
    siteId?: StringNullableFilter<"NetworkSubnet"> | string | null
    vlanId?: StringNullableFilter<"NetworkSubnet"> | string | null
    parentId?: StringNullableFilter<"NetworkSubnet"> | string | null
    gatewayIpId?: StringNullableFilter<"NetworkSubnet"> | string | null
    tags?: StringNullableFilter<"NetworkSubnet"> | string | null
    notes?: StringNullableFilter<"NetworkSubnet"> | string | null
    createdAt?: DateTimeFilter<"NetworkSubnet"> | Date | string
    updatedAt?: DateTimeFilter<"NetworkSubnet"> | Date | string
    site?: XOR<SiteNullableScalarRelationFilter, SiteWhereInput> | null
    vlan?: XOR<VlanNullableScalarRelationFilter, VlanWhereInput> | null
    parent?: XOR<NetworkSubnetNullableScalarRelationFilter, NetworkSubnetWhereInput> | null
    children?: NetworkSubnetListRelationFilter
    ips?: NetworkIPListRelationFilter
  }, "id">

  export type NetworkSubnetOrderByWithAggregationInput = {
    id?: SortOrder
    cidr?: SortOrder
    name?: SortOrderInput | SortOrder
    description?: SortOrderInput | SortOrder
    siteId?: SortOrderInput | SortOrder
    vlanId?: SortOrderInput | SortOrder
    parentId?: SortOrderInput | SortOrder
    gatewayIpId?: SortOrderInput | SortOrder
    tags?: SortOrderInput | SortOrder
    notes?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: NetworkSubnetCountOrderByAggregateInput
    _max?: NetworkSubnetMaxOrderByAggregateInput
    _min?: NetworkSubnetMinOrderByAggregateInput
  }

  export type NetworkSubnetScalarWhereWithAggregatesInput = {
    AND?: NetworkSubnetScalarWhereWithAggregatesInput | NetworkSubnetScalarWhereWithAggregatesInput[]
    OR?: NetworkSubnetScalarWhereWithAggregatesInput[]
    NOT?: NetworkSubnetScalarWhereWithAggregatesInput | NetworkSubnetScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"NetworkSubnet"> | string
    cidr?: StringWithAggregatesFilter<"NetworkSubnet"> | string
    name?: StringNullableWithAggregatesFilter<"NetworkSubnet"> | string | null
    description?: StringNullableWithAggregatesFilter<"NetworkSubnet"> | string | null
    siteId?: StringNullableWithAggregatesFilter<"NetworkSubnet"> | string | null
    vlanId?: StringNullableWithAggregatesFilter<"NetworkSubnet"> | string | null
    parentId?: StringNullableWithAggregatesFilter<"NetworkSubnet"> | string | null
    gatewayIpId?: StringNullableWithAggregatesFilter<"NetworkSubnet"> | string | null
    tags?: StringNullableWithAggregatesFilter<"NetworkSubnet"> | string | null
    notes?: StringNullableWithAggregatesFilter<"NetworkSubnet"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"NetworkSubnet"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"NetworkSubnet"> | Date | string
  }

  export type NetworkIPWhereInput = {
    AND?: NetworkIPWhereInput | NetworkIPWhereInput[]
    OR?: NetworkIPWhereInput[]
    NOT?: NetworkIPWhereInput | NetworkIPWhereInput[]
    id?: StringFilter<"NetworkIP"> | string
    address?: StringFilter<"NetworkIP"> | string
    subnetId?: StringFilter<"NetworkIP"> | string
    status?: EnumIPStatusFilter<"NetworkIP"> | $Enums.IPStatus
    deviceId?: StringNullableFilter<"NetworkIP"> | string | null
    interface?: StringNullableFilter<"NetworkIP"> | string | null
    fqdn?: StringNullableFilter<"NetworkIP"> | string | null
    purpose?: StringNullableFilter<"NetworkIP"> | string | null
    mac?: StringNullableFilter<"NetworkIP"> | string | null
    tags?: StringNullableFilter<"NetworkIP"> | string | null
    notes?: StringNullableFilter<"NetworkIP"> | string | null
    lastSeen?: DateTimeNullableFilter<"NetworkIP"> | Date | string | null
    createdAt?: DateTimeFilter<"NetworkIP"> | Date | string
    updatedAt?: DateTimeFilter<"NetworkIP"> | Date | string
    subnet?: XOR<NetworkSubnetScalarRelationFilter, NetworkSubnetWhereInput>
    device?: XOR<NetworkDeviceNullableScalarRelationFilter, NetworkDeviceWhereInput> | null
  }

  export type NetworkIPOrderByWithRelationInput = {
    id?: SortOrder
    address?: SortOrder
    subnetId?: SortOrder
    status?: SortOrder
    deviceId?: SortOrderInput | SortOrder
    interface?: SortOrderInput | SortOrder
    fqdn?: SortOrderInput | SortOrder
    purpose?: SortOrderInput | SortOrder
    mac?: SortOrderInput | SortOrder
    tags?: SortOrderInput | SortOrder
    notes?: SortOrderInput | SortOrder
    lastSeen?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    subnet?: NetworkSubnetOrderByWithRelationInput
    device?: NetworkDeviceOrderByWithRelationInput
  }

  export type NetworkIPWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: NetworkIPWhereInput | NetworkIPWhereInput[]
    OR?: NetworkIPWhereInput[]
    NOT?: NetworkIPWhereInput | NetworkIPWhereInput[]
    address?: StringFilter<"NetworkIP"> | string
    subnetId?: StringFilter<"NetworkIP"> | string
    status?: EnumIPStatusFilter<"NetworkIP"> | $Enums.IPStatus
    deviceId?: StringNullableFilter<"NetworkIP"> | string | null
    interface?: StringNullableFilter<"NetworkIP"> | string | null
    fqdn?: StringNullableFilter<"NetworkIP"> | string | null
    purpose?: StringNullableFilter<"NetworkIP"> | string | null
    mac?: StringNullableFilter<"NetworkIP"> | string | null
    tags?: StringNullableFilter<"NetworkIP"> | string | null
    notes?: StringNullableFilter<"NetworkIP"> | string | null
    lastSeen?: DateTimeNullableFilter<"NetworkIP"> | Date | string | null
    createdAt?: DateTimeFilter<"NetworkIP"> | Date | string
    updatedAt?: DateTimeFilter<"NetworkIP"> | Date | string
    subnet?: XOR<NetworkSubnetScalarRelationFilter, NetworkSubnetWhereInput>
    device?: XOR<NetworkDeviceNullableScalarRelationFilter, NetworkDeviceWhereInput> | null
  }, "id">

  export type NetworkIPOrderByWithAggregationInput = {
    id?: SortOrder
    address?: SortOrder
    subnetId?: SortOrder
    status?: SortOrder
    deviceId?: SortOrderInput | SortOrder
    interface?: SortOrderInput | SortOrder
    fqdn?: SortOrderInput | SortOrder
    purpose?: SortOrderInput | SortOrder
    mac?: SortOrderInput | SortOrder
    tags?: SortOrderInput | SortOrder
    notes?: SortOrderInput | SortOrder
    lastSeen?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: NetworkIPCountOrderByAggregateInput
    _max?: NetworkIPMaxOrderByAggregateInput
    _min?: NetworkIPMinOrderByAggregateInput
  }

  export type NetworkIPScalarWhereWithAggregatesInput = {
    AND?: NetworkIPScalarWhereWithAggregatesInput | NetworkIPScalarWhereWithAggregatesInput[]
    OR?: NetworkIPScalarWhereWithAggregatesInput[]
    NOT?: NetworkIPScalarWhereWithAggregatesInput | NetworkIPScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"NetworkIP"> | string
    address?: StringWithAggregatesFilter<"NetworkIP"> | string
    subnetId?: StringWithAggregatesFilter<"NetworkIP"> | string
    status?: EnumIPStatusWithAggregatesFilter<"NetworkIP"> | $Enums.IPStatus
    deviceId?: StringNullableWithAggregatesFilter<"NetworkIP"> | string | null
    interface?: StringNullableWithAggregatesFilter<"NetworkIP"> | string | null
    fqdn?: StringNullableWithAggregatesFilter<"NetworkIP"> | string | null
    purpose?: StringNullableWithAggregatesFilter<"NetworkIP"> | string | null
    mac?: StringNullableWithAggregatesFilter<"NetworkIP"> | string | null
    tags?: StringNullableWithAggregatesFilter<"NetworkIP"> | string | null
    notes?: StringNullableWithAggregatesFilter<"NetworkIP"> | string | null
    lastSeen?: DateTimeNullableWithAggregatesFilter<"NetworkIP"> | Date | string | null
    createdAt?: DateTimeWithAggregatesFilter<"NetworkIP"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"NetworkIP"> | Date | string
  }

  export type NetworkDeviceWhereInput = {
    AND?: NetworkDeviceWhereInput | NetworkDeviceWhereInput[]
    OR?: NetworkDeviceWhereInput[]
    NOT?: NetworkDeviceWhereInput | NetworkDeviceWhereInput[]
    id?: StringFilter<"NetworkDevice"> | string
    name?: StringFilter<"NetworkDevice"> | string
    type?: EnumDeviceTypeFilter<"NetworkDevice"> | $Enums.DeviceType
    siteId?: StringNullableFilter<"NetworkDevice"> | string | null
    mgmtIp?: StringNullableFilter<"NetworkDevice"> | string | null
    vendor?: StringNullableFilter<"NetworkDevice"> | string | null
    model?: StringNullableFilter<"NetworkDevice"> | string | null
    serial?: StringNullableFilter<"NetworkDevice"> | string | null
    osVersion?: StringNullableFilter<"NetworkDevice"> | string | null
    tags?: StringNullableFilter<"NetworkDevice"> | string | null
    notes?: StringNullableFilter<"NetworkDevice"> | string | null
    createdAt?: DateTimeFilter<"NetworkDevice"> | Date | string
    updatedAt?: DateTimeFilter<"NetworkDevice"> | Date | string
    site?: XOR<SiteNullableScalarRelationFilter, SiteWhereInput> | null
    services?: NetworkServiceListRelationFilter
    ips?: NetworkIPListRelationFilter
  }

  export type NetworkDeviceOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    type?: SortOrder
    siteId?: SortOrderInput | SortOrder
    mgmtIp?: SortOrderInput | SortOrder
    vendor?: SortOrderInput | SortOrder
    model?: SortOrderInput | SortOrder
    serial?: SortOrderInput | SortOrder
    osVersion?: SortOrderInput | SortOrder
    tags?: SortOrderInput | SortOrder
    notes?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    site?: SiteOrderByWithRelationInput
    services?: NetworkServiceOrderByRelationAggregateInput
    ips?: NetworkIPOrderByRelationAggregateInput
  }

  export type NetworkDeviceWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: NetworkDeviceWhereInput | NetworkDeviceWhereInput[]
    OR?: NetworkDeviceWhereInput[]
    NOT?: NetworkDeviceWhereInput | NetworkDeviceWhereInput[]
    name?: StringFilter<"NetworkDevice"> | string
    type?: EnumDeviceTypeFilter<"NetworkDevice"> | $Enums.DeviceType
    siteId?: StringNullableFilter<"NetworkDevice"> | string | null
    mgmtIp?: StringNullableFilter<"NetworkDevice"> | string | null
    vendor?: StringNullableFilter<"NetworkDevice"> | string | null
    model?: StringNullableFilter<"NetworkDevice"> | string | null
    serial?: StringNullableFilter<"NetworkDevice"> | string | null
    osVersion?: StringNullableFilter<"NetworkDevice"> | string | null
    tags?: StringNullableFilter<"NetworkDevice"> | string | null
    notes?: StringNullableFilter<"NetworkDevice"> | string | null
    createdAt?: DateTimeFilter<"NetworkDevice"> | Date | string
    updatedAt?: DateTimeFilter<"NetworkDevice"> | Date | string
    site?: XOR<SiteNullableScalarRelationFilter, SiteWhereInput> | null
    services?: NetworkServiceListRelationFilter
    ips?: NetworkIPListRelationFilter
  }, "id">

  export type NetworkDeviceOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    type?: SortOrder
    siteId?: SortOrderInput | SortOrder
    mgmtIp?: SortOrderInput | SortOrder
    vendor?: SortOrderInput | SortOrder
    model?: SortOrderInput | SortOrder
    serial?: SortOrderInput | SortOrder
    osVersion?: SortOrderInput | SortOrder
    tags?: SortOrderInput | SortOrder
    notes?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: NetworkDeviceCountOrderByAggregateInput
    _max?: NetworkDeviceMaxOrderByAggregateInput
    _min?: NetworkDeviceMinOrderByAggregateInput
  }

  export type NetworkDeviceScalarWhereWithAggregatesInput = {
    AND?: NetworkDeviceScalarWhereWithAggregatesInput | NetworkDeviceScalarWhereWithAggregatesInput[]
    OR?: NetworkDeviceScalarWhereWithAggregatesInput[]
    NOT?: NetworkDeviceScalarWhereWithAggregatesInput | NetworkDeviceScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"NetworkDevice"> | string
    name?: StringWithAggregatesFilter<"NetworkDevice"> | string
    type?: EnumDeviceTypeWithAggregatesFilter<"NetworkDevice"> | $Enums.DeviceType
    siteId?: StringNullableWithAggregatesFilter<"NetworkDevice"> | string | null
    mgmtIp?: StringNullableWithAggregatesFilter<"NetworkDevice"> | string | null
    vendor?: StringNullableWithAggregatesFilter<"NetworkDevice"> | string | null
    model?: StringNullableWithAggregatesFilter<"NetworkDevice"> | string | null
    serial?: StringNullableWithAggregatesFilter<"NetworkDevice"> | string | null
    osVersion?: StringNullableWithAggregatesFilter<"NetworkDevice"> | string | null
    tags?: StringNullableWithAggregatesFilter<"NetworkDevice"> | string | null
    notes?: StringNullableWithAggregatesFilter<"NetworkDevice"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"NetworkDevice"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"NetworkDevice"> | Date | string
  }

  export type NetworkServiceWhereInput = {
    AND?: NetworkServiceWhereInput | NetworkServiceWhereInput[]
    OR?: NetworkServiceWhereInput[]
    NOT?: NetworkServiceWhereInput | NetworkServiceWhereInput[]
    id?: StringFilter<"NetworkService"> | string
    deviceId?: StringFilter<"NetworkService"> | string
    name?: StringFilter<"NetworkService"> | string
    protocol?: EnumProtocolFilter<"NetworkService"> | $Enums.Protocol
    port?: IntFilter<"NetworkService"> | number
    externalPort?: IntNullableFilter<"NetworkService"> | number | null
    targetIp?: StringNullableFilter<"NetworkService"> | string | null
    targetFqdn?: StringNullableFilter<"NetworkService"> | string | null
    enabled?: BoolFilter<"NetworkService"> | boolean
    description?: StringNullableFilter<"NetworkService"> | string | null
    tags?: StringNullableFilter<"NetworkService"> | string | null
    createdAt?: DateTimeFilter<"NetworkService"> | Date | string
    updatedAt?: DateTimeFilter<"NetworkService"> | Date | string
    device?: XOR<NetworkDeviceScalarRelationFilter, NetworkDeviceWhereInput>
  }

  export type NetworkServiceOrderByWithRelationInput = {
    id?: SortOrder
    deviceId?: SortOrder
    name?: SortOrder
    protocol?: SortOrder
    port?: SortOrder
    externalPort?: SortOrderInput | SortOrder
    targetIp?: SortOrderInput | SortOrder
    targetFqdn?: SortOrderInput | SortOrder
    enabled?: SortOrder
    description?: SortOrderInput | SortOrder
    tags?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    device?: NetworkDeviceOrderByWithRelationInput
  }

  export type NetworkServiceWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: NetworkServiceWhereInput | NetworkServiceWhereInput[]
    OR?: NetworkServiceWhereInput[]
    NOT?: NetworkServiceWhereInput | NetworkServiceWhereInput[]
    deviceId?: StringFilter<"NetworkService"> | string
    name?: StringFilter<"NetworkService"> | string
    protocol?: EnumProtocolFilter<"NetworkService"> | $Enums.Protocol
    port?: IntFilter<"NetworkService"> | number
    externalPort?: IntNullableFilter<"NetworkService"> | number | null
    targetIp?: StringNullableFilter<"NetworkService"> | string | null
    targetFqdn?: StringNullableFilter<"NetworkService"> | string | null
    enabled?: BoolFilter<"NetworkService"> | boolean
    description?: StringNullableFilter<"NetworkService"> | string | null
    tags?: StringNullableFilter<"NetworkService"> | string | null
    createdAt?: DateTimeFilter<"NetworkService"> | Date | string
    updatedAt?: DateTimeFilter<"NetworkService"> | Date | string
    device?: XOR<NetworkDeviceScalarRelationFilter, NetworkDeviceWhereInput>
  }, "id">

  export type NetworkServiceOrderByWithAggregationInput = {
    id?: SortOrder
    deviceId?: SortOrder
    name?: SortOrder
    protocol?: SortOrder
    port?: SortOrder
    externalPort?: SortOrderInput | SortOrder
    targetIp?: SortOrderInput | SortOrder
    targetFqdn?: SortOrderInput | SortOrder
    enabled?: SortOrder
    description?: SortOrderInput | SortOrder
    tags?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: NetworkServiceCountOrderByAggregateInput
    _avg?: NetworkServiceAvgOrderByAggregateInput
    _max?: NetworkServiceMaxOrderByAggregateInput
    _min?: NetworkServiceMinOrderByAggregateInput
    _sum?: NetworkServiceSumOrderByAggregateInput
  }

  export type NetworkServiceScalarWhereWithAggregatesInput = {
    AND?: NetworkServiceScalarWhereWithAggregatesInput | NetworkServiceScalarWhereWithAggregatesInput[]
    OR?: NetworkServiceScalarWhereWithAggregatesInput[]
    NOT?: NetworkServiceScalarWhereWithAggregatesInput | NetworkServiceScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"NetworkService"> | string
    deviceId?: StringWithAggregatesFilter<"NetworkService"> | string
    name?: StringWithAggregatesFilter<"NetworkService"> | string
    protocol?: EnumProtocolWithAggregatesFilter<"NetworkService"> | $Enums.Protocol
    port?: IntWithAggregatesFilter<"NetworkService"> | number
    externalPort?: IntNullableWithAggregatesFilter<"NetworkService"> | number | null
    targetIp?: StringNullableWithAggregatesFilter<"NetworkService"> | string | null
    targetFqdn?: StringNullableWithAggregatesFilter<"NetworkService"> | string | null
    enabled?: BoolWithAggregatesFilter<"NetworkService"> | boolean
    description?: StringNullableWithAggregatesFilter<"NetworkService"> | string | null
    tags?: StringNullableWithAggregatesFilter<"NetworkService"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"NetworkService"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"NetworkService"> | Date | string
  }

  export type UserCreateInput = {
    id?: string
    name: string
    email: string
    password: string
    role?: string
    phone?: string | null
    address?: string | null
    city?: string | null
    state?: string | null
    zipCode?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    subscriptions?: SubscriptionCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateInput = {
    id?: string
    name: string
    email: string
    password: string
    role?: string
    phone?: string | null
    address?: string | null
    city?: string | null
    state?: string | null
    zipCode?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    subscriptions?: SubscriptionUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    state?: NullableStringFieldUpdateOperationsInput | string | null
    zipCode?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    subscriptions?: SubscriptionUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    state?: NullableStringFieldUpdateOperationsInput | string | null
    zipCode?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    subscriptions?: SubscriptionUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UserCreateManyInput = {
    id?: string
    name: string
    email: string
    password: string
    role?: string
    phone?: string | null
    address?: string | null
    city?: string | null
    state?: string | null
    zipCode?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type UserUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    state?: NullableStringFieldUpdateOperationsInput | string | null
    zipCode?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    state?: NullableStringFieldUpdateOperationsInput | string | null
    zipCode?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SubscriptionCreateInput = {
    id?: string
    planName: string
    price: number
    status: string
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutSubscriptionsInput
    invoices?: InvoiceCreateNestedManyWithoutSubscriptionInput
  }

  export type SubscriptionUncheckedCreateInput = {
    id?: string
    userId: string
    planName: string
    price: number
    status: string
    createdAt?: Date | string
    updatedAt?: Date | string
    invoices?: InvoiceUncheckedCreateNestedManyWithoutSubscriptionInput
  }

  export type SubscriptionUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    planName?: StringFieldUpdateOperationsInput | string
    price?: FloatFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutSubscriptionsNestedInput
    invoices?: InvoiceUpdateManyWithoutSubscriptionNestedInput
  }

  export type SubscriptionUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    planName?: StringFieldUpdateOperationsInput | string
    price?: FloatFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    invoices?: InvoiceUncheckedUpdateManyWithoutSubscriptionNestedInput
  }

  export type SubscriptionCreateManyInput = {
    id?: string
    userId: string
    planName: string
    price: number
    status: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SubscriptionUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    planName?: StringFieldUpdateOperationsInput | string
    price?: FloatFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SubscriptionUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    planName?: StringFieldUpdateOperationsInput | string
    price?: FloatFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type InvoiceCreateInput = {
    id?: string
    amount: number
    status: string
    dueDate: Date | string
    paidAt?: Date | string | null
    createdAt?: Date | string
    subscription: SubscriptionCreateNestedOneWithoutInvoicesInput
  }

  export type InvoiceUncheckedCreateInput = {
    id?: string
    subscriptionId: string
    amount: number
    status: string
    dueDate: Date | string
    paidAt?: Date | string | null
    createdAt?: Date | string
  }

  export type InvoiceUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    amount?: FloatFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    dueDate?: DateTimeFieldUpdateOperationsInput | Date | string
    paidAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    subscription?: SubscriptionUpdateOneRequiredWithoutInvoicesNestedInput
  }

  export type InvoiceUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    subscriptionId?: StringFieldUpdateOperationsInput | string
    amount?: FloatFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    dueDate?: DateTimeFieldUpdateOperationsInput | Date | string
    paidAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type InvoiceCreateManyInput = {
    id?: string
    subscriptionId: string
    amount: number
    status: string
    dueDate: Date | string
    paidAt?: Date | string | null
    createdAt?: Date | string
  }

  export type InvoiceUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    amount?: FloatFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    dueDate?: DateTimeFieldUpdateOperationsInput | Date | string
    paidAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type InvoiceUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    subscriptionId?: StringFieldUpdateOperationsInput | string
    amount?: FloatFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    dueDate?: DateTimeFieldUpdateOperationsInput | Date | string
    paidAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MikrotikDeviceCreateInput = {
    id?: string
    name: string
    ip: string
    mac?: string | null
    username: string
    password: string
    port?: number
    status?: string
    model?: string | null
    version?: string | null
    uptime?: string | null
    cpu?: number | null
    memory?: number | null
    interfaces?: number | null
    lastSeen?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type MikrotikDeviceUncheckedCreateInput = {
    id?: string
    name: string
    ip: string
    mac?: string | null
    username: string
    password: string
    port?: number
    status?: string
    model?: string | null
    version?: string | null
    uptime?: string | null
    cpu?: number | null
    memory?: number | null
    interfaces?: number | null
    lastSeen?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type MikrotikDeviceUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    ip?: StringFieldUpdateOperationsInput | string
    mac?: NullableStringFieldUpdateOperationsInput | string | null
    username?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    port?: IntFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    model?: NullableStringFieldUpdateOperationsInput | string | null
    version?: NullableStringFieldUpdateOperationsInput | string | null
    uptime?: NullableStringFieldUpdateOperationsInput | string | null
    cpu?: NullableFloatFieldUpdateOperationsInput | number | null
    memory?: NullableFloatFieldUpdateOperationsInput | number | null
    interfaces?: NullableIntFieldUpdateOperationsInput | number | null
    lastSeen?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MikrotikDeviceUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    ip?: StringFieldUpdateOperationsInput | string
    mac?: NullableStringFieldUpdateOperationsInput | string | null
    username?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    port?: IntFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    model?: NullableStringFieldUpdateOperationsInput | string | null
    version?: NullableStringFieldUpdateOperationsInput | string | null
    uptime?: NullableStringFieldUpdateOperationsInput | string | null
    cpu?: NullableFloatFieldUpdateOperationsInput | number | null
    memory?: NullableFloatFieldUpdateOperationsInput | number | null
    interfaces?: NullableIntFieldUpdateOperationsInput | number | null
    lastSeen?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MikrotikDeviceCreateManyInput = {
    id?: string
    name: string
    ip: string
    mac?: string | null
    username: string
    password: string
    port?: number
    status?: string
    model?: string | null
    version?: string | null
    uptime?: string | null
    cpu?: number | null
    memory?: number | null
    interfaces?: number | null
    lastSeen?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type MikrotikDeviceUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    ip?: StringFieldUpdateOperationsInput | string
    mac?: NullableStringFieldUpdateOperationsInput | string | null
    username?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    port?: IntFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    model?: NullableStringFieldUpdateOperationsInput | string | null
    version?: NullableStringFieldUpdateOperationsInput | string | null
    uptime?: NullableStringFieldUpdateOperationsInput | string | null
    cpu?: NullableFloatFieldUpdateOperationsInput | number | null
    memory?: NullableFloatFieldUpdateOperationsInput | number | null
    interfaces?: NullableIntFieldUpdateOperationsInput | number | null
    lastSeen?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MikrotikDeviceUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    ip?: StringFieldUpdateOperationsInput | string
    mac?: NullableStringFieldUpdateOperationsInput | string | null
    username?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    port?: IntFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    model?: NullableStringFieldUpdateOperationsInput | string | null
    version?: NullableStringFieldUpdateOperationsInput | string | null
    uptime?: NullableStringFieldUpdateOperationsInput | string | null
    cpu?: NullableFloatFieldUpdateOperationsInput | number | null
    memory?: NullableFloatFieldUpdateOperationsInput | number | null
    interfaces?: NullableIntFieldUpdateOperationsInput | number | null
    lastSeen?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DomainCreateInput = {
    id?: string
    name: string
    cloudflareId?: string | null
    status?: string
    nameservers?: string | null
    created?: Date | string | null
    expires?: Date | string | null
    sslStatus?: string | null
    dnsRecords?: number
    raw?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type DomainUncheckedCreateInput = {
    id?: string
    name: string
    cloudflareId?: string | null
    status?: string
    nameservers?: string | null
    created?: Date | string | null
    expires?: Date | string | null
    sslStatus?: string | null
    dnsRecords?: number
    raw?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type DomainUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    cloudflareId?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    nameservers?: NullableStringFieldUpdateOperationsInput | string | null
    created?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    expires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    sslStatus?: NullableStringFieldUpdateOperationsInput | string | null
    dnsRecords?: IntFieldUpdateOperationsInput | number
    raw?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DomainUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    cloudflareId?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    nameservers?: NullableStringFieldUpdateOperationsInput | string | null
    created?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    expires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    sslStatus?: NullableStringFieldUpdateOperationsInput | string | null
    dnsRecords?: IntFieldUpdateOperationsInput | number
    raw?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DomainCreateManyInput = {
    id?: string
    name: string
    cloudflareId?: string | null
    status?: string
    nameservers?: string | null
    created?: Date | string | null
    expires?: Date | string | null
    sslStatus?: string | null
    dnsRecords?: number
    raw?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type DomainUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    cloudflareId?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    nameservers?: NullableStringFieldUpdateOperationsInput | string | null
    created?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    expires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    sslStatus?: NullableStringFieldUpdateOperationsInput | string | null
    dnsRecords?: IntFieldUpdateOperationsInput | number
    raw?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DomainUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    cloudflareId?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    nameservers?: NullableStringFieldUpdateOperationsInput | string | null
    created?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    expires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    sslStatus?: NullableStringFieldUpdateOperationsInput | string | null
    dnsRecords?: IntFieldUpdateOperationsInput | number
    raw?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProxmoxServerCreateInput = {
    id?: string
    name: string
    baseUrl: string
    user: string
    tokenId: string
    tokenSecret: string
    insecure?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    nodes?: ProxmoxNodeCreateNestedManyWithoutServerInput
    vms?: ProxmoxVMCreateNestedManyWithoutServerInput
  }

  export type ProxmoxServerUncheckedCreateInput = {
    id?: string
    name: string
    baseUrl: string
    user: string
    tokenId: string
    tokenSecret: string
    insecure?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    nodes?: ProxmoxNodeUncheckedCreateNestedManyWithoutServerInput
    vms?: ProxmoxVMUncheckedCreateNestedManyWithoutServerInput
  }

  export type ProxmoxServerUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    baseUrl?: StringFieldUpdateOperationsInput | string
    user?: StringFieldUpdateOperationsInput | string
    tokenId?: StringFieldUpdateOperationsInput | string
    tokenSecret?: StringFieldUpdateOperationsInput | string
    insecure?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    nodes?: ProxmoxNodeUpdateManyWithoutServerNestedInput
    vms?: ProxmoxVMUpdateManyWithoutServerNestedInput
  }

  export type ProxmoxServerUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    baseUrl?: StringFieldUpdateOperationsInput | string
    user?: StringFieldUpdateOperationsInput | string
    tokenId?: StringFieldUpdateOperationsInput | string
    tokenSecret?: StringFieldUpdateOperationsInput | string
    insecure?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    nodes?: ProxmoxNodeUncheckedUpdateManyWithoutServerNestedInput
    vms?: ProxmoxVMUncheckedUpdateManyWithoutServerNestedInput
  }

  export type ProxmoxServerCreateManyInput = {
    id?: string
    name: string
    baseUrl: string
    user: string
    tokenId: string
    tokenSecret: string
    insecure?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ProxmoxServerUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    baseUrl?: StringFieldUpdateOperationsInput | string
    user?: StringFieldUpdateOperationsInput | string
    tokenId?: StringFieldUpdateOperationsInput | string
    tokenSecret?: StringFieldUpdateOperationsInput | string
    insecure?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProxmoxServerUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    baseUrl?: StringFieldUpdateOperationsInput | string
    user?: StringFieldUpdateOperationsInput | string
    tokenId?: StringFieldUpdateOperationsInput | string
    tokenSecret?: StringFieldUpdateOperationsInput | string
    insecure?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProxmoxNodeCreateInput = {
    id?: string
    name: string
    status?: string | null
    maxcpu?: number | null
    maxmem?: bigint | number | null
    cpu?: number | null
    mem?: bigint | number | null
    uptime?: number | null
    raw?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    vms?: ProxmoxVMCreateNestedManyWithoutNodeInput
    server?: ProxmoxServerCreateNestedOneWithoutNodesInput
  }

  export type ProxmoxNodeUncheckedCreateInput = {
    id?: string
    name: string
    status?: string | null
    maxcpu?: number | null
    maxmem?: bigint | number | null
    cpu?: number | null
    mem?: bigint | number | null
    uptime?: number | null
    raw?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    serverId?: string | null
    vms?: ProxmoxVMUncheckedCreateNestedManyWithoutNodeInput
  }

  export type ProxmoxNodeUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    status?: NullableStringFieldUpdateOperationsInput | string | null
    maxcpu?: NullableIntFieldUpdateOperationsInput | number | null
    maxmem?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    cpu?: NullableFloatFieldUpdateOperationsInput | number | null
    mem?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    uptime?: NullableIntFieldUpdateOperationsInput | number | null
    raw?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    vms?: ProxmoxVMUpdateManyWithoutNodeNestedInput
    server?: ProxmoxServerUpdateOneWithoutNodesNestedInput
  }

  export type ProxmoxNodeUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    status?: NullableStringFieldUpdateOperationsInput | string | null
    maxcpu?: NullableIntFieldUpdateOperationsInput | number | null
    maxmem?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    cpu?: NullableFloatFieldUpdateOperationsInput | number | null
    mem?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    uptime?: NullableIntFieldUpdateOperationsInput | number | null
    raw?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    serverId?: NullableStringFieldUpdateOperationsInput | string | null
    vms?: ProxmoxVMUncheckedUpdateManyWithoutNodeNestedInput
  }

  export type ProxmoxNodeCreateManyInput = {
    id?: string
    name: string
    status?: string | null
    maxcpu?: number | null
    maxmem?: bigint | number | null
    cpu?: number | null
    mem?: bigint | number | null
    uptime?: number | null
    raw?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    serverId?: string | null
  }

  export type ProxmoxNodeUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    status?: NullableStringFieldUpdateOperationsInput | string | null
    maxcpu?: NullableIntFieldUpdateOperationsInput | number | null
    maxmem?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    cpu?: NullableFloatFieldUpdateOperationsInput | number | null
    mem?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    uptime?: NullableIntFieldUpdateOperationsInput | number | null
    raw?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProxmoxNodeUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    status?: NullableStringFieldUpdateOperationsInput | string | null
    maxcpu?: NullableIntFieldUpdateOperationsInput | number | null
    maxmem?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    cpu?: NullableFloatFieldUpdateOperationsInput | number | null
    mem?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    uptime?: NullableIntFieldUpdateOperationsInput | number | null
    raw?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    serverId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type ProxmoxVMCreateInput = {
    id?: string
    vmid: number
    name?: string | null
    type?: string | null
    status?: string | null
    maxcpu?: number | null
    maxmem?: bigint | number | null
    cpu?: number | null
    mem?: bigint | number | null
    tags?: string | null
    sshHost?: string | null
    sshPort?: number | null
    sshUser?: string | null
    raw?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    node?: ProxmoxNodeCreateNestedOneWithoutVmsInput
    metrics?: ProxmoxMetricCreateNestedManyWithoutVmInput
    server?: ProxmoxServerCreateNestedOneWithoutVmsInput
  }

  export type ProxmoxVMUncheckedCreateInput = {
    id?: string
    vmid: number
    nodeName: string
    serverId?: string | null
    name?: string | null
    type?: string | null
    status?: string | null
    maxcpu?: number | null
    maxmem?: bigint | number | null
    cpu?: number | null
    mem?: bigint | number | null
    tags?: string | null
    sshHost?: string | null
    sshPort?: number | null
    sshUser?: string | null
    raw?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    metrics?: ProxmoxMetricUncheckedCreateNestedManyWithoutVmInput
  }

  export type ProxmoxVMUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    vmid?: IntFieldUpdateOperationsInput | number
    name?: NullableStringFieldUpdateOperationsInput | string | null
    type?: NullableStringFieldUpdateOperationsInput | string | null
    status?: NullableStringFieldUpdateOperationsInput | string | null
    maxcpu?: NullableIntFieldUpdateOperationsInput | number | null
    maxmem?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    cpu?: NullableFloatFieldUpdateOperationsInput | number | null
    mem?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    tags?: NullableStringFieldUpdateOperationsInput | string | null
    sshHost?: NullableStringFieldUpdateOperationsInput | string | null
    sshPort?: NullableIntFieldUpdateOperationsInput | number | null
    sshUser?: NullableStringFieldUpdateOperationsInput | string | null
    raw?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    node?: ProxmoxNodeUpdateOneWithoutVmsNestedInput
    metrics?: ProxmoxMetricUpdateManyWithoutVmNestedInput
    server?: ProxmoxServerUpdateOneWithoutVmsNestedInput
  }

  export type ProxmoxVMUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    vmid?: IntFieldUpdateOperationsInput | number
    nodeName?: StringFieldUpdateOperationsInput | string
    serverId?: NullableStringFieldUpdateOperationsInput | string | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    type?: NullableStringFieldUpdateOperationsInput | string | null
    status?: NullableStringFieldUpdateOperationsInput | string | null
    maxcpu?: NullableIntFieldUpdateOperationsInput | number | null
    maxmem?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    cpu?: NullableFloatFieldUpdateOperationsInput | number | null
    mem?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    tags?: NullableStringFieldUpdateOperationsInput | string | null
    sshHost?: NullableStringFieldUpdateOperationsInput | string | null
    sshPort?: NullableIntFieldUpdateOperationsInput | number | null
    sshUser?: NullableStringFieldUpdateOperationsInput | string | null
    raw?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    metrics?: ProxmoxMetricUncheckedUpdateManyWithoutVmNestedInput
  }

  export type ProxmoxVMCreateManyInput = {
    id?: string
    vmid: number
    nodeName: string
    serverId?: string | null
    name?: string | null
    type?: string | null
    status?: string | null
    maxcpu?: number | null
    maxmem?: bigint | number | null
    cpu?: number | null
    mem?: bigint | number | null
    tags?: string | null
    sshHost?: string | null
    sshPort?: number | null
    sshUser?: string | null
    raw?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ProxmoxVMUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    vmid?: IntFieldUpdateOperationsInput | number
    name?: NullableStringFieldUpdateOperationsInput | string | null
    type?: NullableStringFieldUpdateOperationsInput | string | null
    status?: NullableStringFieldUpdateOperationsInput | string | null
    maxcpu?: NullableIntFieldUpdateOperationsInput | number | null
    maxmem?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    cpu?: NullableFloatFieldUpdateOperationsInput | number | null
    mem?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    tags?: NullableStringFieldUpdateOperationsInput | string | null
    sshHost?: NullableStringFieldUpdateOperationsInput | string | null
    sshPort?: NullableIntFieldUpdateOperationsInput | number | null
    sshUser?: NullableStringFieldUpdateOperationsInput | string | null
    raw?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProxmoxVMUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    vmid?: IntFieldUpdateOperationsInput | number
    nodeName?: StringFieldUpdateOperationsInput | string
    serverId?: NullableStringFieldUpdateOperationsInput | string | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    type?: NullableStringFieldUpdateOperationsInput | string | null
    status?: NullableStringFieldUpdateOperationsInput | string | null
    maxcpu?: NullableIntFieldUpdateOperationsInput | number | null
    maxmem?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    cpu?: NullableFloatFieldUpdateOperationsInput | number | null
    mem?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    tags?: NullableStringFieldUpdateOperationsInput | string | null
    sshHost?: NullableStringFieldUpdateOperationsInput | string | null
    sshPort?: NullableIntFieldUpdateOperationsInput | number | null
    sshUser?: NullableStringFieldUpdateOperationsInput | string | null
    raw?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProxmoxMetricCreateInput = {
    id?: string
    vmNumericId?: number | null
    nodeName?: string | null
    serverId?: string | null
    cpu?: number | null
    mem?: bigint | number | null
    disk?: number | null
    netin?: bigint | number | null
    netout?: bigint | number | null
    ts?: Date | string
    vm?: ProxmoxVMCreateNestedOneWithoutMetricsInput
  }

  export type ProxmoxMetricUncheckedCreateInput = {
    id?: string
    vmId?: string | null
    vmNumericId?: number | null
    nodeName?: string | null
    serverId?: string | null
    cpu?: number | null
    mem?: bigint | number | null
    disk?: number | null
    netin?: bigint | number | null
    netout?: bigint | number | null
    ts?: Date | string
  }

  export type ProxmoxMetricUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    vmNumericId?: NullableIntFieldUpdateOperationsInput | number | null
    nodeName?: NullableStringFieldUpdateOperationsInput | string | null
    serverId?: NullableStringFieldUpdateOperationsInput | string | null
    cpu?: NullableFloatFieldUpdateOperationsInput | number | null
    mem?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    disk?: NullableFloatFieldUpdateOperationsInput | number | null
    netin?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    netout?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    ts?: DateTimeFieldUpdateOperationsInput | Date | string
    vm?: ProxmoxVMUpdateOneWithoutMetricsNestedInput
  }

  export type ProxmoxMetricUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    vmId?: NullableStringFieldUpdateOperationsInput | string | null
    vmNumericId?: NullableIntFieldUpdateOperationsInput | number | null
    nodeName?: NullableStringFieldUpdateOperationsInput | string | null
    serverId?: NullableStringFieldUpdateOperationsInput | string | null
    cpu?: NullableFloatFieldUpdateOperationsInput | number | null
    mem?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    disk?: NullableFloatFieldUpdateOperationsInput | number | null
    netin?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    netout?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    ts?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProxmoxMetricCreateManyInput = {
    id?: string
    vmId?: string | null
    vmNumericId?: number | null
    nodeName?: string | null
    serverId?: string | null
    cpu?: number | null
    mem?: bigint | number | null
    disk?: number | null
    netin?: bigint | number | null
    netout?: bigint | number | null
    ts?: Date | string
  }

  export type ProxmoxMetricUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    vmNumericId?: NullableIntFieldUpdateOperationsInput | number | null
    nodeName?: NullableStringFieldUpdateOperationsInput | string | null
    serverId?: NullableStringFieldUpdateOperationsInput | string | null
    cpu?: NullableFloatFieldUpdateOperationsInput | number | null
    mem?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    disk?: NullableFloatFieldUpdateOperationsInput | number | null
    netin?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    netout?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    ts?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProxmoxMetricUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    vmId?: NullableStringFieldUpdateOperationsInput | string | null
    vmNumericId?: NullableIntFieldUpdateOperationsInput | number | null
    nodeName?: NullableStringFieldUpdateOperationsInput | string | null
    serverId?: NullableStringFieldUpdateOperationsInput | string | null
    cpu?: NullableFloatFieldUpdateOperationsInput | number | null
    mem?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    disk?: NullableFloatFieldUpdateOperationsInput | number | null
    netin?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    netout?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    ts?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SiteCreateInput = {
    id?: string
    name: string
    address?: string | null
    notes?: string | null
    tags?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    subnets?: NetworkSubnetCreateNestedManyWithoutSiteInput
    devices?: NetworkDeviceCreateNestedManyWithoutSiteInput
    vlans?: VlanCreateNestedManyWithoutSiteInput
  }

  export type SiteUncheckedCreateInput = {
    id?: string
    name: string
    address?: string | null
    notes?: string | null
    tags?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    subnets?: NetworkSubnetUncheckedCreateNestedManyWithoutSiteInput
    devices?: NetworkDeviceUncheckedCreateNestedManyWithoutSiteInput
    vlans?: VlanUncheckedCreateNestedManyWithoutSiteInput
  }

  export type SiteUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    address?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    tags?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    subnets?: NetworkSubnetUpdateManyWithoutSiteNestedInput
    devices?: NetworkDeviceUpdateManyWithoutSiteNestedInput
    vlans?: VlanUpdateManyWithoutSiteNestedInput
  }

  export type SiteUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    address?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    tags?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    subnets?: NetworkSubnetUncheckedUpdateManyWithoutSiteNestedInput
    devices?: NetworkDeviceUncheckedUpdateManyWithoutSiteNestedInput
    vlans?: VlanUncheckedUpdateManyWithoutSiteNestedInput
  }

  export type SiteCreateManyInput = {
    id?: string
    name: string
    address?: string | null
    notes?: string | null
    tags?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SiteUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    address?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    tags?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SiteUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    address?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    tags?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type VlanCreateInput = {
    id?: string
    name: string
    vid: number
    description?: string | null
    tags?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    site?: SiteCreateNestedOneWithoutVlansInput
    subnets?: NetworkSubnetCreateNestedManyWithoutVlanInput
  }

  export type VlanUncheckedCreateInput = {
    id?: string
    name: string
    vid: number
    siteId?: string | null
    description?: string | null
    tags?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    subnets?: NetworkSubnetUncheckedCreateNestedManyWithoutVlanInput
  }

  export type VlanUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    vid?: IntFieldUpdateOperationsInput | number
    description?: NullableStringFieldUpdateOperationsInput | string | null
    tags?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    site?: SiteUpdateOneWithoutVlansNestedInput
    subnets?: NetworkSubnetUpdateManyWithoutVlanNestedInput
  }

  export type VlanUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    vid?: IntFieldUpdateOperationsInput | number
    siteId?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    tags?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    subnets?: NetworkSubnetUncheckedUpdateManyWithoutVlanNestedInput
  }

  export type VlanCreateManyInput = {
    id?: string
    name: string
    vid: number
    siteId?: string | null
    description?: string | null
    tags?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type VlanUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    vid?: IntFieldUpdateOperationsInput | number
    description?: NullableStringFieldUpdateOperationsInput | string | null
    tags?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type VlanUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    vid?: IntFieldUpdateOperationsInput | number
    siteId?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    tags?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NetworkSubnetCreateInput = {
    id?: string
    cidr: string
    name?: string | null
    description?: string | null
    gatewayIpId?: string | null
    tags?: string | null
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    site?: SiteCreateNestedOneWithoutSubnetsInput
    vlan?: VlanCreateNestedOneWithoutSubnetsInput
    parent?: NetworkSubnetCreateNestedOneWithoutChildrenInput
    children?: NetworkSubnetCreateNestedManyWithoutParentInput
    ips?: NetworkIPCreateNestedManyWithoutSubnetInput
  }

  export type NetworkSubnetUncheckedCreateInput = {
    id?: string
    cidr: string
    name?: string | null
    description?: string | null
    siteId?: string | null
    vlanId?: string | null
    parentId?: string | null
    gatewayIpId?: string | null
    tags?: string | null
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    children?: NetworkSubnetUncheckedCreateNestedManyWithoutParentInput
    ips?: NetworkIPUncheckedCreateNestedManyWithoutSubnetInput
  }

  export type NetworkSubnetUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    cidr?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    gatewayIpId?: NullableStringFieldUpdateOperationsInput | string | null
    tags?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    site?: SiteUpdateOneWithoutSubnetsNestedInput
    vlan?: VlanUpdateOneWithoutSubnetsNestedInput
    parent?: NetworkSubnetUpdateOneWithoutChildrenNestedInput
    children?: NetworkSubnetUpdateManyWithoutParentNestedInput
    ips?: NetworkIPUpdateManyWithoutSubnetNestedInput
  }

  export type NetworkSubnetUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    cidr?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    siteId?: NullableStringFieldUpdateOperationsInput | string | null
    vlanId?: NullableStringFieldUpdateOperationsInput | string | null
    parentId?: NullableStringFieldUpdateOperationsInput | string | null
    gatewayIpId?: NullableStringFieldUpdateOperationsInput | string | null
    tags?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    children?: NetworkSubnetUncheckedUpdateManyWithoutParentNestedInput
    ips?: NetworkIPUncheckedUpdateManyWithoutSubnetNestedInput
  }

  export type NetworkSubnetCreateManyInput = {
    id?: string
    cidr: string
    name?: string | null
    description?: string | null
    siteId?: string | null
    vlanId?: string | null
    parentId?: string | null
    gatewayIpId?: string | null
    tags?: string | null
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type NetworkSubnetUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    cidr?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    gatewayIpId?: NullableStringFieldUpdateOperationsInput | string | null
    tags?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NetworkSubnetUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    cidr?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    siteId?: NullableStringFieldUpdateOperationsInput | string | null
    vlanId?: NullableStringFieldUpdateOperationsInput | string | null
    parentId?: NullableStringFieldUpdateOperationsInput | string | null
    gatewayIpId?: NullableStringFieldUpdateOperationsInput | string | null
    tags?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NetworkIPCreateInput = {
    id?: string
    address: string
    status?: $Enums.IPStatus
    interface?: string | null
    fqdn?: string | null
    purpose?: string | null
    mac?: string | null
    tags?: string | null
    notes?: string | null
    lastSeen?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    subnet: NetworkSubnetCreateNestedOneWithoutIpsInput
    device?: NetworkDeviceCreateNestedOneWithoutIpsInput
  }

  export type NetworkIPUncheckedCreateInput = {
    id?: string
    address: string
    subnetId: string
    status?: $Enums.IPStatus
    deviceId?: string | null
    interface?: string | null
    fqdn?: string | null
    purpose?: string | null
    mac?: string | null
    tags?: string | null
    notes?: string | null
    lastSeen?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type NetworkIPUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    status?: EnumIPStatusFieldUpdateOperationsInput | $Enums.IPStatus
    interface?: NullableStringFieldUpdateOperationsInput | string | null
    fqdn?: NullableStringFieldUpdateOperationsInput | string | null
    purpose?: NullableStringFieldUpdateOperationsInput | string | null
    mac?: NullableStringFieldUpdateOperationsInput | string | null
    tags?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    lastSeen?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    subnet?: NetworkSubnetUpdateOneRequiredWithoutIpsNestedInput
    device?: NetworkDeviceUpdateOneWithoutIpsNestedInput
  }

  export type NetworkIPUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    subnetId?: StringFieldUpdateOperationsInput | string
    status?: EnumIPStatusFieldUpdateOperationsInput | $Enums.IPStatus
    deviceId?: NullableStringFieldUpdateOperationsInput | string | null
    interface?: NullableStringFieldUpdateOperationsInput | string | null
    fqdn?: NullableStringFieldUpdateOperationsInput | string | null
    purpose?: NullableStringFieldUpdateOperationsInput | string | null
    mac?: NullableStringFieldUpdateOperationsInput | string | null
    tags?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    lastSeen?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NetworkIPCreateManyInput = {
    id?: string
    address: string
    subnetId: string
    status?: $Enums.IPStatus
    deviceId?: string | null
    interface?: string | null
    fqdn?: string | null
    purpose?: string | null
    mac?: string | null
    tags?: string | null
    notes?: string | null
    lastSeen?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type NetworkIPUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    status?: EnumIPStatusFieldUpdateOperationsInput | $Enums.IPStatus
    interface?: NullableStringFieldUpdateOperationsInput | string | null
    fqdn?: NullableStringFieldUpdateOperationsInput | string | null
    purpose?: NullableStringFieldUpdateOperationsInput | string | null
    mac?: NullableStringFieldUpdateOperationsInput | string | null
    tags?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    lastSeen?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NetworkIPUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    subnetId?: StringFieldUpdateOperationsInput | string
    status?: EnumIPStatusFieldUpdateOperationsInput | $Enums.IPStatus
    deviceId?: NullableStringFieldUpdateOperationsInput | string | null
    interface?: NullableStringFieldUpdateOperationsInput | string | null
    fqdn?: NullableStringFieldUpdateOperationsInput | string | null
    purpose?: NullableStringFieldUpdateOperationsInput | string | null
    mac?: NullableStringFieldUpdateOperationsInput | string | null
    tags?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    lastSeen?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NetworkDeviceCreateInput = {
    id?: string
    name: string
    type?: $Enums.DeviceType
    mgmtIp?: string | null
    vendor?: string | null
    model?: string | null
    serial?: string | null
    osVersion?: string | null
    tags?: string | null
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    site?: SiteCreateNestedOneWithoutDevicesInput
    services?: NetworkServiceCreateNestedManyWithoutDeviceInput
    ips?: NetworkIPCreateNestedManyWithoutDeviceInput
  }

  export type NetworkDeviceUncheckedCreateInput = {
    id?: string
    name: string
    type?: $Enums.DeviceType
    siteId?: string | null
    mgmtIp?: string | null
    vendor?: string | null
    model?: string | null
    serial?: string | null
    osVersion?: string | null
    tags?: string | null
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    services?: NetworkServiceUncheckedCreateNestedManyWithoutDeviceInput
    ips?: NetworkIPUncheckedCreateNestedManyWithoutDeviceInput
  }

  export type NetworkDeviceUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: EnumDeviceTypeFieldUpdateOperationsInput | $Enums.DeviceType
    mgmtIp?: NullableStringFieldUpdateOperationsInput | string | null
    vendor?: NullableStringFieldUpdateOperationsInput | string | null
    model?: NullableStringFieldUpdateOperationsInput | string | null
    serial?: NullableStringFieldUpdateOperationsInput | string | null
    osVersion?: NullableStringFieldUpdateOperationsInput | string | null
    tags?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    site?: SiteUpdateOneWithoutDevicesNestedInput
    services?: NetworkServiceUpdateManyWithoutDeviceNestedInput
    ips?: NetworkIPUpdateManyWithoutDeviceNestedInput
  }

  export type NetworkDeviceUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: EnumDeviceTypeFieldUpdateOperationsInput | $Enums.DeviceType
    siteId?: NullableStringFieldUpdateOperationsInput | string | null
    mgmtIp?: NullableStringFieldUpdateOperationsInput | string | null
    vendor?: NullableStringFieldUpdateOperationsInput | string | null
    model?: NullableStringFieldUpdateOperationsInput | string | null
    serial?: NullableStringFieldUpdateOperationsInput | string | null
    osVersion?: NullableStringFieldUpdateOperationsInput | string | null
    tags?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    services?: NetworkServiceUncheckedUpdateManyWithoutDeviceNestedInput
    ips?: NetworkIPUncheckedUpdateManyWithoutDeviceNestedInput
  }

  export type NetworkDeviceCreateManyInput = {
    id?: string
    name: string
    type?: $Enums.DeviceType
    siteId?: string | null
    mgmtIp?: string | null
    vendor?: string | null
    model?: string | null
    serial?: string | null
    osVersion?: string | null
    tags?: string | null
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type NetworkDeviceUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: EnumDeviceTypeFieldUpdateOperationsInput | $Enums.DeviceType
    mgmtIp?: NullableStringFieldUpdateOperationsInput | string | null
    vendor?: NullableStringFieldUpdateOperationsInput | string | null
    model?: NullableStringFieldUpdateOperationsInput | string | null
    serial?: NullableStringFieldUpdateOperationsInput | string | null
    osVersion?: NullableStringFieldUpdateOperationsInput | string | null
    tags?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NetworkDeviceUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: EnumDeviceTypeFieldUpdateOperationsInput | $Enums.DeviceType
    siteId?: NullableStringFieldUpdateOperationsInput | string | null
    mgmtIp?: NullableStringFieldUpdateOperationsInput | string | null
    vendor?: NullableStringFieldUpdateOperationsInput | string | null
    model?: NullableStringFieldUpdateOperationsInput | string | null
    serial?: NullableStringFieldUpdateOperationsInput | string | null
    osVersion?: NullableStringFieldUpdateOperationsInput | string | null
    tags?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NetworkServiceCreateInput = {
    id?: string
    name: string
    protocol?: $Enums.Protocol
    port: number
    externalPort?: number | null
    targetIp?: string | null
    targetFqdn?: string | null
    enabled?: boolean
    description?: string | null
    tags?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    device: NetworkDeviceCreateNestedOneWithoutServicesInput
  }

  export type NetworkServiceUncheckedCreateInput = {
    id?: string
    deviceId: string
    name: string
    protocol?: $Enums.Protocol
    port: number
    externalPort?: number | null
    targetIp?: string | null
    targetFqdn?: string | null
    enabled?: boolean
    description?: string | null
    tags?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type NetworkServiceUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    protocol?: EnumProtocolFieldUpdateOperationsInput | $Enums.Protocol
    port?: IntFieldUpdateOperationsInput | number
    externalPort?: NullableIntFieldUpdateOperationsInput | number | null
    targetIp?: NullableStringFieldUpdateOperationsInput | string | null
    targetFqdn?: NullableStringFieldUpdateOperationsInput | string | null
    enabled?: BoolFieldUpdateOperationsInput | boolean
    description?: NullableStringFieldUpdateOperationsInput | string | null
    tags?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    device?: NetworkDeviceUpdateOneRequiredWithoutServicesNestedInput
  }

  export type NetworkServiceUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    deviceId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    protocol?: EnumProtocolFieldUpdateOperationsInput | $Enums.Protocol
    port?: IntFieldUpdateOperationsInput | number
    externalPort?: NullableIntFieldUpdateOperationsInput | number | null
    targetIp?: NullableStringFieldUpdateOperationsInput | string | null
    targetFqdn?: NullableStringFieldUpdateOperationsInput | string | null
    enabled?: BoolFieldUpdateOperationsInput | boolean
    description?: NullableStringFieldUpdateOperationsInput | string | null
    tags?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NetworkServiceCreateManyInput = {
    id?: string
    deviceId: string
    name: string
    protocol?: $Enums.Protocol
    port: number
    externalPort?: number | null
    targetIp?: string | null
    targetFqdn?: string | null
    enabled?: boolean
    description?: string | null
    tags?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type NetworkServiceUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    protocol?: EnumProtocolFieldUpdateOperationsInput | $Enums.Protocol
    port?: IntFieldUpdateOperationsInput | number
    externalPort?: NullableIntFieldUpdateOperationsInput | number | null
    targetIp?: NullableStringFieldUpdateOperationsInput | string | null
    targetFqdn?: NullableStringFieldUpdateOperationsInput | string | null
    enabled?: BoolFieldUpdateOperationsInput | boolean
    description?: NullableStringFieldUpdateOperationsInput | string | null
    tags?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NetworkServiceUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    deviceId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    protocol?: EnumProtocolFieldUpdateOperationsInput | $Enums.Protocol
    port?: IntFieldUpdateOperationsInput | number
    externalPort?: NullableIntFieldUpdateOperationsInput | number | null
    targetIp?: NullableStringFieldUpdateOperationsInput | string | null
    targetFqdn?: NullableStringFieldUpdateOperationsInput | string | null
    enabled?: BoolFieldUpdateOperationsInput | boolean
    description?: NullableStringFieldUpdateOperationsInput | string | null
    tags?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[]
    notIn?: string[]
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type StringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | null
    notIn?: string[] | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type DateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[]
    notIn?: Date[] | string[]
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type SubscriptionListRelationFilter = {
    every?: SubscriptionWhereInput
    some?: SubscriptionWhereInput
    none?: SubscriptionWhereInput
  }

  export type SortOrderInput = {
    sort: SortOrder
    nulls?: NullsOrder
  }

  export type SubscriptionOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type UserCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    email?: SortOrder
    password?: SortOrder
    role?: SortOrder
    phone?: SortOrder
    address?: SortOrder
    city?: SortOrder
    state?: SortOrder
    zipCode?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type UserMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    email?: SortOrder
    password?: SortOrder
    role?: SortOrder
    phone?: SortOrder
    address?: SortOrder
    city?: SortOrder
    state?: SortOrder
    zipCode?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type UserMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    email?: SortOrder
    password?: SortOrder
    role?: SortOrder
    phone?: SortOrder
    address?: SortOrder
    city?: SortOrder
    state?: SortOrder
    zipCode?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type StringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[]
    notIn?: string[]
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type StringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | null
    notIn?: string[] | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type DateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[]
    notIn?: Date[] | string[]
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type FloatFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatFilter<$PrismaModel> | number
  }

  export type UserScalarRelationFilter = {
    is?: UserWhereInput
    isNot?: UserWhereInput
  }

  export type InvoiceListRelationFilter = {
    every?: InvoiceWhereInput
    some?: InvoiceWhereInput
    none?: InvoiceWhereInput
  }

  export type InvoiceOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type SubscriptionCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    planName?: SortOrder
    price?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type SubscriptionAvgOrderByAggregateInput = {
    price?: SortOrder
  }

  export type SubscriptionMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    planName?: SortOrder
    price?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type SubscriptionMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    planName?: SortOrder
    price?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type SubscriptionSumOrderByAggregateInput = {
    price?: SortOrder
  }

  export type FloatWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedFloatFilter<$PrismaModel>
    _min?: NestedFloatFilter<$PrismaModel>
    _max?: NestedFloatFilter<$PrismaModel>
  }

  export type DateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | null
    notIn?: Date[] | string[] | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type SubscriptionScalarRelationFilter = {
    is?: SubscriptionWhereInput
    isNot?: SubscriptionWhereInput
  }

  export type InvoiceCountOrderByAggregateInput = {
    id?: SortOrder
    subscriptionId?: SortOrder
    amount?: SortOrder
    status?: SortOrder
    dueDate?: SortOrder
    paidAt?: SortOrder
    createdAt?: SortOrder
  }

  export type InvoiceAvgOrderByAggregateInput = {
    amount?: SortOrder
  }

  export type InvoiceMaxOrderByAggregateInput = {
    id?: SortOrder
    subscriptionId?: SortOrder
    amount?: SortOrder
    status?: SortOrder
    dueDate?: SortOrder
    paidAt?: SortOrder
    createdAt?: SortOrder
  }

  export type InvoiceMinOrderByAggregateInput = {
    id?: SortOrder
    subscriptionId?: SortOrder
    amount?: SortOrder
    status?: SortOrder
    dueDate?: SortOrder
    paidAt?: SortOrder
    createdAt?: SortOrder
  }

  export type InvoiceSumOrderByAggregateInput = {
    amount?: SortOrder
  }

  export type DateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | null
    notIn?: Date[] | string[] | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type IntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type FloatNullableFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | null
    notIn?: number[] | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableFilter<$PrismaModel> | number | null
  }

  export type IntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | null
    notIn?: number[] | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type MikrotikDeviceCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    ip?: SortOrder
    mac?: SortOrder
    username?: SortOrder
    password?: SortOrder
    port?: SortOrder
    status?: SortOrder
    model?: SortOrder
    version?: SortOrder
    uptime?: SortOrder
    cpu?: SortOrder
    memory?: SortOrder
    interfaces?: SortOrder
    lastSeen?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type MikrotikDeviceAvgOrderByAggregateInput = {
    port?: SortOrder
    cpu?: SortOrder
    memory?: SortOrder
    interfaces?: SortOrder
  }

  export type MikrotikDeviceMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    ip?: SortOrder
    mac?: SortOrder
    username?: SortOrder
    password?: SortOrder
    port?: SortOrder
    status?: SortOrder
    model?: SortOrder
    version?: SortOrder
    uptime?: SortOrder
    cpu?: SortOrder
    memory?: SortOrder
    interfaces?: SortOrder
    lastSeen?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type MikrotikDeviceMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    ip?: SortOrder
    mac?: SortOrder
    username?: SortOrder
    password?: SortOrder
    port?: SortOrder
    status?: SortOrder
    model?: SortOrder
    version?: SortOrder
    uptime?: SortOrder
    cpu?: SortOrder
    memory?: SortOrder
    interfaces?: SortOrder
    lastSeen?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type MikrotikDeviceSumOrderByAggregateInput = {
    port?: SortOrder
    cpu?: SortOrder
    memory?: SortOrder
    interfaces?: SortOrder
  }

  export type IntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type FloatNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | null
    notIn?: number[] | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedFloatNullableFilter<$PrismaModel>
    _min?: NestedFloatNullableFilter<$PrismaModel>
    _max?: NestedFloatNullableFilter<$PrismaModel>
  }

  export type IntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | null
    notIn?: number[] | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
  }

  export type DomainCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    cloudflareId?: SortOrder
    status?: SortOrder
    nameservers?: SortOrder
    created?: SortOrder
    expires?: SortOrder
    sslStatus?: SortOrder
    dnsRecords?: SortOrder
    raw?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type DomainAvgOrderByAggregateInput = {
    dnsRecords?: SortOrder
  }

  export type DomainMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    cloudflareId?: SortOrder
    status?: SortOrder
    nameservers?: SortOrder
    created?: SortOrder
    expires?: SortOrder
    sslStatus?: SortOrder
    dnsRecords?: SortOrder
    raw?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type DomainMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    cloudflareId?: SortOrder
    status?: SortOrder
    nameservers?: SortOrder
    created?: SortOrder
    expires?: SortOrder
    sslStatus?: SortOrder
    dnsRecords?: SortOrder
    raw?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type DomainSumOrderByAggregateInput = {
    dnsRecords?: SortOrder
  }

  export type BoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type ProxmoxNodeListRelationFilter = {
    every?: ProxmoxNodeWhereInput
    some?: ProxmoxNodeWhereInput
    none?: ProxmoxNodeWhereInput
  }

  export type ProxmoxVMListRelationFilter = {
    every?: ProxmoxVMWhereInput
    some?: ProxmoxVMWhereInput
    none?: ProxmoxVMWhereInput
  }

  export type ProxmoxNodeOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ProxmoxVMOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ProxmoxServerCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    baseUrl?: SortOrder
    user?: SortOrder
    tokenId?: SortOrder
    tokenSecret?: SortOrder
    insecure?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ProxmoxServerMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    baseUrl?: SortOrder
    user?: SortOrder
    tokenId?: SortOrder
    tokenSecret?: SortOrder
    insecure?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ProxmoxServerMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    baseUrl?: SortOrder
    user?: SortOrder
    tokenId?: SortOrder
    tokenSecret?: SortOrder
    insecure?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type BoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type BigIntNullableFilter<$PrismaModel = never> = {
    equals?: bigint | number | BigIntFieldRefInput<$PrismaModel> | null
    in?: bigint[] | number[] | null
    notIn?: bigint[] | number[] | null
    lt?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    lte?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    gt?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    gte?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    not?: NestedBigIntNullableFilter<$PrismaModel> | bigint | number | null
  }

  export type ProxmoxServerNullableScalarRelationFilter = {
    is?: ProxmoxServerWhereInput | null
    isNot?: ProxmoxServerWhereInput | null
  }

  export type ProxmoxNodeNameServerIdCompoundUniqueInput = {
    name: string
    serverId: string
  }

  export type ProxmoxNodeCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    status?: SortOrder
    maxcpu?: SortOrder
    maxmem?: SortOrder
    cpu?: SortOrder
    mem?: SortOrder
    uptime?: SortOrder
    raw?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    serverId?: SortOrder
  }

  export type ProxmoxNodeAvgOrderByAggregateInput = {
    maxcpu?: SortOrder
    maxmem?: SortOrder
    cpu?: SortOrder
    mem?: SortOrder
    uptime?: SortOrder
  }

  export type ProxmoxNodeMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    status?: SortOrder
    maxcpu?: SortOrder
    maxmem?: SortOrder
    cpu?: SortOrder
    mem?: SortOrder
    uptime?: SortOrder
    raw?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    serverId?: SortOrder
  }

  export type ProxmoxNodeMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    status?: SortOrder
    maxcpu?: SortOrder
    maxmem?: SortOrder
    cpu?: SortOrder
    mem?: SortOrder
    uptime?: SortOrder
    raw?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    serverId?: SortOrder
  }

  export type ProxmoxNodeSumOrderByAggregateInput = {
    maxcpu?: SortOrder
    maxmem?: SortOrder
    cpu?: SortOrder
    mem?: SortOrder
    uptime?: SortOrder
  }

  export type BigIntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: bigint | number | BigIntFieldRefInput<$PrismaModel> | null
    in?: bigint[] | number[] | null
    notIn?: bigint[] | number[] | null
    lt?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    lte?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    gt?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    gte?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    not?: NestedBigIntNullableWithAggregatesFilter<$PrismaModel> | bigint | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedBigIntNullableFilter<$PrismaModel>
    _min?: NestedBigIntNullableFilter<$PrismaModel>
    _max?: NestedBigIntNullableFilter<$PrismaModel>
  }

  export type ProxmoxNodeNullableScalarRelationFilter = {
    is?: ProxmoxNodeWhereInput | null
    isNot?: ProxmoxNodeWhereInput | null
  }

  export type ProxmoxMetricListRelationFilter = {
    every?: ProxmoxMetricWhereInput
    some?: ProxmoxMetricWhereInput
    none?: ProxmoxMetricWhereInput
  }

  export type ProxmoxMetricOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ProxmoxVMVmidNodeNameServerIdCompoundUniqueInput = {
    vmid: number
    nodeName: string
    serverId: string
  }

  export type ProxmoxVMCountOrderByAggregateInput = {
    id?: SortOrder
    vmid?: SortOrder
    nodeName?: SortOrder
    serverId?: SortOrder
    name?: SortOrder
    type?: SortOrder
    status?: SortOrder
    maxcpu?: SortOrder
    maxmem?: SortOrder
    cpu?: SortOrder
    mem?: SortOrder
    tags?: SortOrder
    sshHost?: SortOrder
    sshPort?: SortOrder
    sshUser?: SortOrder
    raw?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ProxmoxVMAvgOrderByAggregateInput = {
    vmid?: SortOrder
    maxcpu?: SortOrder
    maxmem?: SortOrder
    cpu?: SortOrder
    mem?: SortOrder
    sshPort?: SortOrder
  }

  export type ProxmoxVMMaxOrderByAggregateInput = {
    id?: SortOrder
    vmid?: SortOrder
    nodeName?: SortOrder
    serverId?: SortOrder
    name?: SortOrder
    type?: SortOrder
    status?: SortOrder
    maxcpu?: SortOrder
    maxmem?: SortOrder
    cpu?: SortOrder
    mem?: SortOrder
    tags?: SortOrder
    sshHost?: SortOrder
    sshPort?: SortOrder
    sshUser?: SortOrder
    raw?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ProxmoxVMMinOrderByAggregateInput = {
    id?: SortOrder
    vmid?: SortOrder
    nodeName?: SortOrder
    serverId?: SortOrder
    name?: SortOrder
    type?: SortOrder
    status?: SortOrder
    maxcpu?: SortOrder
    maxmem?: SortOrder
    cpu?: SortOrder
    mem?: SortOrder
    tags?: SortOrder
    sshHost?: SortOrder
    sshPort?: SortOrder
    sshUser?: SortOrder
    raw?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ProxmoxVMSumOrderByAggregateInput = {
    vmid?: SortOrder
    maxcpu?: SortOrder
    maxmem?: SortOrder
    cpu?: SortOrder
    mem?: SortOrder
    sshPort?: SortOrder
  }

  export type ProxmoxVMNullableScalarRelationFilter = {
    is?: ProxmoxVMWhereInput | null
    isNot?: ProxmoxVMWhereInput | null
  }

  export type ProxmoxMetricCountOrderByAggregateInput = {
    id?: SortOrder
    vmId?: SortOrder
    vmNumericId?: SortOrder
    nodeName?: SortOrder
    serverId?: SortOrder
    cpu?: SortOrder
    mem?: SortOrder
    disk?: SortOrder
    netin?: SortOrder
    netout?: SortOrder
    ts?: SortOrder
  }

  export type ProxmoxMetricAvgOrderByAggregateInput = {
    vmNumericId?: SortOrder
    cpu?: SortOrder
    mem?: SortOrder
    disk?: SortOrder
    netin?: SortOrder
    netout?: SortOrder
  }

  export type ProxmoxMetricMaxOrderByAggregateInput = {
    id?: SortOrder
    vmId?: SortOrder
    vmNumericId?: SortOrder
    nodeName?: SortOrder
    serverId?: SortOrder
    cpu?: SortOrder
    mem?: SortOrder
    disk?: SortOrder
    netin?: SortOrder
    netout?: SortOrder
    ts?: SortOrder
  }

  export type ProxmoxMetricMinOrderByAggregateInput = {
    id?: SortOrder
    vmId?: SortOrder
    vmNumericId?: SortOrder
    nodeName?: SortOrder
    serverId?: SortOrder
    cpu?: SortOrder
    mem?: SortOrder
    disk?: SortOrder
    netin?: SortOrder
    netout?: SortOrder
    ts?: SortOrder
  }

  export type ProxmoxMetricSumOrderByAggregateInput = {
    vmNumericId?: SortOrder
    cpu?: SortOrder
    mem?: SortOrder
    disk?: SortOrder
    netin?: SortOrder
    netout?: SortOrder
  }

  export type NetworkSubnetListRelationFilter = {
    every?: NetworkSubnetWhereInput
    some?: NetworkSubnetWhereInput
    none?: NetworkSubnetWhereInput
  }

  export type NetworkDeviceListRelationFilter = {
    every?: NetworkDeviceWhereInput
    some?: NetworkDeviceWhereInput
    none?: NetworkDeviceWhereInput
  }

  export type VlanListRelationFilter = {
    every?: VlanWhereInput
    some?: VlanWhereInput
    none?: VlanWhereInput
  }

  export type NetworkSubnetOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type NetworkDeviceOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type VlanOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type SiteCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    address?: SortOrder
    notes?: SortOrder
    tags?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type SiteMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    address?: SortOrder
    notes?: SortOrder
    tags?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type SiteMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    address?: SortOrder
    notes?: SortOrder
    tags?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type SiteNullableScalarRelationFilter = {
    is?: SiteWhereInput | null
    isNot?: SiteWhereInput | null
  }

  export type VlanVidSiteIdCompoundUniqueInput = {
    vid: number
    siteId: string
  }

  export type VlanCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    vid?: SortOrder
    siteId?: SortOrder
    description?: SortOrder
    tags?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type VlanAvgOrderByAggregateInput = {
    vid?: SortOrder
  }

  export type VlanMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    vid?: SortOrder
    siteId?: SortOrder
    description?: SortOrder
    tags?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type VlanMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    vid?: SortOrder
    siteId?: SortOrder
    description?: SortOrder
    tags?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type VlanSumOrderByAggregateInput = {
    vid?: SortOrder
  }

  export type VlanNullableScalarRelationFilter = {
    is?: VlanWhereInput | null
    isNot?: VlanWhereInput | null
  }

  export type NetworkSubnetNullableScalarRelationFilter = {
    is?: NetworkSubnetWhereInput | null
    isNot?: NetworkSubnetWhereInput | null
  }

  export type NetworkIPListRelationFilter = {
    every?: NetworkIPWhereInput
    some?: NetworkIPWhereInput
    none?: NetworkIPWhereInput
  }

  export type NetworkIPOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type NetworkSubnetCountOrderByAggregateInput = {
    id?: SortOrder
    cidr?: SortOrder
    name?: SortOrder
    description?: SortOrder
    siteId?: SortOrder
    vlanId?: SortOrder
    parentId?: SortOrder
    gatewayIpId?: SortOrder
    tags?: SortOrder
    notes?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type NetworkSubnetMaxOrderByAggregateInput = {
    id?: SortOrder
    cidr?: SortOrder
    name?: SortOrder
    description?: SortOrder
    siteId?: SortOrder
    vlanId?: SortOrder
    parentId?: SortOrder
    gatewayIpId?: SortOrder
    tags?: SortOrder
    notes?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type NetworkSubnetMinOrderByAggregateInput = {
    id?: SortOrder
    cidr?: SortOrder
    name?: SortOrder
    description?: SortOrder
    siteId?: SortOrder
    vlanId?: SortOrder
    parentId?: SortOrder
    gatewayIpId?: SortOrder
    tags?: SortOrder
    notes?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type EnumIPStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.IPStatus | EnumIPStatusFieldRefInput<$PrismaModel>
    in?: $Enums.IPStatus[]
    notIn?: $Enums.IPStatus[]
    not?: NestedEnumIPStatusFilter<$PrismaModel> | $Enums.IPStatus
  }

  export type NetworkSubnetScalarRelationFilter = {
    is?: NetworkSubnetWhereInput
    isNot?: NetworkSubnetWhereInput
  }

  export type NetworkDeviceNullableScalarRelationFilter = {
    is?: NetworkDeviceWhereInput | null
    isNot?: NetworkDeviceWhereInput | null
  }

  export type NetworkIPCountOrderByAggregateInput = {
    id?: SortOrder
    address?: SortOrder
    subnetId?: SortOrder
    status?: SortOrder
    deviceId?: SortOrder
    interface?: SortOrder
    fqdn?: SortOrder
    purpose?: SortOrder
    mac?: SortOrder
    tags?: SortOrder
    notes?: SortOrder
    lastSeen?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type NetworkIPMaxOrderByAggregateInput = {
    id?: SortOrder
    address?: SortOrder
    subnetId?: SortOrder
    status?: SortOrder
    deviceId?: SortOrder
    interface?: SortOrder
    fqdn?: SortOrder
    purpose?: SortOrder
    mac?: SortOrder
    tags?: SortOrder
    notes?: SortOrder
    lastSeen?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type NetworkIPMinOrderByAggregateInput = {
    id?: SortOrder
    address?: SortOrder
    subnetId?: SortOrder
    status?: SortOrder
    deviceId?: SortOrder
    interface?: SortOrder
    fqdn?: SortOrder
    purpose?: SortOrder
    mac?: SortOrder
    tags?: SortOrder
    notes?: SortOrder
    lastSeen?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type EnumIPStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.IPStatus | EnumIPStatusFieldRefInput<$PrismaModel>
    in?: $Enums.IPStatus[]
    notIn?: $Enums.IPStatus[]
    not?: NestedEnumIPStatusWithAggregatesFilter<$PrismaModel> | $Enums.IPStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumIPStatusFilter<$PrismaModel>
    _max?: NestedEnumIPStatusFilter<$PrismaModel>
  }

  export type EnumDeviceTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.DeviceType | EnumDeviceTypeFieldRefInput<$PrismaModel>
    in?: $Enums.DeviceType[]
    notIn?: $Enums.DeviceType[]
    not?: NestedEnumDeviceTypeFilter<$PrismaModel> | $Enums.DeviceType
  }

  export type NetworkServiceListRelationFilter = {
    every?: NetworkServiceWhereInput
    some?: NetworkServiceWhereInput
    none?: NetworkServiceWhereInput
  }

  export type NetworkServiceOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type NetworkDeviceCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    type?: SortOrder
    siteId?: SortOrder
    mgmtIp?: SortOrder
    vendor?: SortOrder
    model?: SortOrder
    serial?: SortOrder
    osVersion?: SortOrder
    tags?: SortOrder
    notes?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type NetworkDeviceMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    type?: SortOrder
    siteId?: SortOrder
    mgmtIp?: SortOrder
    vendor?: SortOrder
    model?: SortOrder
    serial?: SortOrder
    osVersion?: SortOrder
    tags?: SortOrder
    notes?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type NetworkDeviceMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    type?: SortOrder
    siteId?: SortOrder
    mgmtIp?: SortOrder
    vendor?: SortOrder
    model?: SortOrder
    serial?: SortOrder
    osVersion?: SortOrder
    tags?: SortOrder
    notes?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type EnumDeviceTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.DeviceType | EnumDeviceTypeFieldRefInput<$PrismaModel>
    in?: $Enums.DeviceType[]
    notIn?: $Enums.DeviceType[]
    not?: NestedEnumDeviceTypeWithAggregatesFilter<$PrismaModel> | $Enums.DeviceType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumDeviceTypeFilter<$PrismaModel>
    _max?: NestedEnumDeviceTypeFilter<$PrismaModel>
  }

  export type EnumProtocolFilter<$PrismaModel = never> = {
    equals?: $Enums.Protocol | EnumProtocolFieldRefInput<$PrismaModel>
    in?: $Enums.Protocol[]
    notIn?: $Enums.Protocol[]
    not?: NestedEnumProtocolFilter<$PrismaModel> | $Enums.Protocol
  }

  export type NetworkDeviceScalarRelationFilter = {
    is?: NetworkDeviceWhereInput
    isNot?: NetworkDeviceWhereInput
  }

  export type NetworkServiceCountOrderByAggregateInput = {
    id?: SortOrder
    deviceId?: SortOrder
    name?: SortOrder
    protocol?: SortOrder
    port?: SortOrder
    externalPort?: SortOrder
    targetIp?: SortOrder
    targetFqdn?: SortOrder
    enabled?: SortOrder
    description?: SortOrder
    tags?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type NetworkServiceAvgOrderByAggregateInput = {
    port?: SortOrder
    externalPort?: SortOrder
  }

  export type NetworkServiceMaxOrderByAggregateInput = {
    id?: SortOrder
    deviceId?: SortOrder
    name?: SortOrder
    protocol?: SortOrder
    port?: SortOrder
    externalPort?: SortOrder
    targetIp?: SortOrder
    targetFqdn?: SortOrder
    enabled?: SortOrder
    description?: SortOrder
    tags?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type NetworkServiceMinOrderByAggregateInput = {
    id?: SortOrder
    deviceId?: SortOrder
    name?: SortOrder
    protocol?: SortOrder
    port?: SortOrder
    externalPort?: SortOrder
    targetIp?: SortOrder
    targetFqdn?: SortOrder
    enabled?: SortOrder
    description?: SortOrder
    tags?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type NetworkServiceSumOrderByAggregateInput = {
    port?: SortOrder
    externalPort?: SortOrder
  }

  export type EnumProtocolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.Protocol | EnumProtocolFieldRefInput<$PrismaModel>
    in?: $Enums.Protocol[]
    notIn?: $Enums.Protocol[]
    not?: NestedEnumProtocolWithAggregatesFilter<$PrismaModel> | $Enums.Protocol
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumProtocolFilter<$PrismaModel>
    _max?: NestedEnumProtocolFilter<$PrismaModel>
  }

  export type SubscriptionCreateNestedManyWithoutUserInput = {
    create?: XOR<SubscriptionCreateWithoutUserInput, SubscriptionUncheckedCreateWithoutUserInput> | SubscriptionCreateWithoutUserInput[] | SubscriptionUncheckedCreateWithoutUserInput[]
    connectOrCreate?: SubscriptionCreateOrConnectWithoutUserInput | SubscriptionCreateOrConnectWithoutUserInput[]
    createMany?: SubscriptionCreateManyUserInputEnvelope
    connect?: SubscriptionWhereUniqueInput | SubscriptionWhereUniqueInput[]
  }

  export type SubscriptionUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<SubscriptionCreateWithoutUserInput, SubscriptionUncheckedCreateWithoutUserInput> | SubscriptionCreateWithoutUserInput[] | SubscriptionUncheckedCreateWithoutUserInput[]
    connectOrCreate?: SubscriptionCreateOrConnectWithoutUserInput | SubscriptionCreateOrConnectWithoutUserInput[]
    createMany?: SubscriptionCreateManyUserInputEnvelope
    connect?: SubscriptionWhereUniqueInput | SubscriptionWhereUniqueInput[]
  }

  export type StringFieldUpdateOperationsInput = {
    set?: string
  }

  export type NullableStringFieldUpdateOperationsInput = {
    set?: string | null
  }

  export type DateTimeFieldUpdateOperationsInput = {
    set?: Date | string
  }

  export type SubscriptionUpdateManyWithoutUserNestedInput = {
    create?: XOR<SubscriptionCreateWithoutUserInput, SubscriptionUncheckedCreateWithoutUserInput> | SubscriptionCreateWithoutUserInput[] | SubscriptionUncheckedCreateWithoutUserInput[]
    connectOrCreate?: SubscriptionCreateOrConnectWithoutUserInput | SubscriptionCreateOrConnectWithoutUserInput[]
    upsert?: SubscriptionUpsertWithWhereUniqueWithoutUserInput | SubscriptionUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: SubscriptionCreateManyUserInputEnvelope
    set?: SubscriptionWhereUniqueInput | SubscriptionWhereUniqueInput[]
    disconnect?: SubscriptionWhereUniqueInput | SubscriptionWhereUniqueInput[]
    delete?: SubscriptionWhereUniqueInput | SubscriptionWhereUniqueInput[]
    connect?: SubscriptionWhereUniqueInput | SubscriptionWhereUniqueInput[]
    update?: SubscriptionUpdateWithWhereUniqueWithoutUserInput | SubscriptionUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: SubscriptionUpdateManyWithWhereWithoutUserInput | SubscriptionUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: SubscriptionScalarWhereInput | SubscriptionScalarWhereInput[]
  }

  export type SubscriptionUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<SubscriptionCreateWithoutUserInput, SubscriptionUncheckedCreateWithoutUserInput> | SubscriptionCreateWithoutUserInput[] | SubscriptionUncheckedCreateWithoutUserInput[]
    connectOrCreate?: SubscriptionCreateOrConnectWithoutUserInput | SubscriptionCreateOrConnectWithoutUserInput[]
    upsert?: SubscriptionUpsertWithWhereUniqueWithoutUserInput | SubscriptionUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: SubscriptionCreateManyUserInputEnvelope
    set?: SubscriptionWhereUniqueInput | SubscriptionWhereUniqueInput[]
    disconnect?: SubscriptionWhereUniqueInput | SubscriptionWhereUniqueInput[]
    delete?: SubscriptionWhereUniqueInput | SubscriptionWhereUniqueInput[]
    connect?: SubscriptionWhereUniqueInput | SubscriptionWhereUniqueInput[]
    update?: SubscriptionUpdateWithWhereUniqueWithoutUserInput | SubscriptionUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: SubscriptionUpdateManyWithWhereWithoutUserInput | SubscriptionUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: SubscriptionScalarWhereInput | SubscriptionScalarWhereInput[]
  }

  export type UserCreateNestedOneWithoutSubscriptionsInput = {
    create?: XOR<UserCreateWithoutSubscriptionsInput, UserUncheckedCreateWithoutSubscriptionsInput>
    connectOrCreate?: UserCreateOrConnectWithoutSubscriptionsInput
    connect?: UserWhereUniqueInput
  }

  export type InvoiceCreateNestedManyWithoutSubscriptionInput = {
    create?: XOR<InvoiceCreateWithoutSubscriptionInput, InvoiceUncheckedCreateWithoutSubscriptionInput> | InvoiceCreateWithoutSubscriptionInput[] | InvoiceUncheckedCreateWithoutSubscriptionInput[]
    connectOrCreate?: InvoiceCreateOrConnectWithoutSubscriptionInput | InvoiceCreateOrConnectWithoutSubscriptionInput[]
    createMany?: InvoiceCreateManySubscriptionInputEnvelope
    connect?: InvoiceWhereUniqueInput | InvoiceWhereUniqueInput[]
  }

  export type InvoiceUncheckedCreateNestedManyWithoutSubscriptionInput = {
    create?: XOR<InvoiceCreateWithoutSubscriptionInput, InvoiceUncheckedCreateWithoutSubscriptionInput> | InvoiceCreateWithoutSubscriptionInput[] | InvoiceUncheckedCreateWithoutSubscriptionInput[]
    connectOrCreate?: InvoiceCreateOrConnectWithoutSubscriptionInput | InvoiceCreateOrConnectWithoutSubscriptionInput[]
    createMany?: InvoiceCreateManySubscriptionInputEnvelope
    connect?: InvoiceWhereUniqueInput | InvoiceWhereUniqueInput[]
  }

  export type FloatFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type UserUpdateOneRequiredWithoutSubscriptionsNestedInput = {
    create?: XOR<UserCreateWithoutSubscriptionsInput, UserUncheckedCreateWithoutSubscriptionsInput>
    connectOrCreate?: UserCreateOrConnectWithoutSubscriptionsInput
    upsert?: UserUpsertWithoutSubscriptionsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutSubscriptionsInput, UserUpdateWithoutSubscriptionsInput>, UserUncheckedUpdateWithoutSubscriptionsInput>
  }

  export type InvoiceUpdateManyWithoutSubscriptionNestedInput = {
    create?: XOR<InvoiceCreateWithoutSubscriptionInput, InvoiceUncheckedCreateWithoutSubscriptionInput> | InvoiceCreateWithoutSubscriptionInput[] | InvoiceUncheckedCreateWithoutSubscriptionInput[]
    connectOrCreate?: InvoiceCreateOrConnectWithoutSubscriptionInput | InvoiceCreateOrConnectWithoutSubscriptionInput[]
    upsert?: InvoiceUpsertWithWhereUniqueWithoutSubscriptionInput | InvoiceUpsertWithWhereUniqueWithoutSubscriptionInput[]
    createMany?: InvoiceCreateManySubscriptionInputEnvelope
    set?: InvoiceWhereUniqueInput | InvoiceWhereUniqueInput[]
    disconnect?: InvoiceWhereUniqueInput | InvoiceWhereUniqueInput[]
    delete?: InvoiceWhereUniqueInput | InvoiceWhereUniqueInput[]
    connect?: InvoiceWhereUniqueInput | InvoiceWhereUniqueInput[]
    update?: InvoiceUpdateWithWhereUniqueWithoutSubscriptionInput | InvoiceUpdateWithWhereUniqueWithoutSubscriptionInput[]
    updateMany?: InvoiceUpdateManyWithWhereWithoutSubscriptionInput | InvoiceUpdateManyWithWhereWithoutSubscriptionInput[]
    deleteMany?: InvoiceScalarWhereInput | InvoiceScalarWhereInput[]
  }

  export type InvoiceUncheckedUpdateManyWithoutSubscriptionNestedInput = {
    create?: XOR<InvoiceCreateWithoutSubscriptionInput, InvoiceUncheckedCreateWithoutSubscriptionInput> | InvoiceCreateWithoutSubscriptionInput[] | InvoiceUncheckedCreateWithoutSubscriptionInput[]
    connectOrCreate?: InvoiceCreateOrConnectWithoutSubscriptionInput | InvoiceCreateOrConnectWithoutSubscriptionInput[]
    upsert?: InvoiceUpsertWithWhereUniqueWithoutSubscriptionInput | InvoiceUpsertWithWhereUniqueWithoutSubscriptionInput[]
    createMany?: InvoiceCreateManySubscriptionInputEnvelope
    set?: InvoiceWhereUniqueInput | InvoiceWhereUniqueInput[]
    disconnect?: InvoiceWhereUniqueInput | InvoiceWhereUniqueInput[]
    delete?: InvoiceWhereUniqueInput | InvoiceWhereUniqueInput[]
    connect?: InvoiceWhereUniqueInput | InvoiceWhereUniqueInput[]
    update?: InvoiceUpdateWithWhereUniqueWithoutSubscriptionInput | InvoiceUpdateWithWhereUniqueWithoutSubscriptionInput[]
    updateMany?: InvoiceUpdateManyWithWhereWithoutSubscriptionInput | InvoiceUpdateManyWithWhereWithoutSubscriptionInput[]
    deleteMany?: InvoiceScalarWhereInput | InvoiceScalarWhereInput[]
  }

  export type SubscriptionCreateNestedOneWithoutInvoicesInput = {
    create?: XOR<SubscriptionCreateWithoutInvoicesInput, SubscriptionUncheckedCreateWithoutInvoicesInput>
    connectOrCreate?: SubscriptionCreateOrConnectWithoutInvoicesInput
    connect?: SubscriptionWhereUniqueInput
  }

  export type NullableDateTimeFieldUpdateOperationsInput = {
    set?: Date | string | null
  }

  export type SubscriptionUpdateOneRequiredWithoutInvoicesNestedInput = {
    create?: XOR<SubscriptionCreateWithoutInvoicesInput, SubscriptionUncheckedCreateWithoutInvoicesInput>
    connectOrCreate?: SubscriptionCreateOrConnectWithoutInvoicesInput
    upsert?: SubscriptionUpsertWithoutInvoicesInput
    connect?: SubscriptionWhereUniqueInput
    update?: XOR<XOR<SubscriptionUpdateToOneWithWhereWithoutInvoicesInput, SubscriptionUpdateWithoutInvoicesInput>, SubscriptionUncheckedUpdateWithoutInvoicesInput>
  }

  export type IntFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type NullableFloatFieldUpdateOperationsInput = {
    set?: number | null
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type NullableIntFieldUpdateOperationsInput = {
    set?: number | null
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type ProxmoxNodeCreateNestedManyWithoutServerInput = {
    create?: XOR<ProxmoxNodeCreateWithoutServerInput, ProxmoxNodeUncheckedCreateWithoutServerInput> | ProxmoxNodeCreateWithoutServerInput[] | ProxmoxNodeUncheckedCreateWithoutServerInput[]
    connectOrCreate?: ProxmoxNodeCreateOrConnectWithoutServerInput | ProxmoxNodeCreateOrConnectWithoutServerInput[]
    createMany?: ProxmoxNodeCreateManyServerInputEnvelope
    connect?: ProxmoxNodeWhereUniqueInput | ProxmoxNodeWhereUniqueInput[]
  }

  export type ProxmoxVMCreateNestedManyWithoutServerInput = {
    create?: XOR<ProxmoxVMCreateWithoutServerInput, ProxmoxVMUncheckedCreateWithoutServerInput> | ProxmoxVMCreateWithoutServerInput[] | ProxmoxVMUncheckedCreateWithoutServerInput[]
    connectOrCreate?: ProxmoxVMCreateOrConnectWithoutServerInput | ProxmoxVMCreateOrConnectWithoutServerInput[]
    createMany?: ProxmoxVMCreateManyServerInputEnvelope
    connect?: ProxmoxVMWhereUniqueInput | ProxmoxVMWhereUniqueInput[]
  }

  export type ProxmoxNodeUncheckedCreateNestedManyWithoutServerInput = {
    create?: XOR<ProxmoxNodeCreateWithoutServerInput, ProxmoxNodeUncheckedCreateWithoutServerInput> | ProxmoxNodeCreateWithoutServerInput[] | ProxmoxNodeUncheckedCreateWithoutServerInput[]
    connectOrCreate?: ProxmoxNodeCreateOrConnectWithoutServerInput | ProxmoxNodeCreateOrConnectWithoutServerInput[]
    createMany?: ProxmoxNodeCreateManyServerInputEnvelope
    connect?: ProxmoxNodeWhereUniqueInput | ProxmoxNodeWhereUniqueInput[]
  }

  export type ProxmoxVMUncheckedCreateNestedManyWithoutServerInput = {
    create?: XOR<ProxmoxVMCreateWithoutServerInput, ProxmoxVMUncheckedCreateWithoutServerInput> | ProxmoxVMCreateWithoutServerInput[] | ProxmoxVMUncheckedCreateWithoutServerInput[]
    connectOrCreate?: ProxmoxVMCreateOrConnectWithoutServerInput | ProxmoxVMCreateOrConnectWithoutServerInput[]
    createMany?: ProxmoxVMCreateManyServerInputEnvelope
    connect?: ProxmoxVMWhereUniqueInput | ProxmoxVMWhereUniqueInput[]
  }

  export type BoolFieldUpdateOperationsInput = {
    set?: boolean
  }

  export type ProxmoxNodeUpdateManyWithoutServerNestedInput = {
    create?: XOR<ProxmoxNodeCreateWithoutServerInput, ProxmoxNodeUncheckedCreateWithoutServerInput> | ProxmoxNodeCreateWithoutServerInput[] | ProxmoxNodeUncheckedCreateWithoutServerInput[]
    connectOrCreate?: ProxmoxNodeCreateOrConnectWithoutServerInput | ProxmoxNodeCreateOrConnectWithoutServerInput[]
    upsert?: ProxmoxNodeUpsertWithWhereUniqueWithoutServerInput | ProxmoxNodeUpsertWithWhereUniqueWithoutServerInput[]
    createMany?: ProxmoxNodeCreateManyServerInputEnvelope
    set?: ProxmoxNodeWhereUniqueInput | ProxmoxNodeWhereUniqueInput[]
    disconnect?: ProxmoxNodeWhereUniqueInput | ProxmoxNodeWhereUniqueInput[]
    delete?: ProxmoxNodeWhereUniqueInput | ProxmoxNodeWhereUniqueInput[]
    connect?: ProxmoxNodeWhereUniqueInput | ProxmoxNodeWhereUniqueInput[]
    update?: ProxmoxNodeUpdateWithWhereUniqueWithoutServerInput | ProxmoxNodeUpdateWithWhereUniqueWithoutServerInput[]
    updateMany?: ProxmoxNodeUpdateManyWithWhereWithoutServerInput | ProxmoxNodeUpdateManyWithWhereWithoutServerInput[]
    deleteMany?: ProxmoxNodeScalarWhereInput | ProxmoxNodeScalarWhereInput[]
  }

  export type ProxmoxVMUpdateManyWithoutServerNestedInput = {
    create?: XOR<ProxmoxVMCreateWithoutServerInput, ProxmoxVMUncheckedCreateWithoutServerInput> | ProxmoxVMCreateWithoutServerInput[] | ProxmoxVMUncheckedCreateWithoutServerInput[]
    connectOrCreate?: ProxmoxVMCreateOrConnectWithoutServerInput | ProxmoxVMCreateOrConnectWithoutServerInput[]
    upsert?: ProxmoxVMUpsertWithWhereUniqueWithoutServerInput | ProxmoxVMUpsertWithWhereUniqueWithoutServerInput[]
    createMany?: ProxmoxVMCreateManyServerInputEnvelope
    set?: ProxmoxVMWhereUniqueInput | ProxmoxVMWhereUniqueInput[]
    disconnect?: ProxmoxVMWhereUniqueInput | ProxmoxVMWhereUniqueInput[]
    delete?: ProxmoxVMWhereUniqueInput | ProxmoxVMWhereUniqueInput[]
    connect?: ProxmoxVMWhereUniqueInput | ProxmoxVMWhereUniqueInput[]
    update?: ProxmoxVMUpdateWithWhereUniqueWithoutServerInput | ProxmoxVMUpdateWithWhereUniqueWithoutServerInput[]
    updateMany?: ProxmoxVMUpdateManyWithWhereWithoutServerInput | ProxmoxVMUpdateManyWithWhereWithoutServerInput[]
    deleteMany?: ProxmoxVMScalarWhereInput | ProxmoxVMScalarWhereInput[]
  }

  export type ProxmoxNodeUncheckedUpdateManyWithoutServerNestedInput = {
    create?: XOR<ProxmoxNodeCreateWithoutServerInput, ProxmoxNodeUncheckedCreateWithoutServerInput> | ProxmoxNodeCreateWithoutServerInput[] | ProxmoxNodeUncheckedCreateWithoutServerInput[]
    connectOrCreate?: ProxmoxNodeCreateOrConnectWithoutServerInput | ProxmoxNodeCreateOrConnectWithoutServerInput[]
    upsert?: ProxmoxNodeUpsertWithWhereUniqueWithoutServerInput | ProxmoxNodeUpsertWithWhereUniqueWithoutServerInput[]
    createMany?: ProxmoxNodeCreateManyServerInputEnvelope
    set?: ProxmoxNodeWhereUniqueInput | ProxmoxNodeWhereUniqueInput[]
    disconnect?: ProxmoxNodeWhereUniqueInput | ProxmoxNodeWhereUniqueInput[]
    delete?: ProxmoxNodeWhereUniqueInput | ProxmoxNodeWhereUniqueInput[]
    connect?: ProxmoxNodeWhereUniqueInput | ProxmoxNodeWhereUniqueInput[]
    update?: ProxmoxNodeUpdateWithWhereUniqueWithoutServerInput | ProxmoxNodeUpdateWithWhereUniqueWithoutServerInput[]
    updateMany?: ProxmoxNodeUpdateManyWithWhereWithoutServerInput | ProxmoxNodeUpdateManyWithWhereWithoutServerInput[]
    deleteMany?: ProxmoxNodeScalarWhereInput | ProxmoxNodeScalarWhereInput[]
  }

  export type ProxmoxVMUncheckedUpdateManyWithoutServerNestedInput = {
    create?: XOR<ProxmoxVMCreateWithoutServerInput, ProxmoxVMUncheckedCreateWithoutServerInput> | ProxmoxVMCreateWithoutServerInput[] | ProxmoxVMUncheckedCreateWithoutServerInput[]
    connectOrCreate?: ProxmoxVMCreateOrConnectWithoutServerInput | ProxmoxVMCreateOrConnectWithoutServerInput[]
    upsert?: ProxmoxVMUpsertWithWhereUniqueWithoutServerInput | ProxmoxVMUpsertWithWhereUniqueWithoutServerInput[]
    createMany?: ProxmoxVMCreateManyServerInputEnvelope
    set?: ProxmoxVMWhereUniqueInput | ProxmoxVMWhereUniqueInput[]
    disconnect?: ProxmoxVMWhereUniqueInput | ProxmoxVMWhereUniqueInput[]
    delete?: ProxmoxVMWhereUniqueInput | ProxmoxVMWhereUniqueInput[]
    connect?: ProxmoxVMWhereUniqueInput | ProxmoxVMWhereUniqueInput[]
    update?: ProxmoxVMUpdateWithWhereUniqueWithoutServerInput | ProxmoxVMUpdateWithWhereUniqueWithoutServerInput[]
    updateMany?: ProxmoxVMUpdateManyWithWhereWithoutServerInput | ProxmoxVMUpdateManyWithWhereWithoutServerInput[]
    deleteMany?: ProxmoxVMScalarWhereInput | ProxmoxVMScalarWhereInput[]
  }

  export type ProxmoxVMCreateNestedManyWithoutNodeInput = {
    create?: XOR<ProxmoxVMCreateWithoutNodeInput, ProxmoxVMUncheckedCreateWithoutNodeInput> | ProxmoxVMCreateWithoutNodeInput[] | ProxmoxVMUncheckedCreateWithoutNodeInput[]
    connectOrCreate?: ProxmoxVMCreateOrConnectWithoutNodeInput | ProxmoxVMCreateOrConnectWithoutNodeInput[]
    createMany?: ProxmoxVMCreateManyNodeInputEnvelope
    connect?: ProxmoxVMWhereUniqueInput | ProxmoxVMWhereUniqueInput[]
  }

  export type ProxmoxServerCreateNestedOneWithoutNodesInput = {
    create?: XOR<ProxmoxServerCreateWithoutNodesInput, ProxmoxServerUncheckedCreateWithoutNodesInput>
    connectOrCreate?: ProxmoxServerCreateOrConnectWithoutNodesInput
    connect?: ProxmoxServerWhereUniqueInput
  }

  export type ProxmoxVMUncheckedCreateNestedManyWithoutNodeInput = {
    create?: XOR<ProxmoxVMCreateWithoutNodeInput, ProxmoxVMUncheckedCreateWithoutNodeInput> | ProxmoxVMCreateWithoutNodeInput[] | ProxmoxVMUncheckedCreateWithoutNodeInput[]
    connectOrCreate?: ProxmoxVMCreateOrConnectWithoutNodeInput | ProxmoxVMCreateOrConnectWithoutNodeInput[]
    createMany?: ProxmoxVMCreateManyNodeInputEnvelope
    connect?: ProxmoxVMWhereUniqueInput | ProxmoxVMWhereUniqueInput[]
  }

  export type NullableBigIntFieldUpdateOperationsInput = {
    set?: bigint | number | null
    increment?: bigint | number
    decrement?: bigint | number
    multiply?: bigint | number
    divide?: bigint | number
  }

  export type ProxmoxVMUpdateManyWithoutNodeNestedInput = {
    create?: XOR<ProxmoxVMCreateWithoutNodeInput, ProxmoxVMUncheckedCreateWithoutNodeInput> | ProxmoxVMCreateWithoutNodeInput[] | ProxmoxVMUncheckedCreateWithoutNodeInput[]
    connectOrCreate?: ProxmoxVMCreateOrConnectWithoutNodeInput | ProxmoxVMCreateOrConnectWithoutNodeInput[]
    upsert?: ProxmoxVMUpsertWithWhereUniqueWithoutNodeInput | ProxmoxVMUpsertWithWhereUniqueWithoutNodeInput[]
    createMany?: ProxmoxVMCreateManyNodeInputEnvelope
    set?: ProxmoxVMWhereUniqueInput | ProxmoxVMWhereUniqueInput[]
    disconnect?: ProxmoxVMWhereUniqueInput | ProxmoxVMWhereUniqueInput[]
    delete?: ProxmoxVMWhereUniqueInput | ProxmoxVMWhereUniqueInput[]
    connect?: ProxmoxVMWhereUniqueInput | ProxmoxVMWhereUniqueInput[]
    update?: ProxmoxVMUpdateWithWhereUniqueWithoutNodeInput | ProxmoxVMUpdateWithWhereUniqueWithoutNodeInput[]
    updateMany?: ProxmoxVMUpdateManyWithWhereWithoutNodeInput | ProxmoxVMUpdateManyWithWhereWithoutNodeInput[]
    deleteMany?: ProxmoxVMScalarWhereInput | ProxmoxVMScalarWhereInput[]
  }

  export type ProxmoxServerUpdateOneWithoutNodesNestedInput = {
    create?: XOR<ProxmoxServerCreateWithoutNodesInput, ProxmoxServerUncheckedCreateWithoutNodesInput>
    connectOrCreate?: ProxmoxServerCreateOrConnectWithoutNodesInput
    upsert?: ProxmoxServerUpsertWithoutNodesInput
    disconnect?: ProxmoxServerWhereInput | boolean
    delete?: ProxmoxServerWhereInput | boolean
    connect?: ProxmoxServerWhereUniqueInput
    update?: XOR<XOR<ProxmoxServerUpdateToOneWithWhereWithoutNodesInput, ProxmoxServerUpdateWithoutNodesInput>, ProxmoxServerUncheckedUpdateWithoutNodesInput>
  }

  export type ProxmoxVMUncheckedUpdateManyWithoutNodeNestedInput = {
    create?: XOR<ProxmoxVMCreateWithoutNodeInput, ProxmoxVMUncheckedCreateWithoutNodeInput> | ProxmoxVMCreateWithoutNodeInput[] | ProxmoxVMUncheckedCreateWithoutNodeInput[]
    connectOrCreate?: ProxmoxVMCreateOrConnectWithoutNodeInput | ProxmoxVMCreateOrConnectWithoutNodeInput[]
    upsert?: ProxmoxVMUpsertWithWhereUniqueWithoutNodeInput | ProxmoxVMUpsertWithWhereUniqueWithoutNodeInput[]
    createMany?: ProxmoxVMCreateManyNodeInputEnvelope
    set?: ProxmoxVMWhereUniqueInput | ProxmoxVMWhereUniqueInput[]
    disconnect?: ProxmoxVMWhereUniqueInput | ProxmoxVMWhereUniqueInput[]
    delete?: ProxmoxVMWhereUniqueInput | ProxmoxVMWhereUniqueInput[]
    connect?: ProxmoxVMWhereUniqueInput | ProxmoxVMWhereUniqueInput[]
    update?: ProxmoxVMUpdateWithWhereUniqueWithoutNodeInput | ProxmoxVMUpdateWithWhereUniqueWithoutNodeInput[]
    updateMany?: ProxmoxVMUpdateManyWithWhereWithoutNodeInput | ProxmoxVMUpdateManyWithWhereWithoutNodeInput[]
    deleteMany?: ProxmoxVMScalarWhereInput | ProxmoxVMScalarWhereInput[]
  }

  export type ProxmoxNodeCreateNestedOneWithoutVmsInput = {
    create?: XOR<ProxmoxNodeCreateWithoutVmsInput, ProxmoxNodeUncheckedCreateWithoutVmsInput>
    connectOrCreate?: ProxmoxNodeCreateOrConnectWithoutVmsInput
    connect?: ProxmoxNodeWhereUniqueInput
  }

  export type ProxmoxMetricCreateNestedManyWithoutVmInput = {
    create?: XOR<ProxmoxMetricCreateWithoutVmInput, ProxmoxMetricUncheckedCreateWithoutVmInput> | ProxmoxMetricCreateWithoutVmInput[] | ProxmoxMetricUncheckedCreateWithoutVmInput[]
    connectOrCreate?: ProxmoxMetricCreateOrConnectWithoutVmInput | ProxmoxMetricCreateOrConnectWithoutVmInput[]
    createMany?: ProxmoxMetricCreateManyVmInputEnvelope
    connect?: ProxmoxMetricWhereUniqueInput | ProxmoxMetricWhereUniqueInput[]
  }

  export type ProxmoxServerCreateNestedOneWithoutVmsInput = {
    create?: XOR<ProxmoxServerCreateWithoutVmsInput, ProxmoxServerUncheckedCreateWithoutVmsInput>
    connectOrCreate?: ProxmoxServerCreateOrConnectWithoutVmsInput
    connect?: ProxmoxServerWhereUniqueInput
  }

  export type ProxmoxMetricUncheckedCreateNestedManyWithoutVmInput = {
    create?: XOR<ProxmoxMetricCreateWithoutVmInput, ProxmoxMetricUncheckedCreateWithoutVmInput> | ProxmoxMetricCreateWithoutVmInput[] | ProxmoxMetricUncheckedCreateWithoutVmInput[]
    connectOrCreate?: ProxmoxMetricCreateOrConnectWithoutVmInput | ProxmoxMetricCreateOrConnectWithoutVmInput[]
    createMany?: ProxmoxMetricCreateManyVmInputEnvelope
    connect?: ProxmoxMetricWhereUniqueInput | ProxmoxMetricWhereUniqueInput[]
  }

  export type ProxmoxNodeUpdateOneWithoutVmsNestedInput = {
    create?: XOR<ProxmoxNodeCreateWithoutVmsInput, ProxmoxNodeUncheckedCreateWithoutVmsInput>
    connectOrCreate?: ProxmoxNodeCreateOrConnectWithoutVmsInput
    upsert?: ProxmoxNodeUpsertWithoutVmsInput
    disconnect?: ProxmoxNodeWhereInput | boolean
    delete?: ProxmoxNodeWhereInput | boolean
    connect?: ProxmoxNodeWhereUniqueInput
    update?: XOR<XOR<ProxmoxNodeUpdateToOneWithWhereWithoutVmsInput, ProxmoxNodeUpdateWithoutVmsInput>, ProxmoxNodeUncheckedUpdateWithoutVmsInput>
  }

  export type ProxmoxMetricUpdateManyWithoutVmNestedInput = {
    create?: XOR<ProxmoxMetricCreateWithoutVmInput, ProxmoxMetricUncheckedCreateWithoutVmInput> | ProxmoxMetricCreateWithoutVmInput[] | ProxmoxMetricUncheckedCreateWithoutVmInput[]
    connectOrCreate?: ProxmoxMetricCreateOrConnectWithoutVmInput | ProxmoxMetricCreateOrConnectWithoutVmInput[]
    upsert?: ProxmoxMetricUpsertWithWhereUniqueWithoutVmInput | ProxmoxMetricUpsertWithWhereUniqueWithoutVmInput[]
    createMany?: ProxmoxMetricCreateManyVmInputEnvelope
    set?: ProxmoxMetricWhereUniqueInput | ProxmoxMetricWhereUniqueInput[]
    disconnect?: ProxmoxMetricWhereUniqueInput | ProxmoxMetricWhereUniqueInput[]
    delete?: ProxmoxMetricWhereUniqueInput | ProxmoxMetricWhereUniqueInput[]
    connect?: ProxmoxMetricWhereUniqueInput | ProxmoxMetricWhereUniqueInput[]
    update?: ProxmoxMetricUpdateWithWhereUniqueWithoutVmInput | ProxmoxMetricUpdateWithWhereUniqueWithoutVmInput[]
    updateMany?: ProxmoxMetricUpdateManyWithWhereWithoutVmInput | ProxmoxMetricUpdateManyWithWhereWithoutVmInput[]
    deleteMany?: ProxmoxMetricScalarWhereInput | ProxmoxMetricScalarWhereInput[]
  }

  export type ProxmoxServerUpdateOneWithoutVmsNestedInput = {
    create?: XOR<ProxmoxServerCreateWithoutVmsInput, ProxmoxServerUncheckedCreateWithoutVmsInput>
    connectOrCreate?: ProxmoxServerCreateOrConnectWithoutVmsInput
    upsert?: ProxmoxServerUpsertWithoutVmsInput
    disconnect?: ProxmoxServerWhereInput | boolean
    delete?: ProxmoxServerWhereInput | boolean
    connect?: ProxmoxServerWhereUniqueInput
    update?: XOR<XOR<ProxmoxServerUpdateToOneWithWhereWithoutVmsInput, ProxmoxServerUpdateWithoutVmsInput>, ProxmoxServerUncheckedUpdateWithoutVmsInput>
  }

  export type ProxmoxMetricUncheckedUpdateManyWithoutVmNestedInput = {
    create?: XOR<ProxmoxMetricCreateWithoutVmInput, ProxmoxMetricUncheckedCreateWithoutVmInput> | ProxmoxMetricCreateWithoutVmInput[] | ProxmoxMetricUncheckedCreateWithoutVmInput[]
    connectOrCreate?: ProxmoxMetricCreateOrConnectWithoutVmInput | ProxmoxMetricCreateOrConnectWithoutVmInput[]
    upsert?: ProxmoxMetricUpsertWithWhereUniqueWithoutVmInput | ProxmoxMetricUpsertWithWhereUniqueWithoutVmInput[]
    createMany?: ProxmoxMetricCreateManyVmInputEnvelope
    set?: ProxmoxMetricWhereUniqueInput | ProxmoxMetricWhereUniqueInput[]
    disconnect?: ProxmoxMetricWhereUniqueInput | ProxmoxMetricWhereUniqueInput[]
    delete?: ProxmoxMetricWhereUniqueInput | ProxmoxMetricWhereUniqueInput[]
    connect?: ProxmoxMetricWhereUniqueInput | ProxmoxMetricWhereUniqueInput[]
    update?: ProxmoxMetricUpdateWithWhereUniqueWithoutVmInput | ProxmoxMetricUpdateWithWhereUniqueWithoutVmInput[]
    updateMany?: ProxmoxMetricUpdateManyWithWhereWithoutVmInput | ProxmoxMetricUpdateManyWithWhereWithoutVmInput[]
    deleteMany?: ProxmoxMetricScalarWhereInput | ProxmoxMetricScalarWhereInput[]
  }

  export type ProxmoxVMCreateNestedOneWithoutMetricsInput = {
    create?: XOR<ProxmoxVMCreateWithoutMetricsInput, ProxmoxVMUncheckedCreateWithoutMetricsInput>
    connectOrCreate?: ProxmoxVMCreateOrConnectWithoutMetricsInput
    connect?: ProxmoxVMWhereUniqueInput
  }

  export type ProxmoxVMUpdateOneWithoutMetricsNestedInput = {
    create?: XOR<ProxmoxVMCreateWithoutMetricsInput, ProxmoxVMUncheckedCreateWithoutMetricsInput>
    connectOrCreate?: ProxmoxVMCreateOrConnectWithoutMetricsInput
    upsert?: ProxmoxVMUpsertWithoutMetricsInput
    disconnect?: ProxmoxVMWhereInput | boolean
    delete?: ProxmoxVMWhereInput | boolean
    connect?: ProxmoxVMWhereUniqueInput
    update?: XOR<XOR<ProxmoxVMUpdateToOneWithWhereWithoutMetricsInput, ProxmoxVMUpdateWithoutMetricsInput>, ProxmoxVMUncheckedUpdateWithoutMetricsInput>
  }

  export type NetworkSubnetCreateNestedManyWithoutSiteInput = {
    create?: XOR<NetworkSubnetCreateWithoutSiteInput, NetworkSubnetUncheckedCreateWithoutSiteInput> | NetworkSubnetCreateWithoutSiteInput[] | NetworkSubnetUncheckedCreateWithoutSiteInput[]
    connectOrCreate?: NetworkSubnetCreateOrConnectWithoutSiteInput | NetworkSubnetCreateOrConnectWithoutSiteInput[]
    createMany?: NetworkSubnetCreateManySiteInputEnvelope
    connect?: NetworkSubnetWhereUniqueInput | NetworkSubnetWhereUniqueInput[]
  }

  export type NetworkDeviceCreateNestedManyWithoutSiteInput = {
    create?: XOR<NetworkDeviceCreateWithoutSiteInput, NetworkDeviceUncheckedCreateWithoutSiteInput> | NetworkDeviceCreateWithoutSiteInput[] | NetworkDeviceUncheckedCreateWithoutSiteInput[]
    connectOrCreate?: NetworkDeviceCreateOrConnectWithoutSiteInput | NetworkDeviceCreateOrConnectWithoutSiteInput[]
    createMany?: NetworkDeviceCreateManySiteInputEnvelope
    connect?: NetworkDeviceWhereUniqueInput | NetworkDeviceWhereUniqueInput[]
  }

  export type VlanCreateNestedManyWithoutSiteInput = {
    create?: XOR<VlanCreateWithoutSiteInput, VlanUncheckedCreateWithoutSiteInput> | VlanCreateWithoutSiteInput[] | VlanUncheckedCreateWithoutSiteInput[]
    connectOrCreate?: VlanCreateOrConnectWithoutSiteInput | VlanCreateOrConnectWithoutSiteInput[]
    createMany?: VlanCreateManySiteInputEnvelope
    connect?: VlanWhereUniqueInput | VlanWhereUniqueInput[]
  }

  export type NetworkSubnetUncheckedCreateNestedManyWithoutSiteInput = {
    create?: XOR<NetworkSubnetCreateWithoutSiteInput, NetworkSubnetUncheckedCreateWithoutSiteInput> | NetworkSubnetCreateWithoutSiteInput[] | NetworkSubnetUncheckedCreateWithoutSiteInput[]
    connectOrCreate?: NetworkSubnetCreateOrConnectWithoutSiteInput | NetworkSubnetCreateOrConnectWithoutSiteInput[]
    createMany?: NetworkSubnetCreateManySiteInputEnvelope
    connect?: NetworkSubnetWhereUniqueInput | NetworkSubnetWhereUniqueInput[]
  }

  export type NetworkDeviceUncheckedCreateNestedManyWithoutSiteInput = {
    create?: XOR<NetworkDeviceCreateWithoutSiteInput, NetworkDeviceUncheckedCreateWithoutSiteInput> | NetworkDeviceCreateWithoutSiteInput[] | NetworkDeviceUncheckedCreateWithoutSiteInput[]
    connectOrCreate?: NetworkDeviceCreateOrConnectWithoutSiteInput | NetworkDeviceCreateOrConnectWithoutSiteInput[]
    createMany?: NetworkDeviceCreateManySiteInputEnvelope
    connect?: NetworkDeviceWhereUniqueInput | NetworkDeviceWhereUniqueInput[]
  }

  export type VlanUncheckedCreateNestedManyWithoutSiteInput = {
    create?: XOR<VlanCreateWithoutSiteInput, VlanUncheckedCreateWithoutSiteInput> | VlanCreateWithoutSiteInput[] | VlanUncheckedCreateWithoutSiteInput[]
    connectOrCreate?: VlanCreateOrConnectWithoutSiteInput | VlanCreateOrConnectWithoutSiteInput[]
    createMany?: VlanCreateManySiteInputEnvelope
    connect?: VlanWhereUniqueInput | VlanWhereUniqueInput[]
  }

  export type NetworkSubnetUpdateManyWithoutSiteNestedInput = {
    create?: XOR<NetworkSubnetCreateWithoutSiteInput, NetworkSubnetUncheckedCreateWithoutSiteInput> | NetworkSubnetCreateWithoutSiteInput[] | NetworkSubnetUncheckedCreateWithoutSiteInput[]
    connectOrCreate?: NetworkSubnetCreateOrConnectWithoutSiteInput | NetworkSubnetCreateOrConnectWithoutSiteInput[]
    upsert?: NetworkSubnetUpsertWithWhereUniqueWithoutSiteInput | NetworkSubnetUpsertWithWhereUniqueWithoutSiteInput[]
    createMany?: NetworkSubnetCreateManySiteInputEnvelope
    set?: NetworkSubnetWhereUniqueInput | NetworkSubnetWhereUniqueInput[]
    disconnect?: NetworkSubnetWhereUniqueInput | NetworkSubnetWhereUniqueInput[]
    delete?: NetworkSubnetWhereUniqueInput | NetworkSubnetWhereUniqueInput[]
    connect?: NetworkSubnetWhereUniqueInput | NetworkSubnetWhereUniqueInput[]
    update?: NetworkSubnetUpdateWithWhereUniqueWithoutSiteInput | NetworkSubnetUpdateWithWhereUniqueWithoutSiteInput[]
    updateMany?: NetworkSubnetUpdateManyWithWhereWithoutSiteInput | NetworkSubnetUpdateManyWithWhereWithoutSiteInput[]
    deleteMany?: NetworkSubnetScalarWhereInput | NetworkSubnetScalarWhereInput[]
  }

  export type NetworkDeviceUpdateManyWithoutSiteNestedInput = {
    create?: XOR<NetworkDeviceCreateWithoutSiteInput, NetworkDeviceUncheckedCreateWithoutSiteInput> | NetworkDeviceCreateWithoutSiteInput[] | NetworkDeviceUncheckedCreateWithoutSiteInput[]
    connectOrCreate?: NetworkDeviceCreateOrConnectWithoutSiteInput | NetworkDeviceCreateOrConnectWithoutSiteInput[]
    upsert?: NetworkDeviceUpsertWithWhereUniqueWithoutSiteInput | NetworkDeviceUpsertWithWhereUniqueWithoutSiteInput[]
    createMany?: NetworkDeviceCreateManySiteInputEnvelope
    set?: NetworkDeviceWhereUniqueInput | NetworkDeviceWhereUniqueInput[]
    disconnect?: NetworkDeviceWhereUniqueInput | NetworkDeviceWhereUniqueInput[]
    delete?: NetworkDeviceWhereUniqueInput | NetworkDeviceWhereUniqueInput[]
    connect?: NetworkDeviceWhereUniqueInput | NetworkDeviceWhereUniqueInput[]
    update?: NetworkDeviceUpdateWithWhereUniqueWithoutSiteInput | NetworkDeviceUpdateWithWhereUniqueWithoutSiteInput[]
    updateMany?: NetworkDeviceUpdateManyWithWhereWithoutSiteInput | NetworkDeviceUpdateManyWithWhereWithoutSiteInput[]
    deleteMany?: NetworkDeviceScalarWhereInput | NetworkDeviceScalarWhereInput[]
  }

  export type VlanUpdateManyWithoutSiteNestedInput = {
    create?: XOR<VlanCreateWithoutSiteInput, VlanUncheckedCreateWithoutSiteInput> | VlanCreateWithoutSiteInput[] | VlanUncheckedCreateWithoutSiteInput[]
    connectOrCreate?: VlanCreateOrConnectWithoutSiteInput | VlanCreateOrConnectWithoutSiteInput[]
    upsert?: VlanUpsertWithWhereUniqueWithoutSiteInput | VlanUpsertWithWhereUniqueWithoutSiteInput[]
    createMany?: VlanCreateManySiteInputEnvelope
    set?: VlanWhereUniqueInput | VlanWhereUniqueInput[]
    disconnect?: VlanWhereUniqueInput | VlanWhereUniqueInput[]
    delete?: VlanWhereUniqueInput | VlanWhereUniqueInput[]
    connect?: VlanWhereUniqueInput | VlanWhereUniqueInput[]
    update?: VlanUpdateWithWhereUniqueWithoutSiteInput | VlanUpdateWithWhereUniqueWithoutSiteInput[]
    updateMany?: VlanUpdateManyWithWhereWithoutSiteInput | VlanUpdateManyWithWhereWithoutSiteInput[]
    deleteMany?: VlanScalarWhereInput | VlanScalarWhereInput[]
  }

  export type NetworkSubnetUncheckedUpdateManyWithoutSiteNestedInput = {
    create?: XOR<NetworkSubnetCreateWithoutSiteInput, NetworkSubnetUncheckedCreateWithoutSiteInput> | NetworkSubnetCreateWithoutSiteInput[] | NetworkSubnetUncheckedCreateWithoutSiteInput[]
    connectOrCreate?: NetworkSubnetCreateOrConnectWithoutSiteInput | NetworkSubnetCreateOrConnectWithoutSiteInput[]
    upsert?: NetworkSubnetUpsertWithWhereUniqueWithoutSiteInput | NetworkSubnetUpsertWithWhereUniqueWithoutSiteInput[]
    createMany?: NetworkSubnetCreateManySiteInputEnvelope
    set?: NetworkSubnetWhereUniqueInput | NetworkSubnetWhereUniqueInput[]
    disconnect?: NetworkSubnetWhereUniqueInput | NetworkSubnetWhereUniqueInput[]
    delete?: NetworkSubnetWhereUniqueInput | NetworkSubnetWhereUniqueInput[]
    connect?: NetworkSubnetWhereUniqueInput | NetworkSubnetWhereUniqueInput[]
    update?: NetworkSubnetUpdateWithWhereUniqueWithoutSiteInput | NetworkSubnetUpdateWithWhereUniqueWithoutSiteInput[]
    updateMany?: NetworkSubnetUpdateManyWithWhereWithoutSiteInput | NetworkSubnetUpdateManyWithWhereWithoutSiteInput[]
    deleteMany?: NetworkSubnetScalarWhereInput | NetworkSubnetScalarWhereInput[]
  }

  export type NetworkDeviceUncheckedUpdateManyWithoutSiteNestedInput = {
    create?: XOR<NetworkDeviceCreateWithoutSiteInput, NetworkDeviceUncheckedCreateWithoutSiteInput> | NetworkDeviceCreateWithoutSiteInput[] | NetworkDeviceUncheckedCreateWithoutSiteInput[]
    connectOrCreate?: NetworkDeviceCreateOrConnectWithoutSiteInput | NetworkDeviceCreateOrConnectWithoutSiteInput[]
    upsert?: NetworkDeviceUpsertWithWhereUniqueWithoutSiteInput | NetworkDeviceUpsertWithWhereUniqueWithoutSiteInput[]
    createMany?: NetworkDeviceCreateManySiteInputEnvelope
    set?: NetworkDeviceWhereUniqueInput | NetworkDeviceWhereUniqueInput[]
    disconnect?: NetworkDeviceWhereUniqueInput | NetworkDeviceWhereUniqueInput[]
    delete?: NetworkDeviceWhereUniqueInput | NetworkDeviceWhereUniqueInput[]
    connect?: NetworkDeviceWhereUniqueInput | NetworkDeviceWhereUniqueInput[]
    update?: NetworkDeviceUpdateWithWhereUniqueWithoutSiteInput | NetworkDeviceUpdateWithWhereUniqueWithoutSiteInput[]
    updateMany?: NetworkDeviceUpdateManyWithWhereWithoutSiteInput | NetworkDeviceUpdateManyWithWhereWithoutSiteInput[]
    deleteMany?: NetworkDeviceScalarWhereInput | NetworkDeviceScalarWhereInput[]
  }

  export type VlanUncheckedUpdateManyWithoutSiteNestedInput = {
    create?: XOR<VlanCreateWithoutSiteInput, VlanUncheckedCreateWithoutSiteInput> | VlanCreateWithoutSiteInput[] | VlanUncheckedCreateWithoutSiteInput[]
    connectOrCreate?: VlanCreateOrConnectWithoutSiteInput | VlanCreateOrConnectWithoutSiteInput[]
    upsert?: VlanUpsertWithWhereUniqueWithoutSiteInput | VlanUpsertWithWhereUniqueWithoutSiteInput[]
    createMany?: VlanCreateManySiteInputEnvelope
    set?: VlanWhereUniqueInput | VlanWhereUniqueInput[]
    disconnect?: VlanWhereUniqueInput | VlanWhereUniqueInput[]
    delete?: VlanWhereUniqueInput | VlanWhereUniqueInput[]
    connect?: VlanWhereUniqueInput | VlanWhereUniqueInput[]
    update?: VlanUpdateWithWhereUniqueWithoutSiteInput | VlanUpdateWithWhereUniqueWithoutSiteInput[]
    updateMany?: VlanUpdateManyWithWhereWithoutSiteInput | VlanUpdateManyWithWhereWithoutSiteInput[]
    deleteMany?: VlanScalarWhereInput | VlanScalarWhereInput[]
  }

  export type SiteCreateNestedOneWithoutVlansInput = {
    create?: XOR<SiteCreateWithoutVlansInput, SiteUncheckedCreateWithoutVlansInput>
    connectOrCreate?: SiteCreateOrConnectWithoutVlansInput
    connect?: SiteWhereUniqueInput
  }

  export type NetworkSubnetCreateNestedManyWithoutVlanInput = {
    create?: XOR<NetworkSubnetCreateWithoutVlanInput, NetworkSubnetUncheckedCreateWithoutVlanInput> | NetworkSubnetCreateWithoutVlanInput[] | NetworkSubnetUncheckedCreateWithoutVlanInput[]
    connectOrCreate?: NetworkSubnetCreateOrConnectWithoutVlanInput | NetworkSubnetCreateOrConnectWithoutVlanInput[]
    createMany?: NetworkSubnetCreateManyVlanInputEnvelope
    connect?: NetworkSubnetWhereUniqueInput | NetworkSubnetWhereUniqueInput[]
  }

  export type NetworkSubnetUncheckedCreateNestedManyWithoutVlanInput = {
    create?: XOR<NetworkSubnetCreateWithoutVlanInput, NetworkSubnetUncheckedCreateWithoutVlanInput> | NetworkSubnetCreateWithoutVlanInput[] | NetworkSubnetUncheckedCreateWithoutVlanInput[]
    connectOrCreate?: NetworkSubnetCreateOrConnectWithoutVlanInput | NetworkSubnetCreateOrConnectWithoutVlanInput[]
    createMany?: NetworkSubnetCreateManyVlanInputEnvelope
    connect?: NetworkSubnetWhereUniqueInput | NetworkSubnetWhereUniqueInput[]
  }

  export type SiteUpdateOneWithoutVlansNestedInput = {
    create?: XOR<SiteCreateWithoutVlansInput, SiteUncheckedCreateWithoutVlansInput>
    connectOrCreate?: SiteCreateOrConnectWithoutVlansInput
    upsert?: SiteUpsertWithoutVlansInput
    disconnect?: SiteWhereInput | boolean
    delete?: SiteWhereInput | boolean
    connect?: SiteWhereUniqueInput
    update?: XOR<XOR<SiteUpdateToOneWithWhereWithoutVlansInput, SiteUpdateWithoutVlansInput>, SiteUncheckedUpdateWithoutVlansInput>
  }

  export type NetworkSubnetUpdateManyWithoutVlanNestedInput = {
    create?: XOR<NetworkSubnetCreateWithoutVlanInput, NetworkSubnetUncheckedCreateWithoutVlanInput> | NetworkSubnetCreateWithoutVlanInput[] | NetworkSubnetUncheckedCreateWithoutVlanInput[]
    connectOrCreate?: NetworkSubnetCreateOrConnectWithoutVlanInput | NetworkSubnetCreateOrConnectWithoutVlanInput[]
    upsert?: NetworkSubnetUpsertWithWhereUniqueWithoutVlanInput | NetworkSubnetUpsertWithWhereUniqueWithoutVlanInput[]
    createMany?: NetworkSubnetCreateManyVlanInputEnvelope
    set?: NetworkSubnetWhereUniqueInput | NetworkSubnetWhereUniqueInput[]
    disconnect?: NetworkSubnetWhereUniqueInput | NetworkSubnetWhereUniqueInput[]
    delete?: NetworkSubnetWhereUniqueInput | NetworkSubnetWhereUniqueInput[]
    connect?: NetworkSubnetWhereUniqueInput | NetworkSubnetWhereUniqueInput[]
    update?: NetworkSubnetUpdateWithWhereUniqueWithoutVlanInput | NetworkSubnetUpdateWithWhereUniqueWithoutVlanInput[]
    updateMany?: NetworkSubnetUpdateManyWithWhereWithoutVlanInput | NetworkSubnetUpdateManyWithWhereWithoutVlanInput[]
    deleteMany?: NetworkSubnetScalarWhereInput | NetworkSubnetScalarWhereInput[]
  }

  export type NetworkSubnetUncheckedUpdateManyWithoutVlanNestedInput = {
    create?: XOR<NetworkSubnetCreateWithoutVlanInput, NetworkSubnetUncheckedCreateWithoutVlanInput> | NetworkSubnetCreateWithoutVlanInput[] | NetworkSubnetUncheckedCreateWithoutVlanInput[]
    connectOrCreate?: NetworkSubnetCreateOrConnectWithoutVlanInput | NetworkSubnetCreateOrConnectWithoutVlanInput[]
    upsert?: NetworkSubnetUpsertWithWhereUniqueWithoutVlanInput | NetworkSubnetUpsertWithWhereUniqueWithoutVlanInput[]
    createMany?: NetworkSubnetCreateManyVlanInputEnvelope
    set?: NetworkSubnetWhereUniqueInput | NetworkSubnetWhereUniqueInput[]
    disconnect?: NetworkSubnetWhereUniqueInput | NetworkSubnetWhereUniqueInput[]
    delete?: NetworkSubnetWhereUniqueInput | NetworkSubnetWhereUniqueInput[]
    connect?: NetworkSubnetWhereUniqueInput | NetworkSubnetWhereUniqueInput[]
    update?: NetworkSubnetUpdateWithWhereUniqueWithoutVlanInput | NetworkSubnetUpdateWithWhereUniqueWithoutVlanInput[]
    updateMany?: NetworkSubnetUpdateManyWithWhereWithoutVlanInput | NetworkSubnetUpdateManyWithWhereWithoutVlanInput[]
    deleteMany?: NetworkSubnetScalarWhereInput | NetworkSubnetScalarWhereInput[]
  }

  export type SiteCreateNestedOneWithoutSubnetsInput = {
    create?: XOR<SiteCreateWithoutSubnetsInput, SiteUncheckedCreateWithoutSubnetsInput>
    connectOrCreate?: SiteCreateOrConnectWithoutSubnetsInput
    connect?: SiteWhereUniqueInput
  }

  export type VlanCreateNestedOneWithoutSubnetsInput = {
    create?: XOR<VlanCreateWithoutSubnetsInput, VlanUncheckedCreateWithoutSubnetsInput>
    connectOrCreate?: VlanCreateOrConnectWithoutSubnetsInput
    connect?: VlanWhereUniqueInput
  }

  export type NetworkSubnetCreateNestedOneWithoutChildrenInput = {
    create?: XOR<NetworkSubnetCreateWithoutChildrenInput, NetworkSubnetUncheckedCreateWithoutChildrenInput>
    connectOrCreate?: NetworkSubnetCreateOrConnectWithoutChildrenInput
    connect?: NetworkSubnetWhereUniqueInput
  }

  export type NetworkSubnetCreateNestedManyWithoutParentInput = {
    create?: XOR<NetworkSubnetCreateWithoutParentInput, NetworkSubnetUncheckedCreateWithoutParentInput> | NetworkSubnetCreateWithoutParentInput[] | NetworkSubnetUncheckedCreateWithoutParentInput[]
    connectOrCreate?: NetworkSubnetCreateOrConnectWithoutParentInput | NetworkSubnetCreateOrConnectWithoutParentInput[]
    createMany?: NetworkSubnetCreateManyParentInputEnvelope
    connect?: NetworkSubnetWhereUniqueInput | NetworkSubnetWhereUniqueInput[]
  }

  export type NetworkIPCreateNestedManyWithoutSubnetInput = {
    create?: XOR<NetworkIPCreateWithoutSubnetInput, NetworkIPUncheckedCreateWithoutSubnetInput> | NetworkIPCreateWithoutSubnetInput[] | NetworkIPUncheckedCreateWithoutSubnetInput[]
    connectOrCreate?: NetworkIPCreateOrConnectWithoutSubnetInput | NetworkIPCreateOrConnectWithoutSubnetInput[]
    createMany?: NetworkIPCreateManySubnetInputEnvelope
    connect?: NetworkIPWhereUniqueInput | NetworkIPWhereUniqueInput[]
  }

  export type NetworkSubnetUncheckedCreateNestedManyWithoutParentInput = {
    create?: XOR<NetworkSubnetCreateWithoutParentInput, NetworkSubnetUncheckedCreateWithoutParentInput> | NetworkSubnetCreateWithoutParentInput[] | NetworkSubnetUncheckedCreateWithoutParentInput[]
    connectOrCreate?: NetworkSubnetCreateOrConnectWithoutParentInput | NetworkSubnetCreateOrConnectWithoutParentInput[]
    createMany?: NetworkSubnetCreateManyParentInputEnvelope
    connect?: NetworkSubnetWhereUniqueInput | NetworkSubnetWhereUniqueInput[]
  }

  export type NetworkIPUncheckedCreateNestedManyWithoutSubnetInput = {
    create?: XOR<NetworkIPCreateWithoutSubnetInput, NetworkIPUncheckedCreateWithoutSubnetInput> | NetworkIPCreateWithoutSubnetInput[] | NetworkIPUncheckedCreateWithoutSubnetInput[]
    connectOrCreate?: NetworkIPCreateOrConnectWithoutSubnetInput | NetworkIPCreateOrConnectWithoutSubnetInput[]
    createMany?: NetworkIPCreateManySubnetInputEnvelope
    connect?: NetworkIPWhereUniqueInput | NetworkIPWhereUniqueInput[]
  }

  export type SiteUpdateOneWithoutSubnetsNestedInput = {
    create?: XOR<SiteCreateWithoutSubnetsInput, SiteUncheckedCreateWithoutSubnetsInput>
    connectOrCreate?: SiteCreateOrConnectWithoutSubnetsInput
    upsert?: SiteUpsertWithoutSubnetsInput
    disconnect?: SiteWhereInput | boolean
    delete?: SiteWhereInput | boolean
    connect?: SiteWhereUniqueInput
    update?: XOR<XOR<SiteUpdateToOneWithWhereWithoutSubnetsInput, SiteUpdateWithoutSubnetsInput>, SiteUncheckedUpdateWithoutSubnetsInput>
  }

  export type VlanUpdateOneWithoutSubnetsNestedInput = {
    create?: XOR<VlanCreateWithoutSubnetsInput, VlanUncheckedCreateWithoutSubnetsInput>
    connectOrCreate?: VlanCreateOrConnectWithoutSubnetsInput
    upsert?: VlanUpsertWithoutSubnetsInput
    disconnect?: VlanWhereInput | boolean
    delete?: VlanWhereInput | boolean
    connect?: VlanWhereUniqueInput
    update?: XOR<XOR<VlanUpdateToOneWithWhereWithoutSubnetsInput, VlanUpdateWithoutSubnetsInput>, VlanUncheckedUpdateWithoutSubnetsInput>
  }

  export type NetworkSubnetUpdateOneWithoutChildrenNestedInput = {
    create?: XOR<NetworkSubnetCreateWithoutChildrenInput, NetworkSubnetUncheckedCreateWithoutChildrenInput>
    connectOrCreate?: NetworkSubnetCreateOrConnectWithoutChildrenInput
    upsert?: NetworkSubnetUpsertWithoutChildrenInput
    disconnect?: NetworkSubnetWhereInput | boolean
    delete?: NetworkSubnetWhereInput | boolean
    connect?: NetworkSubnetWhereUniqueInput
    update?: XOR<XOR<NetworkSubnetUpdateToOneWithWhereWithoutChildrenInput, NetworkSubnetUpdateWithoutChildrenInput>, NetworkSubnetUncheckedUpdateWithoutChildrenInput>
  }

  export type NetworkSubnetUpdateManyWithoutParentNestedInput = {
    create?: XOR<NetworkSubnetCreateWithoutParentInput, NetworkSubnetUncheckedCreateWithoutParentInput> | NetworkSubnetCreateWithoutParentInput[] | NetworkSubnetUncheckedCreateWithoutParentInput[]
    connectOrCreate?: NetworkSubnetCreateOrConnectWithoutParentInput | NetworkSubnetCreateOrConnectWithoutParentInput[]
    upsert?: NetworkSubnetUpsertWithWhereUniqueWithoutParentInput | NetworkSubnetUpsertWithWhereUniqueWithoutParentInput[]
    createMany?: NetworkSubnetCreateManyParentInputEnvelope
    set?: NetworkSubnetWhereUniqueInput | NetworkSubnetWhereUniqueInput[]
    disconnect?: NetworkSubnetWhereUniqueInput | NetworkSubnetWhereUniqueInput[]
    delete?: NetworkSubnetWhereUniqueInput | NetworkSubnetWhereUniqueInput[]
    connect?: NetworkSubnetWhereUniqueInput | NetworkSubnetWhereUniqueInput[]
    update?: NetworkSubnetUpdateWithWhereUniqueWithoutParentInput | NetworkSubnetUpdateWithWhereUniqueWithoutParentInput[]
    updateMany?: NetworkSubnetUpdateManyWithWhereWithoutParentInput | NetworkSubnetUpdateManyWithWhereWithoutParentInput[]
    deleteMany?: NetworkSubnetScalarWhereInput | NetworkSubnetScalarWhereInput[]
  }

  export type NetworkIPUpdateManyWithoutSubnetNestedInput = {
    create?: XOR<NetworkIPCreateWithoutSubnetInput, NetworkIPUncheckedCreateWithoutSubnetInput> | NetworkIPCreateWithoutSubnetInput[] | NetworkIPUncheckedCreateWithoutSubnetInput[]
    connectOrCreate?: NetworkIPCreateOrConnectWithoutSubnetInput | NetworkIPCreateOrConnectWithoutSubnetInput[]
    upsert?: NetworkIPUpsertWithWhereUniqueWithoutSubnetInput | NetworkIPUpsertWithWhereUniqueWithoutSubnetInput[]
    createMany?: NetworkIPCreateManySubnetInputEnvelope
    set?: NetworkIPWhereUniqueInput | NetworkIPWhereUniqueInput[]
    disconnect?: NetworkIPWhereUniqueInput | NetworkIPWhereUniqueInput[]
    delete?: NetworkIPWhereUniqueInput | NetworkIPWhereUniqueInput[]
    connect?: NetworkIPWhereUniqueInput | NetworkIPWhereUniqueInput[]
    update?: NetworkIPUpdateWithWhereUniqueWithoutSubnetInput | NetworkIPUpdateWithWhereUniqueWithoutSubnetInput[]
    updateMany?: NetworkIPUpdateManyWithWhereWithoutSubnetInput | NetworkIPUpdateManyWithWhereWithoutSubnetInput[]
    deleteMany?: NetworkIPScalarWhereInput | NetworkIPScalarWhereInput[]
  }

  export type NetworkSubnetUncheckedUpdateManyWithoutParentNestedInput = {
    create?: XOR<NetworkSubnetCreateWithoutParentInput, NetworkSubnetUncheckedCreateWithoutParentInput> | NetworkSubnetCreateWithoutParentInput[] | NetworkSubnetUncheckedCreateWithoutParentInput[]
    connectOrCreate?: NetworkSubnetCreateOrConnectWithoutParentInput | NetworkSubnetCreateOrConnectWithoutParentInput[]
    upsert?: NetworkSubnetUpsertWithWhereUniqueWithoutParentInput | NetworkSubnetUpsertWithWhereUniqueWithoutParentInput[]
    createMany?: NetworkSubnetCreateManyParentInputEnvelope
    set?: NetworkSubnetWhereUniqueInput | NetworkSubnetWhereUniqueInput[]
    disconnect?: NetworkSubnetWhereUniqueInput | NetworkSubnetWhereUniqueInput[]
    delete?: NetworkSubnetWhereUniqueInput | NetworkSubnetWhereUniqueInput[]
    connect?: NetworkSubnetWhereUniqueInput | NetworkSubnetWhereUniqueInput[]
    update?: NetworkSubnetUpdateWithWhereUniqueWithoutParentInput | NetworkSubnetUpdateWithWhereUniqueWithoutParentInput[]
    updateMany?: NetworkSubnetUpdateManyWithWhereWithoutParentInput | NetworkSubnetUpdateManyWithWhereWithoutParentInput[]
    deleteMany?: NetworkSubnetScalarWhereInput | NetworkSubnetScalarWhereInput[]
  }

  export type NetworkIPUncheckedUpdateManyWithoutSubnetNestedInput = {
    create?: XOR<NetworkIPCreateWithoutSubnetInput, NetworkIPUncheckedCreateWithoutSubnetInput> | NetworkIPCreateWithoutSubnetInput[] | NetworkIPUncheckedCreateWithoutSubnetInput[]
    connectOrCreate?: NetworkIPCreateOrConnectWithoutSubnetInput | NetworkIPCreateOrConnectWithoutSubnetInput[]
    upsert?: NetworkIPUpsertWithWhereUniqueWithoutSubnetInput | NetworkIPUpsertWithWhereUniqueWithoutSubnetInput[]
    createMany?: NetworkIPCreateManySubnetInputEnvelope
    set?: NetworkIPWhereUniqueInput | NetworkIPWhereUniqueInput[]
    disconnect?: NetworkIPWhereUniqueInput | NetworkIPWhereUniqueInput[]
    delete?: NetworkIPWhereUniqueInput | NetworkIPWhereUniqueInput[]
    connect?: NetworkIPWhereUniqueInput | NetworkIPWhereUniqueInput[]
    update?: NetworkIPUpdateWithWhereUniqueWithoutSubnetInput | NetworkIPUpdateWithWhereUniqueWithoutSubnetInput[]
    updateMany?: NetworkIPUpdateManyWithWhereWithoutSubnetInput | NetworkIPUpdateManyWithWhereWithoutSubnetInput[]
    deleteMany?: NetworkIPScalarWhereInput | NetworkIPScalarWhereInput[]
  }

  export type NetworkSubnetCreateNestedOneWithoutIpsInput = {
    create?: XOR<NetworkSubnetCreateWithoutIpsInput, NetworkSubnetUncheckedCreateWithoutIpsInput>
    connectOrCreate?: NetworkSubnetCreateOrConnectWithoutIpsInput
    connect?: NetworkSubnetWhereUniqueInput
  }

  export type NetworkDeviceCreateNestedOneWithoutIpsInput = {
    create?: XOR<NetworkDeviceCreateWithoutIpsInput, NetworkDeviceUncheckedCreateWithoutIpsInput>
    connectOrCreate?: NetworkDeviceCreateOrConnectWithoutIpsInput
    connect?: NetworkDeviceWhereUniqueInput
  }

  export type EnumIPStatusFieldUpdateOperationsInput = {
    set?: $Enums.IPStatus
  }

  export type NetworkSubnetUpdateOneRequiredWithoutIpsNestedInput = {
    create?: XOR<NetworkSubnetCreateWithoutIpsInput, NetworkSubnetUncheckedCreateWithoutIpsInput>
    connectOrCreate?: NetworkSubnetCreateOrConnectWithoutIpsInput
    upsert?: NetworkSubnetUpsertWithoutIpsInput
    connect?: NetworkSubnetWhereUniqueInput
    update?: XOR<XOR<NetworkSubnetUpdateToOneWithWhereWithoutIpsInput, NetworkSubnetUpdateWithoutIpsInput>, NetworkSubnetUncheckedUpdateWithoutIpsInput>
  }

  export type NetworkDeviceUpdateOneWithoutIpsNestedInput = {
    create?: XOR<NetworkDeviceCreateWithoutIpsInput, NetworkDeviceUncheckedCreateWithoutIpsInput>
    connectOrCreate?: NetworkDeviceCreateOrConnectWithoutIpsInput
    upsert?: NetworkDeviceUpsertWithoutIpsInput
    disconnect?: NetworkDeviceWhereInput | boolean
    delete?: NetworkDeviceWhereInput | boolean
    connect?: NetworkDeviceWhereUniqueInput
    update?: XOR<XOR<NetworkDeviceUpdateToOneWithWhereWithoutIpsInput, NetworkDeviceUpdateWithoutIpsInput>, NetworkDeviceUncheckedUpdateWithoutIpsInput>
  }

  export type SiteCreateNestedOneWithoutDevicesInput = {
    create?: XOR<SiteCreateWithoutDevicesInput, SiteUncheckedCreateWithoutDevicesInput>
    connectOrCreate?: SiteCreateOrConnectWithoutDevicesInput
    connect?: SiteWhereUniqueInput
  }

  export type NetworkServiceCreateNestedManyWithoutDeviceInput = {
    create?: XOR<NetworkServiceCreateWithoutDeviceInput, NetworkServiceUncheckedCreateWithoutDeviceInput> | NetworkServiceCreateWithoutDeviceInput[] | NetworkServiceUncheckedCreateWithoutDeviceInput[]
    connectOrCreate?: NetworkServiceCreateOrConnectWithoutDeviceInput | NetworkServiceCreateOrConnectWithoutDeviceInput[]
    createMany?: NetworkServiceCreateManyDeviceInputEnvelope
    connect?: NetworkServiceWhereUniqueInput | NetworkServiceWhereUniqueInput[]
  }

  export type NetworkIPCreateNestedManyWithoutDeviceInput = {
    create?: XOR<NetworkIPCreateWithoutDeviceInput, NetworkIPUncheckedCreateWithoutDeviceInput> | NetworkIPCreateWithoutDeviceInput[] | NetworkIPUncheckedCreateWithoutDeviceInput[]
    connectOrCreate?: NetworkIPCreateOrConnectWithoutDeviceInput | NetworkIPCreateOrConnectWithoutDeviceInput[]
    createMany?: NetworkIPCreateManyDeviceInputEnvelope
    connect?: NetworkIPWhereUniqueInput | NetworkIPWhereUniqueInput[]
  }

  export type NetworkServiceUncheckedCreateNestedManyWithoutDeviceInput = {
    create?: XOR<NetworkServiceCreateWithoutDeviceInput, NetworkServiceUncheckedCreateWithoutDeviceInput> | NetworkServiceCreateWithoutDeviceInput[] | NetworkServiceUncheckedCreateWithoutDeviceInput[]
    connectOrCreate?: NetworkServiceCreateOrConnectWithoutDeviceInput | NetworkServiceCreateOrConnectWithoutDeviceInput[]
    createMany?: NetworkServiceCreateManyDeviceInputEnvelope
    connect?: NetworkServiceWhereUniqueInput | NetworkServiceWhereUniqueInput[]
  }

  export type NetworkIPUncheckedCreateNestedManyWithoutDeviceInput = {
    create?: XOR<NetworkIPCreateWithoutDeviceInput, NetworkIPUncheckedCreateWithoutDeviceInput> | NetworkIPCreateWithoutDeviceInput[] | NetworkIPUncheckedCreateWithoutDeviceInput[]
    connectOrCreate?: NetworkIPCreateOrConnectWithoutDeviceInput | NetworkIPCreateOrConnectWithoutDeviceInput[]
    createMany?: NetworkIPCreateManyDeviceInputEnvelope
    connect?: NetworkIPWhereUniqueInput | NetworkIPWhereUniqueInput[]
  }

  export type EnumDeviceTypeFieldUpdateOperationsInput = {
    set?: $Enums.DeviceType
  }

  export type SiteUpdateOneWithoutDevicesNestedInput = {
    create?: XOR<SiteCreateWithoutDevicesInput, SiteUncheckedCreateWithoutDevicesInput>
    connectOrCreate?: SiteCreateOrConnectWithoutDevicesInput
    upsert?: SiteUpsertWithoutDevicesInput
    disconnect?: SiteWhereInput | boolean
    delete?: SiteWhereInput | boolean
    connect?: SiteWhereUniqueInput
    update?: XOR<XOR<SiteUpdateToOneWithWhereWithoutDevicesInput, SiteUpdateWithoutDevicesInput>, SiteUncheckedUpdateWithoutDevicesInput>
  }

  export type NetworkServiceUpdateManyWithoutDeviceNestedInput = {
    create?: XOR<NetworkServiceCreateWithoutDeviceInput, NetworkServiceUncheckedCreateWithoutDeviceInput> | NetworkServiceCreateWithoutDeviceInput[] | NetworkServiceUncheckedCreateWithoutDeviceInput[]
    connectOrCreate?: NetworkServiceCreateOrConnectWithoutDeviceInput | NetworkServiceCreateOrConnectWithoutDeviceInput[]
    upsert?: NetworkServiceUpsertWithWhereUniqueWithoutDeviceInput | NetworkServiceUpsertWithWhereUniqueWithoutDeviceInput[]
    createMany?: NetworkServiceCreateManyDeviceInputEnvelope
    set?: NetworkServiceWhereUniqueInput | NetworkServiceWhereUniqueInput[]
    disconnect?: NetworkServiceWhereUniqueInput | NetworkServiceWhereUniqueInput[]
    delete?: NetworkServiceWhereUniqueInput | NetworkServiceWhereUniqueInput[]
    connect?: NetworkServiceWhereUniqueInput | NetworkServiceWhereUniqueInput[]
    update?: NetworkServiceUpdateWithWhereUniqueWithoutDeviceInput | NetworkServiceUpdateWithWhereUniqueWithoutDeviceInput[]
    updateMany?: NetworkServiceUpdateManyWithWhereWithoutDeviceInput | NetworkServiceUpdateManyWithWhereWithoutDeviceInput[]
    deleteMany?: NetworkServiceScalarWhereInput | NetworkServiceScalarWhereInput[]
  }

  export type NetworkIPUpdateManyWithoutDeviceNestedInput = {
    create?: XOR<NetworkIPCreateWithoutDeviceInput, NetworkIPUncheckedCreateWithoutDeviceInput> | NetworkIPCreateWithoutDeviceInput[] | NetworkIPUncheckedCreateWithoutDeviceInput[]
    connectOrCreate?: NetworkIPCreateOrConnectWithoutDeviceInput | NetworkIPCreateOrConnectWithoutDeviceInput[]
    upsert?: NetworkIPUpsertWithWhereUniqueWithoutDeviceInput | NetworkIPUpsertWithWhereUniqueWithoutDeviceInput[]
    createMany?: NetworkIPCreateManyDeviceInputEnvelope
    set?: NetworkIPWhereUniqueInput | NetworkIPWhereUniqueInput[]
    disconnect?: NetworkIPWhereUniqueInput | NetworkIPWhereUniqueInput[]
    delete?: NetworkIPWhereUniqueInput | NetworkIPWhereUniqueInput[]
    connect?: NetworkIPWhereUniqueInput | NetworkIPWhereUniqueInput[]
    update?: NetworkIPUpdateWithWhereUniqueWithoutDeviceInput | NetworkIPUpdateWithWhereUniqueWithoutDeviceInput[]
    updateMany?: NetworkIPUpdateManyWithWhereWithoutDeviceInput | NetworkIPUpdateManyWithWhereWithoutDeviceInput[]
    deleteMany?: NetworkIPScalarWhereInput | NetworkIPScalarWhereInput[]
  }

  export type NetworkServiceUncheckedUpdateManyWithoutDeviceNestedInput = {
    create?: XOR<NetworkServiceCreateWithoutDeviceInput, NetworkServiceUncheckedCreateWithoutDeviceInput> | NetworkServiceCreateWithoutDeviceInput[] | NetworkServiceUncheckedCreateWithoutDeviceInput[]
    connectOrCreate?: NetworkServiceCreateOrConnectWithoutDeviceInput | NetworkServiceCreateOrConnectWithoutDeviceInput[]
    upsert?: NetworkServiceUpsertWithWhereUniqueWithoutDeviceInput | NetworkServiceUpsertWithWhereUniqueWithoutDeviceInput[]
    createMany?: NetworkServiceCreateManyDeviceInputEnvelope
    set?: NetworkServiceWhereUniqueInput | NetworkServiceWhereUniqueInput[]
    disconnect?: NetworkServiceWhereUniqueInput | NetworkServiceWhereUniqueInput[]
    delete?: NetworkServiceWhereUniqueInput | NetworkServiceWhereUniqueInput[]
    connect?: NetworkServiceWhereUniqueInput | NetworkServiceWhereUniqueInput[]
    update?: NetworkServiceUpdateWithWhereUniqueWithoutDeviceInput | NetworkServiceUpdateWithWhereUniqueWithoutDeviceInput[]
    updateMany?: NetworkServiceUpdateManyWithWhereWithoutDeviceInput | NetworkServiceUpdateManyWithWhereWithoutDeviceInput[]
    deleteMany?: NetworkServiceScalarWhereInput | NetworkServiceScalarWhereInput[]
  }

  export type NetworkIPUncheckedUpdateManyWithoutDeviceNestedInput = {
    create?: XOR<NetworkIPCreateWithoutDeviceInput, NetworkIPUncheckedCreateWithoutDeviceInput> | NetworkIPCreateWithoutDeviceInput[] | NetworkIPUncheckedCreateWithoutDeviceInput[]
    connectOrCreate?: NetworkIPCreateOrConnectWithoutDeviceInput | NetworkIPCreateOrConnectWithoutDeviceInput[]
    upsert?: NetworkIPUpsertWithWhereUniqueWithoutDeviceInput | NetworkIPUpsertWithWhereUniqueWithoutDeviceInput[]
    createMany?: NetworkIPCreateManyDeviceInputEnvelope
    set?: NetworkIPWhereUniqueInput | NetworkIPWhereUniqueInput[]
    disconnect?: NetworkIPWhereUniqueInput | NetworkIPWhereUniqueInput[]
    delete?: NetworkIPWhereUniqueInput | NetworkIPWhereUniqueInput[]
    connect?: NetworkIPWhereUniqueInput | NetworkIPWhereUniqueInput[]
    update?: NetworkIPUpdateWithWhereUniqueWithoutDeviceInput | NetworkIPUpdateWithWhereUniqueWithoutDeviceInput[]
    updateMany?: NetworkIPUpdateManyWithWhereWithoutDeviceInput | NetworkIPUpdateManyWithWhereWithoutDeviceInput[]
    deleteMany?: NetworkIPScalarWhereInput | NetworkIPScalarWhereInput[]
  }

  export type NetworkDeviceCreateNestedOneWithoutServicesInput = {
    create?: XOR<NetworkDeviceCreateWithoutServicesInput, NetworkDeviceUncheckedCreateWithoutServicesInput>
    connectOrCreate?: NetworkDeviceCreateOrConnectWithoutServicesInput
    connect?: NetworkDeviceWhereUniqueInput
  }

  export type EnumProtocolFieldUpdateOperationsInput = {
    set?: $Enums.Protocol
  }

  export type NetworkDeviceUpdateOneRequiredWithoutServicesNestedInput = {
    create?: XOR<NetworkDeviceCreateWithoutServicesInput, NetworkDeviceUncheckedCreateWithoutServicesInput>
    connectOrCreate?: NetworkDeviceCreateOrConnectWithoutServicesInput
    upsert?: NetworkDeviceUpsertWithoutServicesInput
    connect?: NetworkDeviceWhereUniqueInput
    update?: XOR<XOR<NetworkDeviceUpdateToOneWithWhereWithoutServicesInput, NetworkDeviceUpdateWithoutServicesInput>, NetworkDeviceUncheckedUpdateWithoutServicesInput>
  }

  export type NestedStringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[]
    notIn?: string[]
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type NestedStringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | null
    notIn?: string[] | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type NestedDateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[]
    notIn?: Date[] | string[]
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type NestedStringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[]
    notIn?: string[]
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type NestedIntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type NestedStringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | null
    notIn?: string[] | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type NestedIntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | null
    notIn?: number[] | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type NestedDateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[]
    notIn?: Date[] | string[]
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type NestedFloatFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatFilter<$PrismaModel> | number
  }

  export type NestedFloatWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedFloatFilter<$PrismaModel>
    _min?: NestedFloatFilter<$PrismaModel>
    _max?: NestedFloatFilter<$PrismaModel>
  }

  export type NestedDateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | null
    notIn?: Date[] | string[] | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type NestedDateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | null
    notIn?: Date[] | string[] | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type NestedFloatNullableFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | null
    notIn?: number[] | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableFilter<$PrismaModel> | number | null
  }

  export type NestedIntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type NestedFloatNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | null
    notIn?: number[] | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedFloatNullableFilter<$PrismaModel>
    _min?: NestedFloatNullableFilter<$PrismaModel>
    _max?: NestedFloatNullableFilter<$PrismaModel>
  }

  export type NestedIntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | null
    notIn?: number[] | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
  }

  export type NestedBoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type NestedBoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type NestedBigIntNullableFilter<$PrismaModel = never> = {
    equals?: bigint | number | BigIntFieldRefInput<$PrismaModel> | null
    in?: bigint[] | number[] | null
    notIn?: bigint[] | number[] | null
    lt?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    lte?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    gt?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    gte?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    not?: NestedBigIntNullableFilter<$PrismaModel> | bigint | number | null
  }

  export type NestedBigIntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: bigint | number | BigIntFieldRefInput<$PrismaModel> | null
    in?: bigint[] | number[] | null
    notIn?: bigint[] | number[] | null
    lt?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    lte?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    gt?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    gte?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    not?: NestedBigIntNullableWithAggregatesFilter<$PrismaModel> | bigint | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedBigIntNullableFilter<$PrismaModel>
    _min?: NestedBigIntNullableFilter<$PrismaModel>
    _max?: NestedBigIntNullableFilter<$PrismaModel>
  }

  export type NestedEnumIPStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.IPStatus | EnumIPStatusFieldRefInput<$PrismaModel>
    in?: $Enums.IPStatus[]
    notIn?: $Enums.IPStatus[]
    not?: NestedEnumIPStatusFilter<$PrismaModel> | $Enums.IPStatus
  }

  export type NestedEnumIPStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.IPStatus | EnumIPStatusFieldRefInput<$PrismaModel>
    in?: $Enums.IPStatus[]
    notIn?: $Enums.IPStatus[]
    not?: NestedEnumIPStatusWithAggregatesFilter<$PrismaModel> | $Enums.IPStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumIPStatusFilter<$PrismaModel>
    _max?: NestedEnumIPStatusFilter<$PrismaModel>
  }

  export type NestedEnumDeviceTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.DeviceType | EnumDeviceTypeFieldRefInput<$PrismaModel>
    in?: $Enums.DeviceType[]
    notIn?: $Enums.DeviceType[]
    not?: NestedEnumDeviceTypeFilter<$PrismaModel> | $Enums.DeviceType
  }

  export type NestedEnumDeviceTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.DeviceType | EnumDeviceTypeFieldRefInput<$PrismaModel>
    in?: $Enums.DeviceType[]
    notIn?: $Enums.DeviceType[]
    not?: NestedEnumDeviceTypeWithAggregatesFilter<$PrismaModel> | $Enums.DeviceType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumDeviceTypeFilter<$PrismaModel>
    _max?: NestedEnumDeviceTypeFilter<$PrismaModel>
  }

  export type NestedEnumProtocolFilter<$PrismaModel = never> = {
    equals?: $Enums.Protocol | EnumProtocolFieldRefInput<$PrismaModel>
    in?: $Enums.Protocol[]
    notIn?: $Enums.Protocol[]
    not?: NestedEnumProtocolFilter<$PrismaModel> | $Enums.Protocol
  }

  export type NestedEnumProtocolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.Protocol | EnumProtocolFieldRefInput<$PrismaModel>
    in?: $Enums.Protocol[]
    notIn?: $Enums.Protocol[]
    not?: NestedEnumProtocolWithAggregatesFilter<$PrismaModel> | $Enums.Protocol
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumProtocolFilter<$PrismaModel>
    _max?: NestedEnumProtocolFilter<$PrismaModel>
  }

  export type SubscriptionCreateWithoutUserInput = {
    id?: string
    planName: string
    price: number
    status: string
    createdAt?: Date | string
    updatedAt?: Date | string
    invoices?: InvoiceCreateNestedManyWithoutSubscriptionInput
  }

  export type SubscriptionUncheckedCreateWithoutUserInput = {
    id?: string
    planName: string
    price: number
    status: string
    createdAt?: Date | string
    updatedAt?: Date | string
    invoices?: InvoiceUncheckedCreateNestedManyWithoutSubscriptionInput
  }

  export type SubscriptionCreateOrConnectWithoutUserInput = {
    where: SubscriptionWhereUniqueInput
    create: XOR<SubscriptionCreateWithoutUserInput, SubscriptionUncheckedCreateWithoutUserInput>
  }

  export type SubscriptionCreateManyUserInputEnvelope = {
    data: SubscriptionCreateManyUserInput | SubscriptionCreateManyUserInput[]
  }

  export type SubscriptionUpsertWithWhereUniqueWithoutUserInput = {
    where: SubscriptionWhereUniqueInput
    update: XOR<SubscriptionUpdateWithoutUserInput, SubscriptionUncheckedUpdateWithoutUserInput>
    create: XOR<SubscriptionCreateWithoutUserInput, SubscriptionUncheckedCreateWithoutUserInput>
  }

  export type SubscriptionUpdateWithWhereUniqueWithoutUserInput = {
    where: SubscriptionWhereUniqueInput
    data: XOR<SubscriptionUpdateWithoutUserInput, SubscriptionUncheckedUpdateWithoutUserInput>
  }

  export type SubscriptionUpdateManyWithWhereWithoutUserInput = {
    where: SubscriptionScalarWhereInput
    data: XOR<SubscriptionUpdateManyMutationInput, SubscriptionUncheckedUpdateManyWithoutUserInput>
  }

  export type SubscriptionScalarWhereInput = {
    AND?: SubscriptionScalarWhereInput | SubscriptionScalarWhereInput[]
    OR?: SubscriptionScalarWhereInput[]
    NOT?: SubscriptionScalarWhereInput | SubscriptionScalarWhereInput[]
    id?: StringFilter<"Subscription"> | string
    userId?: StringFilter<"Subscription"> | string
    planName?: StringFilter<"Subscription"> | string
    price?: FloatFilter<"Subscription"> | number
    status?: StringFilter<"Subscription"> | string
    createdAt?: DateTimeFilter<"Subscription"> | Date | string
    updatedAt?: DateTimeFilter<"Subscription"> | Date | string
  }

  export type UserCreateWithoutSubscriptionsInput = {
    id?: string
    name: string
    email: string
    password: string
    role?: string
    phone?: string | null
    address?: string | null
    city?: string | null
    state?: string | null
    zipCode?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type UserUncheckedCreateWithoutSubscriptionsInput = {
    id?: string
    name: string
    email: string
    password: string
    role?: string
    phone?: string | null
    address?: string | null
    city?: string | null
    state?: string | null
    zipCode?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type UserCreateOrConnectWithoutSubscriptionsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutSubscriptionsInput, UserUncheckedCreateWithoutSubscriptionsInput>
  }

  export type InvoiceCreateWithoutSubscriptionInput = {
    id?: string
    amount: number
    status: string
    dueDate: Date | string
    paidAt?: Date | string | null
    createdAt?: Date | string
  }

  export type InvoiceUncheckedCreateWithoutSubscriptionInput = {
    id?: string
    amount: number
    status: string
    dueDate: Date | string
    paidAt?: Date | string | null
    createdAt?: Date | string
  }

  export type InvoiceCreateOrConnectWithoutSubscriptionInput = {
    where: InvoiceWhereUniqueInput
    create: XOR<InvoiceCreateWithoutSubscriptionInput, InvoiceUncheckedCreateWithoutSubscriptionInput>
  }

  export type InvoiceCreateManySubscriptionInputEnvelope = {
    data: InvoiceCreateManySubscriptionInput | InvoiceCreateManySubscriptionInput[]
  }

  export type UserUpsertWithoutSubscriptionsInput = {
    update: XOR<UserUpdateWithoutSubscriptionsInput, UserUncheckedUpdateWithoutSubscriptionsInput>
    create: XOR<UserCreateWithoutSubscriptionsInput, UserUncheckedCreateWithoutSubscriptionsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutSubscriptionsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutSubscriptionsInput, UserUncheckedUpdateWithoutSubscriptionsInput>
  }

  export type UserUpdateWithoutSubscriptionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    state?: NullableStringFieldUpdateOperationsInput | string | null
    zipCode?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserUncheckedUpdateWithoutSubscriptionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    state?: NullableStringFieldUpdateOperationsInput | string | null
    zipCode?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type InvoiceUpsertWithWhereUniqueWithoutSubscriptionInput = {
    where: InvoiceWhereUniqueInput
    update: XOR<InvoiceUpdateWithoutSubscriptionInput, InvoiceUncheckedUpdateWithoutSubscriptionInput>
    create: XOR<InvoiceCreateWithoutSubscriptionInput, InvoiceUncheckedCreateWithoutSubscriptionInput>
  }

  export type InvoiceUpdateWithWhereUniqueWithoutSubscriptionInput = {
    where: InvoiceWhereUniqueInput
    data: XOR<InvoiceUpdateWithoutSubscriptionInput, InvoiceUncheckedUpdateWithoutSubscriptionInput>
  }

  export type InvoiceUpdateManyWithWhereWithoutSubscriptionInput = {
    where: InvoiceScalarWhereInput
    data: XOR<InvoiceUpdateManyMutationInput, InvoiceUncheckedUpdateManyWithoutSubscriptionInput>
  }

  export type InvoiceScalarWhereInput = {
    AND?: InvoiceScalarWhereInput | InvoiceScalarWhereInput[]
    OR?: InvoiceScalarWhereInput[]
    NOT?: InvoiceScalarWhereInput | InvoiceScalarWhereInput[]
    id?: StringFilter<"Invoice"> | string
    subscriptionId?: StringFilter<"Invoice"> | string
    amount?: FloatFilter<"Invoice"> | number
    status?: StringFilter<"Invoice"> | string
    dueDate?: DateTimeFilter<"Invoice"> | Date | string
    paidAt?: DateTimeNullableFilter<"Invoice"> | Date | string | null
    createdAt?: DateTimeFilter<"Invoice"> | Date | string
  }

  export type SubscriptionCreateWithoutInvoicesInput = {
    id?: string
    planName: string
    price: number
    status: string
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutSubscriptionsInput
  }

  export type SubscriptionUncheckedCreateWithoutInvoicesInput = {
    id?: string
    userId: string
    planName: string
    price: number
    status: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SubscriptionCreateOrConnectWithoutInvoicesInput = {
    where: SubscriptionWhereUniqueInput
    create: XOR<SubscriptionCreateWithoutInvoicesInput, SubscriptionUncheckedCreateWithoutInvoicesInput>
  }

  export type SubscriptionUpsertWithoutInvoicesInput = {
    update: XOR<SubscriptionUpdateWithoutInvoicesInput, SubscriptionUncheckedUpdateWithoutInvoicesInput>
    create: XOR<SubscriptionCreateWithoutInvoicesInput, SubscriptionUncheckedCreateWithoutInvoicesInput>
    where?: SubscriptionWhereInput
  }

  export type SubscriptionUpdateToOneWithWhereWithoutInvoicesInput = {
    where?: SubscriptionWhereInput
    data: XOR<SubscriptionUpdateWithoutInvoicesInput, SubscriptionUncheckedUpdateWithoutInvoicesInput>
  }

  export type SubscriptionUpdateWithoutInvoicesInput = {
    id?: StringFieldUpdateOperationsInput | string
    planName?: StringFieldUpdateOperationsInput | string
    price?: FloatFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutSubscriptionsNestedInput
  }

  export type SubscriptionUncheckedUpdateWithoutInvoicesInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    planName?: StringFieldUpdateOperationsInput | string
    price?: FloatFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProxmoxNodeCreateWithoutServerInput = {
    id?: string
    name: string
    status?: string | null
    maxcpu?: number | null
    maxmem?: bigint | number | null
    cpu?: number | null
    mem?: bigint | number | null
    uptime?: number | null
    raw?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    vms?: ProxmoxVMCreateNestedManyWithoutNodeInput
  }

  export type ProxmoxNodeUncheckedCreateWithoutServerInput = {
    id?: string
    name: string
    status?: string | null
    maxcpu?: number | null
    maxmem?: bigint | number | null
    cpu?: number | null
    mem?: bigint | number | null
    uptime?: number | null
    raw?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    vms?: ProxmoxVMUncheckedCreateNestedManyWithoutNodeInput
  }

  export type ProxmoxNodeCreateOrConnectWithoutServerInput = {
    where: ProxmoxNodeWhereUniqueInput
    create: XOR<ProxmoxNodeCreateWithoutServerInput, ProxmoxNodeUncheckedCreateWithoutServerInput>
  }

  export type ProxmoxNodeCreateManyServerInputEnvelope = {
    data: ProxmoxNodeCreateManyServerInput | ProxmoxNodeCreateManyServerInput[]
  }

  export type ProxmoxVMCreateWithoutServerInput = {
    id?: string
    vmid: number
    name?: string | null
    type?: string | null
    status?: string | null
    maxcpu?: number | null
    maxmem?: bigint | number | null
    cpu?: number | null
    mem?: bigint | number | null
    tags?: string | null
    sshHost?: string | null
    sshPort?: number | null
    sshUser?: string | null
    raw?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    node?: ProxmoxNodeCreateNestedOneWithoutVmsInput
    metrics?: ProxmoxMetricCreateNestedManyWithoutVmInput
  }

  export type ProxmoxVMUncheckedCreateWithoutServerInput = {
    id?: string
    vmid: number
    nodeName: string
    name?: string | null
    type?: string | null
    status?: string | null
    maxcpu?: number | null
    maxmem?: bigint | number | null
    cpu?: number | null
    mem?: bigint | number | null
    tags?: string | null
    sshHost?: string | null
    sshPort?: number | null
    sshUser?: string | null
    raw?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    metrics?: ProxmoxMetricUncheckedCreateNestedManyWithoutVmInput
  }

  export type ProxmoxVMCreateOrConnectWithoutServerInput = {
    where: ProxmoxVMWhereUniqueInput
    create: XOR<ProxmoxVMCreateWithoutServerInput, ProxmoxVMUncheckedCreateWithoutServerInput>
  }

  export type ProxmoxVMCreateManyServerInputEnvelope = {
    data: ProxmoxVMCreateManyServerInput | ProxmoxVMCreateManyServerInput[]
  }

  export type ProxmoxNodeUpsertWithWhereUniqueWithoutServerInput = {
    where: ProxmoxNodeWhereUniqueInput
    update: XOR<ProxmoxNodeUpdateWithoutServerInput, ProxmoxNodeUncheckedUpdateWithoutServerInput>
    create: XOR<ProxmoxNodeCreateWithoutServerInput, ProxmoxNodeUncheckedCreateWithoutServerInput>
  }

  export type ProxmoxNodeUpdateWithWhereUniqueWithoutServerInput = {
    where: ProxmoxNodeWhereUniqueInput
    data: XOR<ProxmoxNodeUpdateWithoutServerInput, ProxmoxNodeUncheckedUpdateWithoutServerInput>
  }

  export type ProxmoxNodeUpdateManyWithWhereWithoutServerInput = {
    where: ProxmoxNodeScalarWhereInput
    data: XOR<ProxmoxNodeUpdateManyMutationInput, ProxmoxNodeUncheckedUpdateManyWithoutServerInput>
  }

  export type ProxmoxNodeScalarWhereInput = {
    AND?: ProxmoxNodeScalarWhereInput | ProxmoxNodeScalarWhereInput[]
    OR?: ProxmoxNodeScalarWhereInput[]
    NOT?: ProxmoxNodeScalarWhereInput | ProxmoxNodeScalarWhereInput[]
    id?: StringFilter<"ProxmoxNode"> | string
    name?: StringFilter<"ProxmoxNode"> | string
    status?: StringNullableFilter<"ProxmoxNode"> | string | null
    maxcpu?: IntNullableFilter<"ProxmoxNode"> | number | null
    maxmem?: BigIntNullableFilter<"ProxmoxNode"> | bigint | number | null
    cpu?: FloatNullableFilter<"ProxmoxNode"> | number | null
    mem?: BigIntNullableFilter<"ProxmoxNode"> | bigint | number | null
    uptime?: IntNullableFilter<"ProxmoxNode"> | number | null
    raw?: StringNullableFilter<"ProxmoxNode"> | string | null
    createdAt?: DateTimeFilter<"ProxmoxNode"> | Date | string
    updatedAt?: DateTimeFilter<"ProxmoxNode"> | Date | string
    serverId?: StringNullableFilter<"ProxmoxNode"> | string | null
  }

  export type ProxmoxVMUpsertWithWhereUniqueWithoutServerInput = {
    where: ProxmoxVMWhereUniqueInput
    update: XOR<ProxmoxVMUpdateWithoutServerInput, ProxmoxVMUncheckedUpdateWithoutServerInput>
    create: XOR<ProxmoxVMCreateWithoutServerInput, ProxmoxVMUncheckedCreateWithoutServerInput>
  }

  export type ProxmoxVMUpdateWithWhereUniqueWithoutServerInput = {
    where: ProxmoxVMWhereUniqueInput
    data: XOR<ProxmoxVMUpdateWithoutServerInput, ProxmoxVMUncheckedUpdateWithoutServerInput>
  }

  export type ProxmoxVMUpdateManyWithWhereWithoutServerInput = {
    where: ProxmoxVMScalarWhereInput
    data: XOR<ProxmoxVMUpdateManyMutationInput, ProxmoxVMUncheckedUpdateManyWithoutServerInput>
  }

  export type ProxmoxVMScalarWhereInput = {
    AND?: ProxmoxVMScalarWhereInput | ProxmoxVMScalarWhereInput[]
    OR?: ProxmoxVMScalarWhereInput[]
    NOT?: ProxmoxVMScalarWhereInput | ProxmoxVMScalarWhereInput[]
    id?: StringFilter<"ProxmoxVM"> | string
    vmid?: IntFilter<"ProxmoxVM"> | number
    nodeName?: StringFilter<"ProxmoxVM"> | string
    serverId?: StringNullableFilter<"ProxmoxVM"> | string | null
    name?: StringNullableFilter<"ProxmoxVM"> | string | null
    type?: StringNullableFilter<"ProxmoxVM"> | string | null
    status?: StringNullableFilter<"ProxmoxVM"> | string | null
    maxcpu?: IntNullableFilter<"ProxmoxVM"> | number | null
    maxmem?: BigIntNullableFilter<"ProxmoxVM"> | bigint | number | null
    cpu?: FloatNullableFilter<"ProxmoxVM"> | number | null
    mem?: BigIntNullableFilter<"ProxmoxVM"> | bigint | number | null
    tags?: StringNullableFilter<"ProxmoxVM"> | string | null
    sshHost?: StringNullableFilter<"ProxmoxVM"> | string | null
    sshPort?: IntNullableFilter<"ProxmoxVM"> | number | null
    sshUser?: StringNullableFilter<"ProxmoxVM"> | string | null
    raw?: StringNullableFilter<"ProxmoxVM"> | string | null
    createdAt?: DateTimeFilter<"ProxmoxVM"> | Date | string
    updatedAt?: DateTimeFilter<"ProxmoxVM"> | Date | string
  }

  export type ProxmoxVMCreateWithoutNodeInput = {
    id?: string
    vmid: number
    name?: string | null
    type?: string | null
    status?: string | null
    maxcpu?: number | null
    maxmem?: bigint | number | null
    cpu?: number | null
    mem?: bigint | number | null
    tags?: string | null
    sshHost?: string | null
    sshPort?: number | null
    sshUser?: string | null
    raw?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    metrics?: ProxmoxMetricCreateNestedManyWithoutVmInput
    server?: ProxmoxServerCreateNestedOneWithoutVmsInput
  }

  export type ProxmoxVMUncheckedCreateWithoutNodeInput = {
    id?: string
    vmid: number
    name?: string | null
    type?: string | null
    status?: string | null
    maxcpu?: number | null
    maxmem?: bigint | number | null
    cpu?: number | null
    mem?: bigint | number | null
    tags?: string | null
    sshHost?: string | null
    sshPort?: number | null
    sshUser?: string | null
    raw?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    metrics?: ProxmoxMetricUncheckedCreateNestedManyWithoutVmInput
  }

  export type ProxmoxVMCreateOrConnectWithoutNodeInput = {
    where: ProxmoxVMWhereUniqueInput
    create: XOR<ProxmoxVMCreateWithoutNodeInput, ProxmoxVMUncheckedCreateWithoutNodeInput>
  }

  export type ProxmoxVMCreateManyNodeInputEnvelope = {
    data: ProxmoxVMCreateManyNodeInput | ProxmoxVMCreateManyNodeInput[]
  }

  export type ProxmoxServerCreateWithoutNodesInput = {
    id?: string
    name: string
    baseUrl: string
    user: string
    tokenId: string
    tokenSecret: string
    insecure?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    vms?: ProxmoxVMCreateNestedManyWithoutServerInput
  }

  export type ProxmoxServerUncheckedCreateWithoutNodesInput = {
    id?: string
    name: string
    baseUrl: string
    user: string
    tokenId: string
    tokenSecret: string
    insecure?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    vms?: ProxmoxVMUncheckedCreateNestedManyWithoutServerInput
  }

  export type ProxmoxServerCreateOrConnectWithoutNodesInput = {
    where: ProxmoxServerWhereUniqueInput
    create: XOR<ProxmoxServerCreateWithoutNodesInput, ProxmoxServerUncheckedCreateWithoutNodesInput>
  }

  export type ProxmoxVMUpsertWithWhereUniqueWithoutNodeInput = {
    where: ProxmoxVMWhereUniqueInput
    update: XOR<ProxmoxVMUpdateWithoutNodeInput, ProxmoxVMUncheckedUpdateWithoutNodeInput>
    create: XOR<ProxmoxVMCreateWithoutNodeInput, ProxmoxVMUncheckedCreateWithoutNodeInput>
  }

  export type ProxmoxVMUpdateWithWhereUniqueWithoutNodeInput = {
    where: ProxmoxVMWhereUniqueInput
    data: XOR<ProxmoxVMUpdateWithoutNodeInput, ProxmoxVMUncheckedUpdateWithoutNodeInput>
  }

  export type ProxmoxVMUpdateManyWithWhereWithoutNodeInput = {
    where: ProxmoxVMScalarWhereInput
    data: XOR<ProxmoxVMUpdateManyMutationInput, ProxmoxVMUncheckedUpdateManyWithoutNodeInput>
  }

  export type ProxmoxServerUpsertWithoutNodesInput = {
    update: XOR<ProxmoxServerUpdateWithoutNodesInput, ProxmoxServerUncheckedUpdateWithoutNodesInput>
    create: XOR<ProxmoxServerCreateWithoutNodesInput, ProxmoxServerUncheckedCreateWithoutNodesInput>
    where?: ProxmoxServerWhereInput
  }

  export type ProxmoxServerUpdateToOneWithWhereWithoutNodesInput = {
    where?: ProxmoxServerWhereInput
    data: XOR<ProxmoxServerUpdateWithoutNodesInput, ProxmoxServerUncheckedUpdateWithoutNodesInput>
  }

  export type ProxmoxServerUpdateWithoutNodesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    baseUrl?: StringFieldUpdateOperationsInput | string
    user?: StringFieldUpdateOperationsInput | string
    tokenId?: StringFieldUpdateOperationsInput | string
    tokenSecret?: StringFieldUpdateOperationsInput | string
    insecure?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    vms?: ProxmoxVMUpdateManyWithoutServerNestedInput
  }

  export type ProxmoxServerUncheckedUpdateWithoutNodesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    baseUrl?: StringFieldUpdateOperationsInput | string
    user?: StringFieldUpdateOperationsInput | string
    tokenId?: StringFieldUpdateOperationsInput | string
    tokenSecret?: StringFieldUpdateOperationsInput | string
    insecure?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    vms?: ProxmoxVMUncheckedUpdateManyWithoutServerNestedInput
  }

  export type ProxmoxNodeCreateWithoutVmsInput = {
    id?: string
    name: string
    status?: string | null
    maxcpu?: number | null
    maxmem?: bigint | number | null
    cpu?: number | null
    mem?: bigint | number | null
    uptime?: number | null
    raw?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    server?: ProxmoxServerCreateNestedOneWithoutNodesInput
  }

  export type ProxmoxNodeUncheckedCreateWithoutVmsInput = {
    id?: string
    name: string
    status?: string | null
    maxcpu?: number | null
    maxmem?: bigint | number | null
    cpu?: number | null
    mem?: bigint | number | null
    uptime?: number | null
    raw?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    serverId?: string | null
  }

  export type ProxmoxNodeCreateOrConnectWithoutVmsInput = {
    where: ProxmoxNodeWhereUniqueInput
    create: XOR<ProxmoxNodeCreateWithoutVmsInput, ProxmoxNodeUncheckedCreateWithoutVmsInput>
  }

  export type ProxmoxMetricCreateWithoutVmInput = {
    id?: string
    vmNumericId?: number | null
    nodeName?: string | null
    serverId?: string | null
    cpu?: number | null
    mem?: bigint | number | null
    disk?: number | null
    netin?: bigint | number | null
    netout?: bigint | number | null
    ts?: Date | string
  }

  export type ProxmoxMetricUncheckedCreateWithoutVmInput = {
    id?: string
    vmNumericId?: number | null
    nodeName?: string | null
    serverId?: string | null
    cpu?: number | null
    mem?: bigint | number | null
    disk?: number | null
    netin?: bigint | number | null
    netout?: bigint | number | null
    ts?: Date | string
  }

  export type ProxmoxMetricCreateOrConnectWithoutVmInput = {
    where: ProxmoxMetricWhereUniqueInput
    create: XOR<ProxmoxMetricCreateWithoutVmInput, ProxmoxMetricUncheckedCreateWithoutVmInput>
  }

  export type ProxmoxMetricCreateManyVmInputEnvelope = {
    data: ProxmoxMetricCreateManyVmInput | ProxmoxMetricCreateManyVmInput[]
  }

  export type ProxmoxServerCreateWithoutVmsInput = {
    id?: string
    name: string
    baseUrl: string
    user: string
    tokenId: string
    tokenSecret: string
    insecure?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    nodes?: ProxmoxNodeCreateNestedManyWithoutServerInput
  }

  export type ProxmoxServerUncheckedCreateWithoutVmsInput = {
    id?: string
    name: string
    baseUrl: string
    user: string
    tokenId: string
    tokenSecret: string
    insecure?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    nodes?: ProxmoxNodeUncheckedCreateNestedManyWithoutServerInput
  }

  export type ProxmoxServerCreateOrConnectWithoutVmsInput = {
    where: ProxmoxServerWhereUniqueInput
    create: XOR<ProxmoxServerCreateWithoutVmsInput, ProxmoxServerUncheckedCreateWithoutVmsInput>
  }

  export type ProxmoxNodeUpsertWithoutVmsInput = {
    update: XOR<ProxmoxNodeUpdateWithoutVmsInput, ProxmoxNodeUncheckedUpdateWithoutVmsInput>
    create: XOR<ProxmoxNodeCreateWithoutVmsInput, ProxmoxNodeUncheckedCreateWithoutVmsInput>
    where?: ProxmoxNodeWhereInput
  }

  export type ProxmoxNodeUpdateToOneWithWhereWithoutVmsInput = {
    where?: ProxmoxNodeWhereInput
    data: XOR<ProxmoxNodeUpdateWithoutVmsInput, ProxmoxNodeUncheckedUpdateWithoutVmsInput>
  }

  export type ProxmoxNodeUpdateWithoutVmsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    status?: NullableStringFieldUpdateOperationsInput | string | null
    maxcpu?: NullableIntFieldUpdateOperationsInput | number | null
    maxmem?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    cpu?: NullableFloatFieldUpdateOperationsInput | number | null
    mem?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    uptime?: NullableIntFieldUpdateOperationsInput | number | null
    raw?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    server?: ProxmoxServerUpdateOneWithoutNodesNestedInput
  }

  export type ProxmoxNodeUncheckedUpdateWithoutVmsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    status?: NullableStringFieldUpdateOperationsInput | string | null
    maxcpu?: NullableIntFieldUpdateOperationsInput | number | null
    maxmem?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    cpu?: NullableFloatFieldUpdateOperationsInput | number | null
    mem?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    uptime?: NullableIntFieldUpdateOperationsInput | number | null
    raw?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    serverId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type ProxmoxMetricUpsertWithWhereUniqueWithoutVmInput = {
    where: ProxmoxMetricWhereUniqueInput
    update: XOR<ProxmoxMetricUpdateWithoutVmInput, ProxmoxMetricUncheckedUpdateWithoutVmInput>
    create: XOR<ProxmoxMetricCreateWithoutVmInput, ProxmoxMetricUncheckedCreateWithoutVmInput>
  }

  export type ProxmoxMetricUpdateWithWhereUniqueWithoutVmInput = {
    where: ProxmoxMetricWhereUniqueInput
    data: XOR<ProxmoxMetricUpdateWithoutVmInput, ProxmoxMetricUncheckedUpdateWithoutVmInput>
  }

  export type ProxmoxMetricUpdateManyWithWhereWithoutVmInput = {
    where: ProxmoxMetricScalarWhereInput
    data: XOR<ProxmoxMetricUpdateManyMutationInput, ProxmoxMetricUncheckedUpdateManyWithoutVmInput>
  }

  export type ProxmoxMetricScalarWhereInput = {
    AND?: ProxmoxMetricScalarWhereInput | ProxmoxMetricScalarWhereInput[]
    OR?: ProxmoxMetricScalarWhereInput[]
    NOT?: ProxmoxMetricScalarWhereInput | ProxmoxMetricScalarWhereInput[]
    id?: StringFilter<"ProxmoxMetric"> | string
    vmId?: StringNullableFilter<"ProxmoxMetric"> | string | null
    vmNumericId?: IntNullableFilter<"ProxmoxMetric"> | number | null
    nodeName?: StringNullableFilter<"ProxmoxMetric"> | string | null
    serverId?: StringNullableFilter<"ProxmoxMetric"> | string | null
    cpu?: FloatNullableFilter<"ProxmoxMetric"> | number | null
    mem?: BigIntNullableFilter<"ProxmoxMetric"> | bigint | number | null
    disk?: FloatNullableFilter<"ProxmoxMetric"> | number | null
    netin?: BigIntNullableFilter<"ProxmoxMetric"> | bigint | number | null
    netout?: BigIntNullableFilter<"ProxmoxMetric"> | bigint | number | null
    ts?: DateTimeFilter<"ProxmoxMetric"> | Date | string
  }

  export type ProxmoxServerUpsertWithoutVmsInput = {
    update: XOR<ProxmoxServerUpdateWithoutVmsInput, ProxmoxServerUncheckedUpdateWithoutVmsInput>
    create: XOR<ProxmoxServerCreateWithoutVmsInput, ProxmoxServerUncheckedCreateWithoutVmsInput>
    where?: ProxmoxServerWhereInput
  }

  export type ProxmoxServerUpdateToOneWithWhereWithoutVmsInput = {
    where?: ProxmoxServerWhereInput
    data: XOR<ProxmoxServerUpdateWithoutVmsInput, ProxmoxServerUncheckedUpdateWithoutVmsInput>
  }

  export type ProxmoxServerUpdateWithoutVmsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    baseUrl?: StringFieldUpdateOperationsInput | string
    user?: StringFieldUpdateOperationsInput | string
    tokenId?: StringFieldUpdateOperationsInput | string
    tokenSecret?: StringFieldUpdateOperationsInput | string
    insecure?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    nodes?: ProxmoxNodeUpdateManyWithoutServerNestedInput
  }

  export type ProxmoxServerUncheckedUpdateWithoutVmsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    baseUrl?: StringFieldUpdateOperationsInput | string
    user?: StringFieldUpdateOperationsInput | string
    tokenId?: StringFieldUpdateOperationsInput | string
    tokenSecret?: StringFieldUpdateOperationsInput | string
    insecure?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    nodes?: ProxmoxNodeUncheckedUpdateManyWithoutServerNestedInput
  }

  export type ProxmoxVMCreateWithoutMetricsInput = {
    id?: string
    vmid: number
    name?: string | null
    type?: string | null
    status?: string | null
    maxcpu?: number | null
    maxmem?: bigint | number | null
    cpu?: number | null
    mem?: bigint | number | null
    tags?: string | null
    sshHost?: string | null
    sshPort?: number | null
    sshUser?: string | null
    raw?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    node?: ProxmoxNodeCreateNestedOneWithoutVmsInput
    server?: ProxmoxServerCreateNestedOneWithoutVmsInput
  }

  export type ProxmoxVMUncheckedCreateWithoutMetricsInput = {
    id?: string
    vmid: number
    nodeName: string
    serverId?: string | null
    name?: string | null
    type?: string | null
    status?: string | null
    maxcpu?: number | null
    maxmem?: bigint | number | null
    cpu?: number | null
    mem?: bigint | number | null
    tags?: string | null
    sshHost?: string | null
    sshPort?: number | null
    sshUser?: string | null
    raw?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ProxmoxVMCreateOrConnectWithoutMetricsInput = {
    where: ProxmoxVMWhereUniqueInput
    create: XOR<ProxmoxVMCreateWithoutMetricsInput, ProxmoxVMUncheckedCreateWithoutMetricsInput>
  }

  export type ProxmoxVMUpsertWithoutMetricsInput = {
    update: XOR<ProxmoxVMUpdateWithoutMetricsInput, ProxmoxVMUncheckedUpdateWithoutMetricsInput>
    create: XOR<ProxmoxVMCreateWithoutMetricsInput, ProxmoxVMUncheckedCreateWithoutMetricsInput>
    where?: ProxmoxVMWhereInput
  }

  export type ProxmoxVMUpdateToOneWithWhereWithoutMetricsInput = {
    where?: ProxmoxVMWhereInput
    data: XOR<ProxmoxVMUpdateWithoutMetricsInput, ProxmoxVMUncheckedUpdateWithoutMetricsInput>
  }

  export type ProxmoxVMUpdateWithoutMetricsInput = {
    id?: StringFieldUpdateOperationsInput | string
    vmid?: IntFieldUpdateOperationsInput | number
    name?: NullableStringFieldUpdateOperationsInput | string | null
    type?: NullableStringFieldUpdateOperationsInput | string | null
    status?: NullableStringFieldUpdateOperationsInput | string | null
    maxcpu?: NullableIntFieldUpdateOperationsInput | number | null
    maxmem?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    cpu?: NullableFloatFieldUpdateOperationsInput | number | null
    mem?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    tags?: NullableStringFieldUpdateOperationsInput | string | null
    sshHost?: NullableStringFieldUpdateOperationsInput | string | null
    sshPort?: NullableIntFieldUpdateOperationsInput | number | null
    sshUser?: NullableStringFieldUpdateOperationsInput | string | null
    raw?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    node?: ProxmoxNodeUpdateOneWithoutVmsNestedInput
    server?: ProxmoxServerUpdateOneWithoutVmsNestedInput
  }

  export type ProxmoxVMUncheckedUpdateWithoutMetricsInput = {
    id?: StringFieldUpdateOperationsInput | string
    vmid?: IntFieldUpdateOperationsInput | number
    nodeName?: StringFieldUpdateOperationsInput | string
    serverId?: NullableStringFieldUpdateOperationsInput | string | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    type?: NullableStringFieldUpdateOperationsInput | string | null
    status?: NullableStringFieldUpdateOperationsInput | string | null
    maxcpu?: NullableIntFieldUpdateOperationsInput | number | null
    maxmem?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    cpu?: NullableFloatFieldUpdateOperationsInput | number | null
    mem?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    tags?: NullableStringFieldUpdateOperationsInput | string | null
    sshHost?: NullableStringFieldUpdateOperationsInput | string | null
    sshPort?: NullableIntFieldUpdateOperationsInput | number | null
    sshUser?: NullableStringFieldUpdateOperationsInput | string | null
    raw?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NetworkSubnetCreateWithoutSiteInput = {
    id?: string
    cidr: string
    name?: string | null
    description?: string | null
    gatewayIpId?: string | null
    tags?: string | null
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    vlan?: VlanCreateNestedOneWithoutSubnetsInput
    parent?: NetworkSubnetCreateNestedOneWithoutChildrenInput
    children?: NetworkSubnetCreateNestedManyWithoutParentInput
    ips?: NetworkIPCreateNestedManyWithoutSubnetInput
  }

  export type NetworkSubnetUncheckedCreateWithoutSiteInput = {
    id?: string
    cidr: string
    name?: string | null
    description?: string | null
    vlanId?: string | null
    parentId?: string | null
    gatewayIpId?: string | null
    tags?: string | null
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    children?: NetworkSubnetUncheckedCreateNestedManyWithoutParentInput
    ips?: NetworkIPUncheckedCreateNestedManyWithoutSubnetInput
  }

  export type NetworkSubnetCreateOrConnectWithoutSiteInput = {
    where: NetworkSubnetWhereUniqueInput
    create: XOR<NetworkSubnetCreateWithoutSiteInput, NetworkSubnetUncheckedCreateWithoutSiteInput>
  }

  export type NetworkSubnetCreateManySiteInputEnvelope = {
    data: NetworkSubnetCreateManySiteInput | NetworkSubnetCreateManySiteInput[]
  }

  export type NetworkDeviceCreateWithoutSiteInput = {
    id?: string
    name: string
    type?: $Enums.DeviceType
    mgmtIp?: string | null
    vendor?: string | null
    model?: string | null
    serial?: string | null
    osVersion?: string | null
    tags?: string | null
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    services?: NetworkServiceCreateNestedManyWithoutDeviceInput
    ips?: NetworkIPCreateNestedManyWithoutDeviceInput
  }

  export type NetworkDeviceUncheckedCreateWithoutSiteInput = {
    id?: string
    name: string
    type?: $Enums.DeviceType
    mgmtIp?: string | null
    vendor?: string | null
    model?: string | null
    serial?: string | null
    osVersion?: string | null
    tags?: string | null
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    services?: NetworkServiceUncheckedCreateNestedManyWithoutDeviceInput
    ips?: NetworkIPUncheckedCreateNestedManyWithoutDeviceInput
  }

  export type NetworkDeviceCreateOrConnectWithoutSiteInput = {
    where: NetworkDeviceWhereUniqueInput
    create: XOR<NetworkDeviceCreateWithoutSiteInput, NetworkDeviceUncheckedCreateWithoutSiteInput>
  }

  export type NetworkDeviceCreateManySiteInputEnvelope = {
    data: NetworkDeviceCreateManySiteInput | NetworkDeviceCreateManySiteInput[]
  }

  export type VlanCreateWithoutSiteInput = {
    id?: string
    name: string
    vid: number
    description?: string | null
    tags?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    subnets?: NetworkSubnetCreateNestedManyWithoutVlanInput
  }

  export type VlanUncheckedCreateWithoutSiteInput = {
    id?: string
    name: string
    vid: number
    description?: string | null
    tags?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    subnets?: NetworkSubnetUncheckedCreateNestedManyWithoutVlanInput
  }

  export type VlanCreateOrConnectWithoutSiteInput = {
    where: VlanWhereUniqueInput
    create: XOR<VlanCreateWithoutSiteInput, VlanUncheckedCreateWithoutSiteInput>
  }

  export type VlanCreateManySiteInputEnvelope = {
    data: VlanCreateManySiteInput | VlanCreateManySiteInput[]
  }

  export type NetworkSubnetUpsertWithWhereUniqueWithoutSiteInput = {
    where: NetworkSubnetWhereUniqueInput
    update: XOR<NetworkSubnetUpdateWithoutSiteInput, NetworkSubnetUncheckedUpdateWithoutSiteInput>
    create: XOR<NetworkSubnetCreateWithoutSiteInput, NetworkSubnetUncheckedCreateWithoutSiteInput>
  }

  export type NetworkSubnetUpdateWithWhereUniqueWithoutSiteInput = {
    where: NetworkSubnetWhereUniqueInput
    data: XOR<NetworkSubnetUpdateWithoutSiteInput, NetworkSubnetUncheckedUpdateWithoutSiteInput>
  }

  export type NetworkSubnetUpdateManyWithWhereWithoutSiteInput = {
    where: NetworkSubnetScalarWhereInput
    data: XOR<NetworkSubnetUpdateManyMutationInput, NetworkSubnetUncheckedUpdateManyWithoutSiteInput>
  }

  export type NetworkSubnetScalarWhereInput = {
    AND?: NetworkSubnetScalarWhereInput | NetworkSubnetScalarWhereInput[]
    OR?: NetworkSubnetScalarWhereInput[]
    NOT?: NetworkSubnetScalarWhereInput | NetworkSubnetScalarWhereInput[]
    id?: StringFilter<"NetworkSubnet"> | string
    cidr?: StringFilter<"NetworkSubnet"> | string
    name?: StringNullableFilter<"NetworkSubnet"> | string | null
    description?: StringNullableFilter<"NetworkSubnet"> | string | null
    siteId?: StringNullableFilter<"NetworkSubnet"> | string | null
    vlanId?: StringNullableFilter<"NetworkSubnet"> | string | null
    parentId?: StringNullableFilter<"NetworkSubnet"> | string | null
    gatewayIpId?: StringNullableFilter<"NetworkSubnet"> | string | null
    tags?: StringNullableFilter<"NetworkSubnet"> | string | null
    notes?: StringNullableFilter<"NetworkSubnet"> | string | null
    createdAt?: DateTimeFilter<"NetworkSubnet"> | Date | string
    updatedAt?: DateTimeFilter<"NetworkSubnet"> | Date | string
  }

  export type NetworkDeviceUpsertWithWhereUniqueWithoutSiteInput = {
    where: NetworkDeviceWhereUniqueInput
    update: XOR<NetworkDeviceUpdateWithoutSiteInput, NetworkDeviceUncheckedUpdateWithoutSiteInput>
    create: XOR<NetworkDeviceCreateWithoutSiteInput, NetworkDeviceUncheckedCreateWithoutSiteInput>
  }

  export type NetworkDeviceUpdateWithWhereUniqueWithoutSiteInput = {
    where: NetworkDeviceWhereUniqueInput
    data: XOR<NetworkDeviceUpdateWithoutSiteInput, NetworkDeviceUncheckedUpdateWithoutSiteInput>
  }

  export type NetworkDeviceUpdateManyWithWhereWithoutSiteInput = {
    where: NetworkDeviceScalarWhereInput
    data: XOR<NetworkDeviceUpdateManyMutationInput, NetworkDeviceUncheckedUpdateManyWithoutSiteInput>
  }

  export type NetworkDeviceScalarWhereInput = {
    AND?: NetworkDeviceScalarWhereInput | NetworkDeviceScalarWhereInput[]
    OR?: NetworkDeviceScalarWhereInput[]
    NOT?: NetworkDeviceScalarWhereInput | NetworkDeviceScalarWhereInput[]
    id?: StringFilter<"NetworkDevice"> | string
    name?: StringFilter<"NetworkDevice"> | string
    type?: EnumDeviceTypeFilter<"NetworkDevice"> | $Enums.DeviceType
    siteId?: StringNullableFilter<"NetworkDevice"> | string | null
    mgmtIp?: StringNullableFilter<"NetworkDevice"> | string | null
    vendor?: StringNullableFilter<"NetworkDevice"> | string | null
    model?: StringNullableFilter<"NetworkDevice"> | string | null
    serial?: StringNullableFilter<"NetworkDevice"> | string | null
    osVersion?: StringNullableFilter<"NetworkDevice"> | string | null
    tags?: StringNullableFilter<"NetworkDevice"> | string | null
    notes?: StringNullableFilter<"NetworkDevice"> | string | null
    createdAt?: DateTimeFilter<"NetworkDevice"> | Date | string
    updatedAt?: DateTimeFilter<"NetworkDevice"> | Date | string
  }

  export type VlanUpsertWithWhereUniqueWithoutSiteInput = {
    where: VlanWhereUniqueInput
    update: XOR<VlanUpdateWithoutSiteInput, VlanUncheckedUpdateWithoutSiteInput>
    create: XOR<VlanCreateWithoutSiteInput, VlanUncheckedCreateWithoutSiteInput>
  }

  export type VlanUpdateWithWhereUniqueWithoutSiteInput = {
    where: VlanWhereUniqueInput
    data: XOR<VlanUpdateWithoutSiteInput, VlanUncheckedUpdateWithoutSiteInput>
  }

  export type VlanUpdateManyWithWhereWithoutSiteInput = {
    where: VlanScalarWhereInput
    data: XOR<VlanUpdateManyMutationInput, VlanUncheckedUpdateManyWithoutSiteInput>
  }

  export type VlanScalarWhereInput = {
    AND?: VlanScalarWhereInput | VlanScalarWhereInput[]
    OR?: VlanScalarWhereInput[]
    NOT?: VlanScalarWhereInput | VlanScalarWhereInput[]
    id?: StringFilter<"Vlan"> | string
    name?: StringFilter<"Vlan"> | string
    vid?: IntFilter<"Vlan"> | number
    siteId?: StringNullableFilter<"Vlan"> | string | null
    description?: StringNullableFilter<"Vlan"> | string | null
    tags?: StringNullableFilter<"Vlan"> | string | null
    createdAt?: DateTimeFilter<"Vlan"> | Date | string
    updatedAt?: DateTimeFilter<"Vlan"> | Date | string
  }

  export type SiteCreateWithoutVlansInput = {
    id?: string
    name: string
    address?: string | null
    notes?: string | null
    tags?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    subnets?: NetworkSubnetCreateNestedManyWithoutSiteInput
    devices?: NetworkDeviceCreateNestedManyWithoutSiteInput
  }

  export type SiteUncheckedCreateWithoutVlansInput = {
    id?: string
    name: string
    address?: string | null
    notes?: string | null
    tags?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    subnets?: NetworkSubnetUncheckedCreateNestedManyWithoutSiteInput
    devices?: NetworkDeviceUncheckedCreateNestedManyWithoutSiteInput
  }

  export type SiteCreateOrConnectWithoutVlansInput = {
    where: SiteWhereUniqueInput
    create: XOR<SiteCreateWithoutVlansInput, SiteUncheckedCreateWithoutVlansInput>
  }

  export type NetworkSubnetCreateWithoutVlanInput = {
    id?: string
    cidr: string
    name?: string | null
    description?: string | null
    gatewayIpId?: string | null
    tags?: string | null
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    site?: SiteCreateNestedOneWithoutSubnetsInput
    parent?: NetworkSubnetCreateNestedOneWithoutChildrenInput
    children?: NetworkSubnetCreateNestedManyWithoutParentInput
    ips?: NetworkIPCreateNestedManyWithoutSubnetInput
  }

  export type NetworkSubnetUncheckedCreateWithoutVlanInput = {
    id?: string
    cidr: string
    name?: string | null
    description?: string | null
    siteId?: string | null
    parentId?: string | null
    gatewayIpId?: string | null
    tags?: string | null
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    children?: NetworkSubnetUncheckedCreateNestedManyWithoutParentInput
    ips?: NetworkIPUncheckedCreateNestedManyWithoutSubnetInput
  }

  export type NetworkSubnetCreateOrConnectWithoutVlanInput = {
    where: NetworkSubnetWhereUniqueInput
    create: XOR<NetworkSubnetCreateWithoutVlanInput, NetworkSubnetUncheckedCreateWithoutVlanInput>
  }

  export type NetworkSubnetCreateManyVlanInputEnvelope = {
    data: NetworkSubnetCreateManyVlanInput | NetworkSubnetCreateManyVlanInput[]
  }

  export type SiteUpsertWithoutVlansInput = {
    update: XOR<SiteUpdateWithoutVlansInput, SiteUncheckedUpdateWithoutVlansInput>
    create: XOR<SiteCreateWithoutVlansInput, SiteUncheckedCreateWithoutVlansInput>
    where?: SiteWhereInput
  }

  export type SiteUpdateToOneWithWhereWithoutVlansInput = {
    where?: SiteWhereInput
    data: XOR<SiteUpdateWithoutVlansInput, SiteUncheckedUpdateWithoutVlansInput>
  }

  export type SiteUpdateWithoutVlansInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    address?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    tags?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    subnets?: NetworkSubnetUpdateManyWithoutSiteNestedInput
    devices?: NetworkDeviceUpdateManyWithoutSiteNestedInput
  }

  export type SiteUncheckedUpdateWithoutVlansInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    address?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    tags?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    subnets?: NetworkSubnetUncheckedUpdateManyWithoutSiteNestedInput
    devices?: NetworkDeviceUncheckedUpdateManyWithoutSiteNestedInput
  }

  export type NetworkSubnetUpsertWithWhereUniqueWithoutVlanInput = {
    where: NetworkSubnetWhereUniqueInput
    update: XOR<NetworkSubnetUpdateWithoutVlanInput, NetworkSubnetUncheckedUpdateWithoutVlanInput>
    create: XOR<NetworkSubnetCreateWithoutVlanInput, NetworkSubnetUncheckedCreateWithoutVlanInput>
  }

  export type NetworkSubnetUpdateWithWhereUniqueWithoutVlanInput = {
    where: NetworkSubnetWhereUniqueInput
    data: XOR<NetworkSubnetUpdateWithoutVlanInput, NetworkSubnetUncheckedUpdateWithoutVlanInput>
  }

  export type NetworkSubnetUpdateManyWithWhereWithoutVlanInput = {
    where: NetworkSubnetScalarWhereInput
    data: XOR<NetworkSubnetUpdateManyMutationInput, NetworkSubnetUncheckedUpdateManyWithoutVlanInput>
  }

  export type SiteCreateWithoutSubnetsInput = {
    id?: string
    name: string
    address?: string | null
    notes?: string | null
    tags?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    devices?: NetworkDeviceCreateNestedManyWithoutSiteInput
    vlans?: VlanCreateNestedManyWithoutSiteInput
  }

  export type SiteUncheckedCreateWithoutSubnetsInput = {
    id?: string
    name: string
    address?: string | null
    notes?: string | null
    tags?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    devices?: NetworkDeviceUncheckedCreateNestedManyWithoutSiteInput
    vlans?: VlanUncheckedCreateNestedManyWithoutSiteInput
  }

  export type SiteCreateOrConnectWithoutSubnetsInput = {
    where: SiteWhereUniqueInput
    create: XOR<SiteCreateWithoutSubnetsInput, SiteUncheckedCreateWithoutSubnetsInput>
  }

  export type VlanCreateWithoutSubnetsInput = {
    id?: string
    name: string
    vid: number
    description?: string | null
    tags?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    site?: SiteCreateNestedOneWithoutVlansInput
  }

  export type VlanUncheckedCreateWithoutSubnetsInput = {
    id?: string
    name: string
    vid: number
    siteId?: string | null
    description?: string | null
    tags?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type VlanCreateOrConnectWithoutSubnetsInput = {
    where: VlanWhereUniqueInput
    create: XOR<VlanCreateWithoutSubnetsInput, VlanUncheckedCreateWithoutSubnetsInput>
  }

  export type NetworkSubnetCreateWithoutChildrenInput = {
    id?: string
    cidr: string
    name?: string | null
    description?: string | null
    gatewayIpId?: string | null
    tags?: string | null
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    site?: SiteCreateNestedOneWithoutSubnetsInput
    vlan?: VlanCreateNestedOneWithoutSubnetsInput
    parent?: NetworkSubnetCreateNestedOneWithoutChildrenInput
    ips?: NetworkIPCreateNestedManyWithoutSubnetInput
  }

  export type NetworkSubnetUncheckedCreateWithoutChildrenInput = {
    id?: string
    cidr: string
    name?: string | null
    description?: string | null
    siteId?: string | null
    vlanId?: string | null
    parentId?: string | null
    gatewayIpId?: string | null
    tags?: string | null
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    ips?: NetworkIPUncheckedCreateNestedManyWithoutSubnetInput
  }

  export type NetworkSubnetCreateOrConnectWithoutChildrenInput = {
    where: NetworkSubnetWhereUniqueInput
    create: XOR<NetworkSubnetCreateWithoutChildrenInput, NetworkSubnetUncheckedCreateWithoutChildrenInput>
  }

  export type NetworkSubnetCreateWithoutParentInput = {
    id?: string
    cidr: string
    name?: string | null
    description?: string | null
    gatewayIpId?: string | null
    tags?: string | null
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    site?: SiteCreateNestedOneWithoutSubnetsInput
    vlan?: VlanCreateNestedOneWithoutSubnetsInput
    children?: NetworkSubnetCreateNestedManyWithoutParentInput
    ips?: NetworkIPCreateNestedManyWithoutSubnetInput
  }

  export type NetworkSubnetUncheckedCreateWithoutParentInput = {
    id?: string
    cidr: string
    name?: string | null
    description?: string | null
    siteId?: string | null
    vlanId?: string | null
    gatewayIpId?: string | null
    tags?: string | null
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    children?: NetworkSubnetUncheckedCreateNestedManyWithoutParentInput
    ips?: NetworkIPUncheckedCreateNestedManyWithoutSubnetInput
  }

  export type NetworkSubnetCreateOrConnectWithoutParentInput = {
    where: NetworkSubnetWhereUniqueInput
    create: XOR<NetworkSubnetCreateWithoutParentInput, NetworkSubnetUncheckedCreateWithoutParentInput>
  }

  export type NetworkSubnetCreateManyParentInputEnvelope = {
    data: NetworkSubnetCreateManyParentInput | NetworkSubnetCreateManyParentInput[]
  }

  export type NetworkIPCreateWithoutSubnetInput = {
    id?: string
    address: string
    status?: $Enums.IPStatus
    interface?: string | null
    fqdn?: string | null
    purpose?: string | null
    mac?: string | null
    tags?: string | null
    notes?: string | null
    lastSeen?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    device?: NetworkDeviceCreateNestedOneWithoutIpsInput
  }

  export type NetworkIPUncheckedCreateWithoutSubnetInput = {
    id?: string
    address: string
    status?: $Enums.IPStatus
    deviceId?: string | null
    interface?: string | null
    fqdn?: string | null
    purpose?: string | null
    mac?: string | null
    tags?: string | null
    notes?: string | null
    lastSeen?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type NetworkIPCreateOrConnectWithoutSubnetInput = {
    where: NetworkIPWhereUniqueInput
    create: XOR<NetworkIPCreateWithoutSubnetInput, NetworkIPUncheckedCreateWithoutSubnetInput>
  }

  export type NetworkIPCreateManySubnetInputEnvelope = {
    data: NetworkIPCreateManySubnetInput | NetworkIPCreateManySubnetInput[]
  }

  export type SiteUpsertWithoutSubnetsInput = {
    update: XOR<SiteUpdateWithoutSubnetsInput, SiteUncheckedUpdateWithoutSubnetsInput>
    create: XOR<SiteCreateWithoutSubnetsInput, SiteUncheckedCreateWithoutSubnetsInput>
    where?: SiteWhereInput
  }

  export type SiteUpdateToOneWithWhereWithoutSubnetsInput = {
    where?: SiteWhereInput
    data: XOR<SiteUpdateWithoutSubnetsInput, SiteUncheckedUpdateWithoutSubnetsInput>
  }

  export type SiteUpdateWithoutSubnetsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    address?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    tags?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    devices?: NetworkDeviceUpdateManyWithoutSiteNestedInput
    vlans?: VlanUpdateManyWithoutSiteNestedInput
  }

  export type SiteUncheckedUpdateWithoutSubnetsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    address?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    tags?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    devices?: NetworkDeviceUncheckedUpdateManyWithoutSiteNestedInput
    vlans?: VlanUncheckedUpdateManyWithoutSiteNestedInput
  }

  export type VlanUpsertWithoutSubnetsInput = {
    update: XOR<VlanUpdateWithoutSubnetsInput, VlanUncheckedUpdateWithoutSubnetsInput>
    create: XOR<VlanCreateWithoutSubnetsInput, VlanUncheckedCreateWithoutSubnetsInput>
    where?: VlanWhereInput
  }

  export type VlanUpdateToOneWithWhereWithoutSubnetsInput = {
    where?: VlanWhereInput
    data: XOR<VlanUpdateWithoutSubnetsInput, VlanUncheckedUpdateWithoutSubnetsInput>
  }

  export type VlanUpdateWithoutSubnetsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    vid?: IntFieldUpdateOperationsInput | number
    description?: NullableStringFieldUpdateOperationsInput | string | null
    tags?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    site?: SiteUpdateOneWithoutVlansNestedInput
  }

  export type VlanUncheckedUpdateWithoutSubnetsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    vid?: IntFieldUpdateOperationsInput | number
    siteId?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    tags?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NetworkSubnetUpsertWithoutChildrenInput = {
    update: XOR<NetworkSubnetUpdateWithoutChildrenInput, NetworkSubnetUncheckedUpdateWithoutChildrenInput>
    create: XOR<NetworkSubnetCreateWithoutChildrenInput, NetworkSubnetUncheckedCreateWithoutChildrenInput>
    where?: NetworkSubnetWhereInput
  }

  export type NetworkSubnetUpdateToOneWithWhereWithoutChildrenInput = {
    where?: NetworkSubnetWhereInput
    data: XOR<NetworkSubnetUpdateWithoutChildrenInput, NetworkSubnetUncheckedUpdateWithoutChildrenInput>
  }

  export type NetworkSubnetUpdateWithoutChildrenInput = {
    id?: StringFieldUpdateOperationsInput | string
    cidr?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    gatewayIpId?: NullableStringFieldUpdateOperationsInput | string | null
    tags?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    site?: SiteUpdateOneWithoutSubnetsNestedInput
    vlan?: VlanUpdateOneWithoutSubnetsNestedInput
    parent?: NetworkSubnetUpdateOneWithoutChildrenNestedInput
    ips?: NetworkIPUpdateManyWithoutSubnetNestedInput
  }

  export type NetworkSubnetUncheckedUpdateWithoutChildrenInput = {
    id?: StringFieldUpdateOperationsInput | string
    cidr?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    siteId?: NullableStringFieldUpdateOperationsInput | string | null
    vlanId?: NullableStringFieldUpdateOperationsInput | string | null
    parentId?: NullableStringFieldUpdateOperationsInput | string | null
    gatewayIpId?: NullableStringFieldUpdateOperationsInput | string | null
    tags?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    ips?: NetworkIPUncheckedUpdateManyWithoutSubnetNestedInput
  }

  export type NetworkSubnetUpsertWithWhereUniqueWithoutParentInput = {
    where: NetworkSubnetWhereUniqueInput
    update: XOR<NetworkSubnetUpdateWithoutParentInput, NetworkSubnetUncheckedUpdateWithoutParentInput>
    create: XOR<NetworkSubnetCreateWithoutParentInput, NetworkSubnetUncheckedCreateWithoutParentInput>
  }

  export type NetworkSubnetUpdateWithWhereUniqueWithoutParentInput = {
    where: NetworkSubnetWhereUniqueInput
    data: XOR<NetworkSubnetUpdateWithoutParentInput, NetworkSubnetUncheckedUpdateWithoutParentInput>
  }

  export type NetworkSubnetUpdateManyWithWhereWithoutParentInput = {
    where: NetworkSubnetScalarWhereInput
    data: XOR<NetworkSubnetUpdateManyMutationInput, NetworkSubnetUncheckedUpdateManyWithoutParentInput>
  }

  export type NetworkIPUpsertWithWhereUniqueWithoutSubnetInput = {
    where: NetworkIPWhereUniqueInput
    update: XOR<NetworkIPUpdateWithoutSubnetInput, NetworkIPUncheckedUpdateWithoutSubnetInput>
    create: XOR<NetworkIPCreateWithoutSubnetInput, NetworkIPUncheckedCreateWithoutSubnetInput>
  }

  export type NetworkIPUpdateWithWhereUniqueWithoutSubnetInput = {
    where: NetworkIPWhereUniqueInput
    data: XOR<NetworkIPUpdateWithoutSubnetInput, NetworkIPUncheckedUpdateWithoutSubnetInput>
  }

  export type NetworkIPUpdateManyWithWhereWithoutSubnetInput = {
    where: NetworkIPScalarWhereInput
    data: XOR<NetworkIPUpdateManyMutationInput, NetworkIPUncheckedUpdateManyWithoutSubnetInput>
  }

  export type NetworkIPScalarWhereInput = {
    AND?: NetworkIPScalarWhereInput | NetworkIPScalarWhereInput[]
    OR?: NetworkIPScalarWhereInput[]
    NOT?: NetworkIPScalarWhereInput | NetworkIPScalarWhereInput[]
    id?: StringFilter<"NetworkIP"> | string
    address?: StringFilter<"NetworkIP"> | string
    subnetId?: StringFilter<"NetworkIP"> | string
    status?: EnumIPStatusFilter<"NetworkIP"> | $Enums.IPStatus
    deviceId?: StringNullableFilter<"NetworkIP"> | string | null
    interface?: StringNullableFilter<"NetworkIP"> | string | null
    fqdn?: StringNullableFilter<"NetworkIP"> | string | null
    purpose?: StringNullableFilter<"NetworkIP"> | string | null
    mac?: StringNullableFilter<"NetworkIP"> | string | null
    tags?: StringNullableFilter<"NetworkIP"> | string | null
    notes?: StringNullableFilter<"NetworkIP"> | string | null
    lastSeen?: DateTimeNullableFilter<"NetworkIP"> | Date | string | null
    createdAt?: DateTimeFilter<"NetworkIP"> | Date | string
    updatedAt?: DateTimeFilter<"NetworkIP"> | Date | string
  }

  export type NetworkSubnetCreateWithoutIpsInput = {
    id?: string
    cidr: string
    name?: string | null
    description?: string | null
    gatewayIpId?: string | null
    tags?: string | null
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    site?: SiteCreateNestedOneWithoutSubnetsInput
    vlan?: VlanCreateNestedOneWithoutSubnetsInput
    parent?: NetworkSubnetCreateNestedOneWithoutChildrenInput
    children?: NetworkSubnetCreateNestedManyWithoutParentInput
  }

  export type NetworkSubnetUncheckedCreateWithoutIpsInput = {
    id?: string
    cidr: string
    name?: string | null
    description?: string | null
    siteId?: string | null
    vlanId?: string | null
    parentId?: string | null
    gatewayIpId?: string | null
    tags?: string | null
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    children?: NetworkSubnetUncheckedCreateNestedManyWithoutParentInput
  }

  export type NetworkSubnetCreateOrConnectWithoutIpsInput = {
    where: NetworkSubnetWhereUniqueInput
    create: XOR<NetworkSubnetCreateWithoutIpsInput, NetworkSubnetUncheckedCreateWithoutIpsInput>
  }

  export type NetworkDeviceCreateWithoutIpsInput = {
    id?: string
    name: string
    type?: $Enums.DeviceType
    mgmtIp?: string | null
    vendor?: string | null
    model?: string | null
    serial?: string | null
    osVersion?: string | null
    tags?: string | null
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    site?: SiteCreateNestedOneWithoutDevicesInput
    services?: NetworkServiceCreateNestedManyWithoutDeviceInput
  }

  export type NetworkDeviceUncheckedCreateWithoutIpsInput = {
    id?: string
    name: string
    type?: $Enums.DeviceType
    siteId?: string | null
    mgmtIp?: string | null
    vendor?: string | null
    model?: string | null
    serial?: string | null
    osVersion?: string | null
    tags?: string | null
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    services?: NetworkServiceUncheckedCreateNestedManyWithoutDeviceInput
  }

  export type NetworkDeviceCreateOrConnectWithoutIpsInput = {
    where: NetworkDeviceWhereUniqueInput
    create: XOR<NetworkDeviceCreateWithoutIpsInput, NetworkDeviceUncheckedCreateWithoutIpsInput>
  }

  export type NetworkSubnetUpsertWithoutIpsInput = {
    update: XOR<NetworkSubnetUpdateWithoutIpsInput, NetworkSubnetUncheckedUpdateWithoutIpsInput>
    create: XOR<NetworkSubnetCreateWithoutIpsInput, NetworkSubnetUncheckedCreateWithoutIpsInput>
    where?: NetworkSubnetWhereInput
  }

  export type NetworkSubnetUpdateToOneWithWhereWithoutIpsInput = {
    where?: NetworkSubnetWhereInput
    data: XOR<NetworkSubnetUpdateWithoutIpsInput, NetworkSubnetUncheckedUpdateWithoutIpsInput>
  }

  export type NetworkSubnetUpdateWithoutIpsInput = {
    id?: StringFieldUpdateOperationsInput | string
    cidr?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    gatewayIpId?: NullableStringFieldUpdateOperationsInput | string | null
    tags?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    site?: SiteUpdateOneWithoutSubnetsNestedInput
    vlan?: VlanUpdateOneWithoutSubnetsNestedInput
    parent?: NetworkSubnetUpdateOneWithoutChildrenNestedInput
    children?: NetworkSubnetUpdateManyWithoutParentNestedInput
  }

  export type NetworkSubnetUncheckedUpdateWithoutIpsInput = {
    id?: StringFieldUpdateOperationsInput | string
    cidr?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    siteId?: NullableStringFieldUpdateOperationsInput | string | null
    vlanId?: NullableStringFieldUpdateOperationsInput | string | null
    parentId?: NullableStringFieldUpdateOperationsInput | string | null
    gatewayIpId?: NullableStringFieldUpdateOperationsInput | string | null
    tags?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    children?: NetworkSubnetUncheckedUpdateManyWithoutParentNestedInput
  }

  export type NetworkDeviceUpsertWithoutIpsInput = {
    update: XOR<NetworkDeviceUpdateWithoutIpsInput, NetworkDeviceUncheckedUpdateWithoutIpsInput>
    create: XOR<NetworkDeviceCreateWithoutIpsInput, NetworkDeviceUncheckedCreateWithoutIpsInput>
    where?: NetworkDeviceWhereInput
  }

  export type NetworkDeviceUpdateToOneWithWhereWithoutIpsInput = {
    where?: NetworkDeviceWhereInput
    data: XOR<NetworkDeviceUpdateWithoutIpsInput, NetworkDeviceUncheckedUpdateWithoutIpsInput>
  }

  export type NetworkDeviceUpdateWithoutIpsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: EnumDeviceTypeFieldUpdateOperationsInput | $Enums.DeviceType
    mgmtIp?: NullableStringFieldUpdateOperationsInput | string | null
    vendor?: NullableStringFieldUpdateOperationsInput | string | null
    model?: NullableStringFieldUpdateOperationsInput | string | null
    serial?: NullableStringFieldUpdateOperationsInput | string | null
    osVersion?: NullableStringFieldUpdateOperationsInput | string | null
    tags?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    site?: SiteUpdateOneWithoutDevicesNestedInput
    services?: NetworkServiceUpdateManyWithoutDeviceNestedInput
  }

  export type NetworkDeviceUncheckedUpdateWithoutIpsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: EnumDeviceTypeFieldUpdateOperationsInput | $Enums.DeviceType
    siteId?: NullableStringFieldUpdateOperationsInput | string | null
    mgmtIp?: NullableStringFieldUpdateOperationsInput | string | null
    vendor?: NullableStringFieldUpdateOperationsInput | string | null
    model?: NullableStringFieldUpdateOperationsInput | string | null
    serial?: NullableStringFieldUpdateOperationsInput | string | null
    osVersion?: NullableStringFieldUpdateOperationsInput | string | null
    tags?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    services?: NetworkServiceUncheckedUpdateManyWithoutDeviceNestedInput
  }

  export type SiteCreateWithoutDevicesInput = {
    id?: string
    name: string
    address?: string | null
    notes?: string | null
    tags?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    subnets?: NetworkSubnetCreateNestedManyWithoutSiteInput
    vlans?: VlanCreateNestedManyWithoutSiteInput
  }

  export type SiteUncheckedCreateWithoutDevicesInput = {
    id?: string
    name: string
    address?: string | null
    notes?: string | null
    tags?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    subnets?: NetworkSubnetUncheckedCreateNestedManyWithoutSiteInput
    vlans?: VlanUncheckedCreateNestedManyWithoutSiteInput
  }

  export type SiteCreateOrConnectWithoutDevicesInput = {
    where: SiteWhereUniqueInput
    create: XOR<SiteCreateWithoutDevicesInput, SiteUncheckedCreateWithoutDevicesInput>
  }

  export type NetworkServiceCreateWithoutDeviceInput = {
    id?: string
    name: string
    protocol?: $Enums.Protocol
    port: number
    externalPort?: number | null
    targetIp?: string | null
    targetFqdn?: string | null
    enabled?: boolean
    description?: string | null
    tags?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type NetworkServiceUncheckedCreateWithoutDeviceInput = {
    id?: string
    name: string
    protocol?: $Enums.Protocol
    port: number
    externalPort?: number | null
    targetIp?: string | null
    targetFqdn?: string | null
    enabled?: boolean
    description?: string | null
    tags?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type NetworkServiceCreateOrConnectWithoutDeviceInput = {
    where: NetworkServiceWhereUniqueInput
    create: XOR<NetworkServiceCreateWithoutDeviceInput, NetworkServiceUncheckedCreateWithoutDeviceInput>
  }

  export type NetworkServiceCreateManyDeviceInputEnvelope = {
    data: NetworkServiceCreateManyDeviceInput | NetworkServiceCreateManyDeviceInput[]
  }

  export type NetworkIPCreateWithoutDeviceInput = {
    id?: string
    address: string
    status?: $Enums.IPStatus
    interface?: string | null
    fqdn?: string | null
    purpose?: string | null
    mac?: string | null
    tags?: string | null
    notes?: string | null
    lastSeen?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    subnet: NetworkSubnetCreateNestedOneWithoutIpsInput
  }

  export type NetworkIPUncheckedCreateWithoutDeviceInput = {
    id?: string
    address: string
    subnetId: string
    status?: $Enums.IPStatus
    interface?: string | null
    fqdn?: string | null
    purpose?: string | null
    mac?: string | null
    tags?: string | null
    notes?: string | null
    lastSeen?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type NetworkIPCreateOrConnectWithoutDeviceInput = {
    where: NetworkIPWhereUniqueInput
    create: XOR<NetworkIPCreateWithoutDeviceInput, NetworkIPUncheckedCreateWithoutDeviceInput>
  }

  export type NetworkIPCreateManyDeviceInputEnvelope = {
    data: NetworkIPCreateManyDeviceInput | NetworkIPCreateManyDeviceInput[]
  }

  export type SiteUpsertWithoutDevicesInput = {
    update: XOR<SiteUpdateWithoutDevicesInput, SiteUncheckedUpdateWithoutDevicesInput>
    create: XOR<SiteCreateWithoutDevicesInput, SiteUncheckedCreateWithoutDevicesInput>
    where?: SiteWhereInput
  }

  export type SiteUpdateToOneWithWhereWithoutDevicesInput = {
    where?: SiteWhereInput
    data: XOR<SiteUpdateWithoutDevicesInput, SiteUncheckedUpdateWithoutDevicesInput>
  }

  export type SiteUpdateWithoutDevicesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    address?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    tags?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    subnets?: NetworkSubnetUpdateManyWithoutSiteNestedInput
    vlans?: VlanUpdateManyWithoutSiteNestedInput
  }

  export type SiteUncheckedUpdateWithoutDevicesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    address?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    tags?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    subnets?: NetworkSubnetUncheckedUpdateManyWithoutSiteNestedInput
    vlans?: VlanUncheckedUpdateManyWithoutSiteNestedInput
  }

  export type NetworkServiceUpsertWithWhereUniqueWithoutDeviceInput = {
    where: NetworkServiceWhereUniqueInput
    update: XOR<NetworkServiceUpdateWithoutDeviceInput, NetworkServiceUncheckedUpdateWithoutDeviceInput>
    create: XOR<NetworkServiceCreateWithoutDeviceInput, NetworkServiceUncheckedCreateWithoutDeviceInput>
  }

  export type NetworkServiceUpdateWithWhereUniqueWithoutDeviceInput = {
    where: NetworkServiceWhereUniqueInput
    data: XOR<NetworkServiceUpdateWithoutDeviceInput, NetworkServiceUncheckedUpdateWithoutDeviceInput>
  }

  export type NetworkServiceUpdateManyWithWhereWithoutDeviceInput = {
    where: NetworkServiceScalarWhereInput
    data: XOR<NetworkServiceUpdateManyMutationInput, NetworkServiceUncheckedUpdateManyWithoutDeviceInput>
  }

  export type NetworkServiceScalarWhereInput = {
    AND?: NetworkServiceScalarWhereInput | NetworkServiceScalarWhereInput[]
    OR?: NetworkServiceScalarWhereInput[]
    NOT?: NetworkServiceScalarWhereInput | NetworkServiceScalarWhereInput[]
    id?: StringFilter<"NetworkService"> | string
    deviceId?: StringFilter<"NetworkService"> | string
    name?: StringFilter<"NetworkService"> | string
    protocol?: EnumProtocolFilter<"NetworkService"> | $Enums.Protocol
    port?: IntFilter<"NetworkService"> | number
    externalPort?: IntNullableFilter<"NetworkService"> | number | null
    targetIp?: StringNullableFilter<"NetworkService"> | string | null
    targetFqdn?: StringNullableFilter<"NetworkService"> | string | null
    enabled?: BoolFilter<"NetworkService"> | boolean
    description?: StringNullableFilter<"NetworkService"> | string | null
    tags?: StringNullableFilter<"NetworkService"> | string | null
    createdAt?: DateTimeFilter<"NetworkService"> | Date | string
    updatedAt?: DateTimeFilter<"NetworkService"> | Date | string
  }

  export type NetworkIPUpsertWithWhereUniqueWithoutDeviceInput = {
    where: NetworkIPWhereUniqueInput
    update: XOR<NetworkIPUpdateWithoutDeviceInput, NetworkIPUncheckedUpdateWithoutDeviceInput>
    create: XOR<NetworkIPCreateWithoutDeviceInput, NetworkIPUncheckedCreateWithoutDeviceInput>
  }

  export type NetworkIPUpdateWithWhereUniqueWithoutDeviceInput = {
    where: NetworkIPWhereUniqueInput
    data: XOR<NetworkIPUpdateWithoutDeviceInput, NetworkIPUncheckedUpdateWithoutDeviceInput>
  }

  export type NetworkIPUpdateManyWithWhereWithoutDeviceInput = {
    where: NetworkIPScalarWhereInput
    data: XOR<NetworkIPUpdateManyMutationInput, NetworkIPUncheckedUpdateManyWithoutDeviceInput>
  }

  export type NetworkDeviceCreateWithoutServicesInput = {
    id?: string
    name: string
    type?: $Enums.DeviceType
    mgmtIp?: string | null
    vendor?: string | null
    model?: string | null
    serial?: string | null
    osVersion?: string | null
    tags?: string | null
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    site?: SiteCreateNestedOneWithoutDevicesInput
    ips?: NetworkIPCreateNestedManyWithoutDeviceInput
  }

  export type NetworkDeviceUncheckedCreateWithoutServicesInput = {
    id?: string
    name: string
    type?: $Enums.DeviceType
    siteId?: string | null
    mgmtIp?: string | null
    vendor?: string | null
    model?: string | null
    serial?: string | null
    osVersion?: string | null
    tags?: string | null
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    ips?: NetworkIPUncheckedCreateNestedManyWithoutDeviceInput
  }

  export type NetworkDeviceCreateOrConnectWithoutServicesInput = {
    where: NetworkDeviceWhereUniqueInput
    create: XOR<NetworkDeviceCreateWithoutServicesInput, NetworkDeviceUncheckedCreateWithoutServicesInput>
  }

  export type NetworkDeviceUpsertWithoutServicesInput = {
    update: XOR<NetworkDeviceUpdateWithoutServicesInput, NetworkDeviceUncheckedUpdateWithoutServicesInput>
    create: XOR<NetworkDeviceCreateWithoutServicesInput, NetworkDeviceUncheckedCreateWithoutServicesInput>
    where?: NetworkDeviceWhereInput
  }

  export type NetworkDeviceUpdateToOneWithWhereWithoutServicesInput = {
    where?: NetworkDeviceWhereInput
    data: XOR<NetworkDeviceUpdateWithoutServicesInput, NetworkDeviceUncheckedUpdateWithoutServicesInput>
  }

  export type NetworkDeviceUpdateWithoutServicesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: EnumDeviceTypeFieldUpdateOperationsInput | $Enums.DeviceType
    mgmtIp?: NullableStringFieldUpdateOperationsInput | string | null
    vendor?: NullableStringFieldUpdateOperationsInput | string | null
    model?: NullableStringFieldUpdateOperationsInput | string | null
    serial?: NullableStringFieldUpdateOperationsInput | string | null
    osVersion?: NullableStringFieldUpdateOperationsInput | string | null
    tags?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    site?: SiteUpdateOneWithoutDevicesNestedInput
    ips?: NetworkIPUpdateManyWithoutDeviceNestedInput
  }

  export type NetworkDeviceUncheckedUpdateWithoutServicesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: EnumDeviceTypeFieldUpdateOperationsInput | $Enums.DeviceType
    siteId?: NullableStringFieldUpdateOperationsInput | string | null
    mgmtIp?: NullableStringFieldUpdateOperationsInput | string | null
    vendor?: NullableStringFieldUpdateOperationsInput | string | null
    model?: NullableStringFieldUpdateOperationsInput | string | null
    serial?: NullableStringFieldUpdateOperationsInput | string | null
    osVersion?: NullableStringFieldUpdateOperationsInput | string | null
    tags?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    ips?: NetworkIPUncheckedUpdateManyWithoutDeviceNestedInput
  }

  export type SubscriptionCreateManyUserInput = {
    id?: string
    planName: string
    price: number
    status: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SubscriptionUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    planName?: StringFieldUpdateOperationsInput | string
    price?: FloatFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    invoices?: InvoiceUpdateManyWithoutSubscriptionNestedInput
  }

  export type SubscriptionUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    planName?: StringFieldUpdateOperationsInput | string
    price?: FloatFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    invoices?: InvoiceUncheckedUpdateManyWithoutSubscriptionNestedInput
  }

  export type SubscriptionUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    planName?: StringFieldUpdateOperationsInput | string
    price?: FloatFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type InvoiceCreateManySubscriptionInput = {
    id?: string
    amount: number
    status: string
    dueDate: Date | string
    paidAt?: Date | string | null
    createdAt?: Date | string
  }

  export type InvoiceUpdateWithoutSubscriptionInput = {
    id?: StringFieldUpdateOperationsInput | string
    amount?: FloatFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    dueDate?: DateTimeFieldUpdateOperationsInput | Date | string
    paidAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type InvoiceUncheckedUpdateWithoutSubscriptionInput = {
    id?: StringFieldUpdateOperationsInput | string
    amount?: FloatFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    dueDate?: DateTimeFieldUpdateOperationsInput | Date | string
    paidAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type InvoiceUncheckedUpdateManyWithoutSubscriptionInput = {
    id?: StringFieldUpdateOperationsInput | string
    amount?: FloatFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    dueDate?: DateTimeFieldUpdateOperationsInput | Date | string
    paidAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProxmoxNodeCreateManyServerInput = {
    id?: string
    name: string
    status?: string | null
    maxcpu?: number | null
    maxmem?: bigint | number | null
    cpu?: number | null
    mem?: bigint | number | null
    uptime?: number | null
    raw?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ProxmoxVMCreateManyServerInput = {
    id?: string
    vmid: number
    nodeName: string
    name?: string | null
    type?: string | null
    status?: string | null
    maxcpu?: number | null
    maxmem?: bigint | number | null
    cpu?: number | null
    mem?: bigint | number | null
    tags?: string | null
    sshHost?: string | null
    sshPort?: number | null
    sshUser?: string | null
    raw?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ProxmoxNodeUpdateWithoutServerInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    status?: NullableStringFieldUpdateOperationsInput | string | null
    maxcpu?: NullableIntFieldUpdateOperationsInput | number | null
    maxmem?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    cpu?: NullableFloatFieldUpdateOperationsInput | number | null
    mem?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    uptime?: NullableIntFieldUpdateOperationsInput | number | null
    raw?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    vms?: ProxmoxVMUpdateManyWithoutNodeNestedInput
  }

  export type ProxmoxNodeUncheckedUpdateWithoutServerInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    status?: NullableStringFieldUpdateOperationsInput | string | null
    maxcpu?: NullableIntFieldUpdateOperationsInput | number | null
    maxmem?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    cpu?: NullableFloatFieldUpdateOperationsInput | number | null
    mem?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    uptime?: NullableIntFieldUpdateOperationsInput | number | null
    raw?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    vms?: ProxmoxVMUncheckedUpdateManyWithoutNodeNestedInput
  }

  export type ProxmoxNodeUncheckedUpdateManyWithoutServerInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    status?: NullableStringFieldUpdateOperationsInput | string | null
    maxcpu?: NullableIntFieldUpdateOperationsInput | number | null
    maxmem?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    cpu?: NullableFloatFieldUpdateOperationsInput | number | null
    mem?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    uptime?: NullableIntFieldUpdateOperationsInput | number | null
    raw?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProxmoxVMUpdateWithoutServerInput = {
    id?: StringFieldUpdateOperationsInput | string
    vmid?: IntFieldUpdateOperationsInput | number
    name?: NullableStringFieldUpdateOperationsInput | string | null
    type?: NullableStringFieldUpdateOperationsInput | string | null
    status?: NullableStringFieldUpdateOperationsInput | string | null
    maxcpu?: NullableIntFieldUpdateOperationsInput | number | null
    maxmem?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    cpu?: NullableFloatFieldUpdateOperationsInput | number | null
    mem?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    tags?: NullableStringFieldUpdateOperationsInput | string | null
    sshHost?: NullableStringFieldUpdateOperationsInput | string | null
    sshPort?: NullableIntFieldUpdateOperationsInput | number | null
    sshUser?: NullableStringFieldUpdateOperationsInput | string | null
    raw?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    node?: ProxmoxNodeUpdateOneWithoutVmsNestedInput
    metrics?: ProxmoxMetricUpdateManyWithoutVmNestedInput
  }

  export type ProxmoxVMUncheckedUpdateWithoutServerInput = {
    id?: StringFieldUpdateOperationsInput | string
    vmid?: IntFieldUpdateOperationsInput | number
    nodeName?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    type?: NullableStringFieldUpdateOperationsInput | string | null
    status?: NullableStringFieldUpdateOperationsInput | string | null
    maxcpu?: NullableIntFieldUpdateOperationsInput | number | null
    maxmem?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    cpu?: NullableFloatFieldUpdateOperationsInput | number | null
    mem?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    tags?: NullableStringFieldUpdateOperationsInput | string | null
    sshHost?: NullableStringFieldUpdateOperationsInput | string | null
    sshPort?: NullableIntFieldUpdateOperationsInput | number | null
    sshUser?: NullableStringFieldUpdateOperationsInput | string | null
    raw?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    metrics?: ProxmoxMetricUncheckedUpdateManyWithoutVmNestedInput
  }

  export type ProxmoxVMUncheckedUpdateManyWithoutServerInput = {
    id?: StringFieldUpdateOperationsInput | string
    vmid?: IntFieldUpdateOperationsInput | number
    nodeName?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    type?: NullableStringFieldUpdateOperationsInput | string | null
    status?: NullableStringFieldUpdateOperationsInput | string | null
    maxcpu?: NullableIntFieldUpdateOperationsInput | number | null
    maxmem?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    cpu?: NullableFloatFieldUpdateOperationsInput | number | null
    mem?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    tags?: NullableStringFieldUpdateOperationsInput | string | null
    sshHost?: NullableStringFieldUpdateOperationsInput | string | null
    sshPort?: NullableIntFieldUpdateOperationsInput | number | null
    sshUser?: NullableStringFieldUpdateOperationsInput | string | null
    raw?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProxmoxVMCreateManyNodeInput = {
    id?: string
    vmid: number
    name?: string | null
    type?: string | null
    status?: string | null
    maxcpu?: number | null
    maxmem?: bigint | number | null
    cpu?: number | null
    mem?: bigint | number | null
    tags?: string | null
    sshHost?: string | null
    sshPort?: number | null
    sshUser?: string | null
    raw?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ProxmoxVMUpdateWithoutNodeInput = {
    id?: StringFieldUpdateOperationsInput | string
    vmid?: IntFieldUpdateOperationsInput | number
    name?: NullableStringFieldUpdateOperationsInput | string | null
    type?: NullableStringFieldUpdateOperationsInput | string | null
    status?: NullableStringFieldUpdateOperationsInput | string | null
    maxcpu?: NullableIntFieldUpdateOperationsInput | number | null
    maxmem?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    cpu?: NullableFloatFieldUpdateOperationsInput | number | null
    mem?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    tags?: NullableStringFieldUpdateOperationsInput | string | null
    sshHost?: NullableStringFieldUpdateOperationsInput | string | null
    sshPort?: NullableIntFieldUpdateOperationsInput | number | null
    sshUser?: NullableStringFieldUpdateOperationsInput | string | null
    raw?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    metrics?: ProxmoxMetricUpdateManyWithoutVmNestedInput
    server?: ProxmoxServerUpdateOneWithoutVmsNestedInput
  }

  export type ProxmoxVMUncheckedUpdateWithoutNodeInput = {
    id?: StringFieldUpdateOperationsInput | string
    vmid?: IntFieldUpdateOperationsInput | number
    name?: NullableStringFieldUpdateOperationsInput | string | null
    type?: NullableStringFieldUpdateOperationsInput | string | null
    status?: NullableStringFieldUpdateOperationsInput | string | null
    maxcpu?: NullableIntFieldUpdateOperationsInput | number | null
    maxmem?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    cpu?: NullableFloatFieldUpdateOperationsInput | number | null
    mem?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    tags?: NullableStringFieldUpdateOperationsInput | string | null
    sshHost?: NullableStringFieldUpdateOperationsInput | string | null
    sshPort?: NullableIntFieldUpdateOperationsInput | number | null
    sshUser?: NullableStringFieldUpdateOperationsInput | string | null
    raw?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    metrics?: ProxmoxMetricUncheckedUpdateManyWithoutVmNestedInput
  }

  export type ProxmoxVMUncheckedUpdateManyWithoutNodeInput = {
    id?: StringFieldUpdateOperationsInput | string
    vmid?: IntFieldUpdateOperationsInput | number
    name?: NullableStringFieldUpdateOperationsInput | string | null
    type?: NullableStringFieldUpdateOperationsInput | string | null
    status?: NullableStringFieldUpdateOperationsInput | string | null
    maxcpu?: NullableIntFieldUpdateOperationsInput | number | null
    maxmem?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    cpu?: NullableFloatFieldUpdateOperationsInput | number | null
    mem?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    tags?: NullableStringFieldUpdateOperationsInput | string | null
    sshHost?: NullableStringFieldUpdateOperationsInput | string | null
    sshPort?: NullableIntFieldUpdateOperationsInput | number | null
    sshUser?: NullableStringFieldUpdateOperationsInput | string | null
    raw?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProxmoxMetricCreateManyVmInput = {
    id?: string
    vmNumericId?: number | null
    nodeName?: string | null
    serverId?: string | null
    cpu?: number | null
    mem?: bigint | number | null
    disk?: number | null
    netin?: bigint | number | null
    netout?: bigint | number | null
    ts?: Date | string
  }

  export type ProxmoxMetricUpdateWithoutVmInput = {
    id?: StringFieldUpdateOperationsInput | string
    vmNumericId?: NullableIntFieldUpdateOperationsInput | number | null
    nodeName?: NullableStringFieldUpdateOperationsInput | string | null
    serverId?: NullableStringFieldUpdateOperationsInput | string | null
    cpu?: NullableFloatFieldUpdateOperationsInput | number | null
    mem?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    disk?: NullableFloatFieldUpdateOperationsInput | number | null
    netin?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    netout?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    ts?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProxmoxMetricUncheckedUpdateWithoutVmInput = {
    id?: StringFieldUpdateOperationsInput | string
    vmNumericId?: NullableIntFieldUpdateOperationsInput | number | null
    nodeName?: NullableStringFieldUpdateOperationsInput | string | null
    serverId?: NullableStringFieldUpdateOperationsInput | string | null
    cpu?: NullableFloatFieldUpdateOperationsInput | number | null
    mem?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    disk?: NullableFloatFieldUpdateOperationsInput | number | null
    netin?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    netout?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    ts?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProxmoxMetricUncheckedUpdateManyWithoutVmInput = {
    id?: StringFieldUpdateOperationsInput | string
    vmNumericId?: NullableIntFieldUpdateOperationsInput | number | null
    nodeName?: NullableStringFieldUpdateOperationsInput | string | null
    serverId?: NullableStringFieldUpdateOperationsInput | string | null
    cpu?: NullableFloatFieldUpdateOperationsInput | number | null
    mem?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    disk?: NullableFloatFieldUpdateOperationsInput | number | null
    netin?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    netout?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    ts?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NetworkSubnetCreateManySiteInput = {
    id?: string
    cidr: string
    name?: string | null
    description?: string | null
    vlanId?: string | null
    parentId?: string | null
    gatewayIpId?: string | null
    tags?: string | null
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type NetworkDeviceCreateManySiteInput = {
    id?: string
    name: string
    type?: $Enums.DeviceType
    mgmtIp?: string | null
    vendor?: string | null
    model?: string | null
    serial?: string | null
    osVersion?: string | null
    tags?: string | null
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type VlanCreateManySiteInput = {
    id?: string
    name: string
    vid: number
    description?: string | null
    tags?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type NetworkSubnetUpdateWithoutSiteInput = {
    id?: StringFieldUpdateOperationsInput | string
    cidr?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    gatewayIpId?: NullableStringFieldUpdateOperationsInput | string | null
    tags?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    vlan?: VlanUpdateOneWithoutSubnetsNestedInput
    parent?: NetworkSubnetUpdateOneWithoutChildrenNestedInput
    children?: NetworkSubnetUpdateManyWithoutParentNestedInput
    ips?: NetworkIPUpdateManyWithoutSubnetNestedInput
  }

  export type NetworkSubnetUncheckedUpdateWithoutSiteInput = {
    id?: StringFieldUpdateOperationsInput | string
    cidr?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    vlanId?: NullableStringFieldUpdateOperationsInput | string | null
    parentId?: NullableStringFieldUpdateOperationsInput | string | null
    gatewayIpId?: NullableStringFieldUpdateOperationsInput | string | null
    tags?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    children?: NetworkSubnetUncheckedUpdateManyWithoutParentNestedInput
    ips?: NetworkIPUncheckedUpdateManyWithoutSubnetNestedInput
  }

  export type NetworkSubnetUncheckedUpdateManyWithoutSiteInput = {
    id?: StringFieldUpdateOperationsInput | string
    cidr?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    vlanId?: NullableStringFieldUpdateOperationsInput | string | null
    parentId?: NullableStringFieldUpdateOperationsInput | string | null
    gatewayIpId?: NullableStringFieldUpdateOperationsInput | string | null
    tags?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NetworkDeviceUpdateWithoutSiteInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: EnumDeviceTypeFieldUpdateOperationsInput | $Enums.DeviceType
    mgmtIp?: NullableStringFieldUpdateOperationsInput | string | null
    vendor?: NullableStringFieldUpdateOperationsInput | string | null
    model?: NullableStringFieldUpdateOperationsInput | string | null
    serial?: NullableStringFieldUpdateOperationsInput | string | null
    osVersion?: NullableStringFieldUpdateOperationsInput | string | null
    tags?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    services?: NetworkServiceUpdateManyWithoutDeviceNestedInput
    ips?: NetworkIPUpdateManyWithoutDeviceNestedInput
  }

  export type NetworkDeviceUncheckedUpdateWithoutSiteInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: EnumDeviceTypeFieldUpdateOperationsInput | $Enums.DeviceType
    mgmtIp?: NullableStringFieldUpdateOperationsInput | string | null
    vendor?: NullableStringFieldUpdateOperationsInput | string | null
    model?: NullableStringFieldUpdateOperationsInput | string | null
    serial?: NullableStringFieldUpdateOperationsInput | string | null
    osVersion?: NullableStringFieldUpdateOperationsInput | string | null
    tags?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    services?: NetworkServiceUncheckedUpdateManyWithoutDeviceNestedInput
    ips?: NetworkIPUncheckedUpdateManyWithoutDeviceNestedInput
  }

  export type NetworkDeviceUncheckedUpdateManyWithoutSiteInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: EnumDeviceTypeFieldUpdateOperationsInput | $Enums.DeviceType
    mgmtIp?: NullableStringFieldUpdateOperationsInput | string | null
    vendor?: NullableStringFieldUpdateOperationsInput | string | null
    model?: NullableStringFieldUpdateOperationsInput | string | null
    serial?: NullableStringFieldUpdateOperationsInput | string | null
    osVersion?: NullableStringFieldUpdateOperationsInput | string | null
    tags?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type VlanUpdateWithoutSiteInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    vid?: IntFieldUpdateOperationsInput | number
    description?: NullableStringFieldUpdateOperationsInput | string | null
    tags?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    subnets?: NetworkSubnetUpdateManyWithoutVlanNestedInput
  }

  export type VlanUncheckedUpdateWithoutSiteInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    vid?: IntFieldUpdateOperationsInput | number
    description?: NullableStringFieldUpdateOperationsInput | string | null
    tags?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    subnets?: NetworkSubnetUncheckedUpdateManyWithoutVlanNestedInput
  }

  export type VlanUncheckedUpdateManyWithoutSiteInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    vid?: IntFieldUpdateOperationsInput | number
    description?: NullableStringFieldUpdateOperationsInput | string | null
    tags?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NetworkSubnetCreateManyVlanInput = {
    id?: string
    cidr: string
    name?: string | null
    description?: string | null
    siteId?: string | null
    parentId?: string | null
    gatewayIpId?: string | null
    tags?: string | null
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type NetworkSubnetUpdateWithoutVlanInput = {
    id?: StringFieldUpdateOperationsInput | string
    cidr?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    gatewayIpId?: NullableStringFieldUpdateOperationsInput | string | null
    tags?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    site?: SiteUpdateOneWithoutSubnetsNestedInput
    parent?: NetworkSubnetUpdateOneWithoutChildrenNestedInput
    children?: NetworkSubnetUpdateManyWithoutParentNestedInput
    ips?: NetworkIPUpdateManyWithoutSubnetNestedInput
  }

  export type NetworkSubnetUncheckedUpdateWithoutVlanInput = {
    id?: StringFieldUpdateOperationsInput | string
    cidr?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    siteId?: NullableStringFieldUpdateOperationsInput | string | null
    parentId?: NullableStringFieldUpdateOperationsInput | string | null
    gatewayIpId?: NullableStringFieldUpdateOperationsInput | string | null
    tags?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    children?: NetworkSubnetUncheckedUpdateManyWithoutParentNestedInput
    ips?: NetworkIPUncheckedUpdateManyWithoutSubnetNestedInput
  }

  export type NetworkSubnetUncheckedUpdateManyWithoutVlanInput = {
    id?: StringFieldUpdateOperationsInput | string
    cidr?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    siteId?: NullableStringFieldUpdateOperationsInput | string | null
    parentId?: NullableStringFieldUpdateOperationsInput | string | null
    gatewayIpId?: NullableStringFieldUpdateOperationsInput | string | null
    tags?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NetworkSubnetCreateManyParentInput = {
    id?: string
    cidr: string
    name?: string | null
    description?: string | null
    siteId?: string | null
    vlanId?: string | null
    gatewayIpId?: string | null
    tags?: string | null
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type NetworkIPCreateManySubnetInput = {
    id?: string
    address: string
    status?: $Enums.IPStatus
    deviceId?: string | null
    interface?: string | null
    fqdn?: string | null
    purpose?: string | null
    mac?: string | null
    tags?: string | null
    notes?: string | null
    lastSeen?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type NetworkSubnetUpdateWithoutParentInput = {
    id?: StringFieldUpdateOperationsInput | string
    cidr?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    gatewayIpId?: NullableStringFieldUpdateOperationsInput | string | null
    tags?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    site?: SiteUpdateOneWithoutSubnetsNestedInput
    vlan?: VlanUpdateOneWithoutSubnetsNestedInput
    children?: NetworkSubnetUpdateManyWithoutParentNestedInput
    ips?: NetworkIPUpdateManyWithoutSubnetNestedInput
  }

  export type NetworkSubnetUncheckedUpdateWithoutParentInput = {
    id?: StringFieldUpdateOperationsInput | string
    cidr?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    siteId?: NullableStringFieldUpdateOperationsInput | string | null
    vlanId?: NullableStringFieldUpdateOperationsInput | string | null
    gatewayIpId?: NullableStringFieldUpdateOperationsInput | string | null
    tags?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    children?: NetworkSubnetUncheckedUpdateManyWithoutParentNestedInput
    ips?: NetworkIPUncheckedUpdateManyWithoutSubnetNestedInput
  }

  export type NetworkSubnetUncheckedUpdateManyWithoutParentInput = {
    id?: StringFieldUpdateOperationsInput | string
    cidr?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    siteId?: NullableStringFieldUpdateOperationsInput | string | null
    vlanId?: NullableStringFieldUpdateOperationsInput | string | null
    gatewayIpId?: NullableStringFieldUpdateOperationsInput | string | null
    tags?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NetworkIPUpdateWithoutSubnetInput = {
    id?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    status?: EnumIPStatusFieldUpdateOperationsInput | $Enums.IPStatus
    interface?: NullableStringFieldUpdateOperationsInput | string | null
    fqdn?: NullableStringFieldUpdateOperationsInput | string | null
    purpose?: NullableStringFieldUpdateOperationsInput | string | null
    mac?: NullableStringFieldUpdateOperationsInput | string | null
    tags?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    lastSeen?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    device?: NetworkDeviceUpdateOneWithoutIpsNestedInput
  }

  export type NetworkIPUncheckedUpdateWithoutSubnetInput = {
    id?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    status?: EnumIPStatusFieldUpdateOperationsInput | $Enums.IPStatus
    deviceId?: NullableStringFieldUpdateOperationsInput | string | null
    interface?: NullableStringFieldUpdateOperationsInput | string | null
    fqdn?: NullableStringFieldUpdateOperationsInput | string | null
    purpose?: NullableStringFieldUpdateOperationsInput | string | null
    mac?: NullableStringFieldUpdateOperationsInput | string | null
    tags?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    lastSeen?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NetworkIPUncheckedUpdateManyWithoutSubnetInput = {
    id?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    status?: EnumIPStatusFieldUpdateOperationsInput | $Enums.IPStatus
    deviceId?: NullableStringFieldUpdateOperationsInput | string | null
    interface?: NullableStringFieldUpdateOperationsInput | string | null
    fqdn?: NullableStringFieldUpdateOperationsInput | string | null
    purpose?: NullableStringFieldUpdateOperationsInput | string | null
    mac?: NullableStringFieldUpdateOperationsInput | string | null
    tags?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    lastSeen?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NetworkServiceCreateManyDeviceInput = {
    id?: string
    name: string
    protocol?: $Enums.Protocol
    port: number
    externalPort?: number | null
    targetIp?: string | null
    targetFqdn?: string | null
    enabled?: boolean
    description?: string | null
    tags?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type NetworkIPCreateManyDeviceInput = {
    id?: string
    address: string
    subnetId: string
    status?: $Enums.IPStatus
    interface?: string | null
    fqdn?: string | null
    purpose?: string | null
    mac?: string | null
    tags?: string | null
    notes?: string | null
    lastSeen?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type NetworkServiceUpdateWithoutDeviceInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    protocol?: EnumProtocolFieldUpdateOperationsInput | $Enums.Protocol
    port?: IntFieldUpdateOperationsInput | number
    externalPort?: NullableIntFieldUpdateOperationsInput | number | null
    targetIp?: NullableStringFieldUpdateOperationsInput | string | null
    targetFqdn?: NullableStringFieldUpdateOperationsInput | string | null
    enabled?: BoolFieldUpdateOperationsInput | boolean
    description?: NullableStringFieldUpdateOperationsInput | string | null
    tags?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NetworkServiceUncheckedUpdateWithoutDeviceInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    protocol?: EnumProtocolFieldUpdateOperationsInput | $Enums.Protocol
    port?: IntFieldUpdateOperationsInput | number
    externalPort?: NullableIntFieldUpdateOperationsInput | number | null
    targetIp?: NullableStringFieldUpdateOperationsInput | string | null
    targetFqdn?: NullableStringFieldUpdateOperationsInput | string | null
    enabled?: BoolFieldUpdateOperationsInput | boolean
    description?: NullableStringFieldUpdateOperationsInput | string | null
    tags?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NetworkServiceUncheckedUpdateManyWithoutDeviceInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    protocol?: EnumProtocolFieldUpdateOperationsInput | $Enums.Protocol
    port?: IntFieldUpdateOperationsInput | number
    externalPort?: NullableIntFieldUpdateOperationsInput | number | null
    targetIp?: NullableStringFieldUpdateOperationsInput | string | null
    targetFqdn?: NullableStringFieldUpdateOperationsInput | string | null
    enabled?: BoolFieldUpdateOperationsInput | boolean
    description?: NullableStringFieldUpdateOperationsInput | string | null
    tags?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NetworkIPUpdateWithoutDeviceInput = {
    id?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    status?: EnumIPStatusFieldUpdateOperationsInput | $Enums.IPStatus
    interface?: NullableStringFieldUpdateOperationsInput | string | null
    fqdn?: NullableStringFieldUpdateOperationsInput | string | null
    purpose?: NullableStringFieldUpdateOperationsInput | string | null
    mac?: NullableStringFieldUpdateOperationsInput | string | null
    tags?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    lastSeen?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    subnet?: NetworkSubnetUpdateOneRequiredWithoutIpsNestedInput
  }

  export type NetworkIPUncheckedUpdateWithoutDeviceInput = {
    id?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    subnetId?: StringFieldUpdateOperationsInput | string
    status?: EnumIPStatusFieldUpdateOperationsInput | $Enums.IPStatus
    interface?: NullableStringFieldUpdateOperationsInput | string | null
    fqdn?: NullableStringFieldUpdateOperationsInput | string | null
    purpose?: NullableStringFieldUpdateOperationsInput | string | null
    mac?: NullableStringFieldUpdateOperationsInput | string | null
    tags?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    lastSeen?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NetworkIPUncheckedUpdateManyWithoutDeviceInput = {
    id?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    subnetId?: StringFieldUpdateOperationsInput | string
    status?: EnumIPStatusFieldUpdateOperationsInput | $Enums.IPStatus
    interface?: NullableStringFieldUpdateOperationsInput | string | null
    fqdn?: NullableStringFieldUpdateOperationsInput | string | null
    purpose?: NullableStringFieldUpdateOperationsInput | string | null
    mac?: NullableStringFieldUpdateOperationsInput | string | null
    tags?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    lastSeen?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }



  /**
   * Batch Payload for updateMany & deleteMany & createMany
   */

  export type BatchPayload = {
    count: number
  }

  /**
   * DMMF
   */
  export const dmmf: runtime.BaseDMMF
}